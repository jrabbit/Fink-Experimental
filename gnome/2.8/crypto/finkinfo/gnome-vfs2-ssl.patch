diff -Naur gnome-vfs-2.8.1-old/libgnomevfs/gnome-vfs-cdrom.c gnome-vfs-2.8.1/libgnomevfs/gnome-vfs-cdrom.c
--- gnome-vfs-2.8.1-old/libgnomevfs/gnome-vfs-cdrom.c	Thu Aug 26 09:23:33 2004
+++ gnome-vfs-2.8.1/libgnomevfs/gnome-vfs-cdrom.c	Wed Oct  6 10:52:48 2004
@@ -143,6 +143,7 @@
 #endif /* defined(__FreeBSD__) */
 	return type;
 #else
+	#if !defined(__APPLE__)
 	*fd = open (vol_dev_path, O_RDONLY|O_NONBLOCK);
 	if (*fd  < 0) {
 		return -1;
@@ -153,6 +154,7 @@
 		return -1;
 	}
 	return ioctl (*fd, CDROM_DISC_STATUS, CDSL_CURRENT);
+	#endif
 #endif
 }
 
diff -Naur gnome-vfs-2.8.1-old/libgnomevfs/gnome-vfs-utils.c gnome-vfs-2.8.1/libgnomevfs/gnome-vfs-utils.c
--- gnome-vfs-2.8.1-old/libgnomevfs/gnome-vfs-utils.c	Fri Aug 27 09:32:11 2004
+++ gnome-vfs-2.8.1/libgnomevfs/gnome-vfs-utils.c	Wed Oct  6 10:52:53 2004
@@ -46,6 +46,9 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/param.h>
+#include <sys/mount.h>
+#define HAVE_STATVFS 0
 #include <unistd.h>
 
 #if HAVE_SYS_STATVFS_H
diff -Naur gnome-vfs-2.8.1-old/libgnomevfs/gnome-vfs-utils.c.orig gnome-vfs-2.8.1/libgnomevfs/gnome-vfs-utils.c.orig
--- gnome-vfs-2.8.1-old/libgnomevfs/gnome-vfs-utils.c.orig	Wed Dec 31 19:00:00 1969
+++ gnome-vfs-2.8.1/libgnomevfs/gnome-vfs-utils.c.orig	Fri Aug 27 09:32:11 2004
@@ -0,0 +1,2112 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+
+/* gnome-vfs-utils.c - Private utility functions for the GNOME Virtual
+   File System.
+
+   Copyright (C) 1999 Free Software Foundation
+   Copyright (C) 2000, 2001 Eazel, Inc.
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Authors: Ettore Perazzoli <ettore@comm2000.it>
+   	    John Sullivan <sullivan@eazel.com> 
+            Darin Adler <darin@eazel.com>
+*/
+
+#include <config.h>
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include "gnome-vfs-utils.h"
+
+#include "gnome-vfs-i18n.h"
+#include "gnome-vfs-private-utils.h"
+#include "gnome-vfs-ops.h"
+#include "gnome-vfs-mime-handlers.h"
+#include "gnome-vfs-mime-private.h"
+#include <glib/gstrfuncs.h>
+#include <glib/gutils.h>
+#include <gconf/gconf-client.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#if HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+
+#if HAVE_SYS_VFS_H
+#include <sys/vfs.h>
+#elif HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+#define KILOBYTE_FACTOR 1024.0
+#define MEGABYTE_FACTOR (1024.0 * 1024.0)
+#define GIGABYTE_FACTOR (1024.0 * 1024.0 * 1024.0)
+
+#define READ_CHUNK_SIZE 8192
+
+#define MAX_SYMLINKS_FOLLOWED 32
+
+
+/**
+ * gnome_vfs_format_file_size_for_display:
+ * @size:
+ * 
+ * Formats the file size passed in @bytes in a way that is easy for
+ * the user to read. Gives the size in bytes, kilobytes, megabytes or
+ * gigabytes, choosing whatever is appropriate.
+ * 
+ * Returns: a newly allocated string with the size ready to be shown.
+ **/
+
+gchar*
+gnome_vfs_format_file_size_for_display (GnomeVFSFileSize size)
+{
+	if (size < (GnomeVFSFileSize) KILOBYTE_FACTOR) {
+		return g_strdup_printf (dngettext(GETTEXT_PACKAGE, "%u byte", "%u bytes",(guint) size), (guint) size);
+	} else {
+		gdouble displayed_size;
+
+		if (size < (GnomeVFSFileSize) MEGABYTE_FACTOR) {
+			displayed_size = (gdouble) size / KILOBYTE_FACTOR;
+			return g_strdup_printf (_("%.1f KB"),
+						       displayed_size);
+		} else if (size < (GnomeVFSFileSize) GIGABYTE_FACTOR) {
+			displayed_size = (gdouble) size / MEGABYTE_FACTOR;
+			return g_strdup_printf (_("%.1f MB"),
+						       displayed_size);
+		} else {
+			displayed_size = (gdouble) size / GIGABYTE_FACTOR;
+			return g_strdup_printf (_("%.1f GB"),
+						       displayed_size);
+		}
+	}
+}
+
+typedef enum {
+	UNSAFE_ALL        = 0x1,  /* Escape all unsafe characters   */
+	UNSAFE_ALLOW_PLUS = 0x2,  /* Allows '+'  */
+	UNSAFE_PATH       = 0x4,  /* Allows '/' and '?' and '&' and '='  */
+	UNSAFE_DOS_PATH   = 0x8,  /* Allows '/' and '?' and '&' and '=' and ':' */
+	UNSAFE_HOST       = 0x10, /* Allows '/' and ':' and '@' */
+	UNSAFE_SLASHES    = 0x20  /* Allows all characters except for '/' and '%' */
+} UnsafeCharacterSet;
+
+static const guchar acceptable[96] =
+{ /* X0   X1   X2   X3   X4   X5   X6   X7   X8   X9   XA   XB   XC   XD   XE   XF */
+    0x00,0x3F,0x20,0x20,0x20,0x00,0x2C,0x3F,0x3F,0x3F,0x3F,0x22,0x20,0x3F,0x3F,0x1C, /* 2X  !"#$%&'()*+,-./   */
+    0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x38,0x20,0x20,0x2C,0x20,0x2C, /* 3X 0123456789:;<=>?   */
+    0x30,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F, /* 4X @ABCDEFGHIJKLMNO   */
+    0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x20,0x3F, /* 5X PQRSTUVWXYZ[\]^_   */
+    0x20,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F, /* 6X `abcdefghijklmno   */
+    0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x3F,0x20  /* 7X pqrstuvwxyz{|}~DEL */
+};
+
+enum {
+	RESERVED = 1,
+	UNRESERVED,
+	DELIMITERS,
+	UNWISE,
+	CONTROL,
+	SPACE	
+};
+
+static const guchar uri_character_kind[128] =
+{
+    CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   , 
+    CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,
+    CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,
+    CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,CONTROL   ,
+    /* ' '        !          "          #          $          %          &          '      */
+    SPACE     ,UNRESERVED,DELIMITERS,DELIMITERS,RESERVED  ,DELIMITERS,RESERVED  ,UNRESERVED,
+    /*  (         )          *          +          ,          -          .          /      */
+    UNRESERVED,UNRESERVED,UNRESERVED,RESERVED  ,RESERVED  ,UNRESERVED,UNRESERVED,RESERVED  , 
+    /*  0         1          2          3          4          5          6          7      */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  8         9          :          ;          <          =          >          ?      */
+    UNRESERVED,UNRESERVED,RESERVED  ,RESERVED  ,DELIMITERS,RESERVED  ,DELIMITERS,RESERVED  ,
+    /*  @         A          B          C          D          E          F          G      */
+    RESERVED  ,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  H         I          J          K          L          M          N          O      */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  P         Q          R          S          T          U          V          W      */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  X         Y          Z          [          \          ]          ^          _      */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNWISE    ,UNWISE    ,UNWISE    ,UNWISE    ,UNRESERVED,
+    /*  `         a          b          c          d          e          f          g      */
+    UNWISE    ,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  h         i          j          k          l          m          n          o      */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  p         q          r          s          t          u          v          w      */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,UNRESERVED,
+    /*  x         y          z         {           |          }          ~         DEL     */
+    UNRESERVED,UNRESERVED,UNRESERVED,UNWISE    ,UNWISE    ,UNWISE    ,UNRESERVED,CONTROL
+};
+
+
+/*  Below modified from libwww HTEscape.c */
+
+#define HEX_ESCAPE '%'
+
+/*  Escape undesirable characters using %
+ *  -------------------------------------
+ *
+ * This function takes a pointer to a string in which
+ * some characters may be unacceptable unescaped.
+ * It returns a string which has these characters
+ * represented by a '%' character followed by two hex digits.
+ *
+ * This routine returns a g_malloced string.
+ */
+
+static const gchar hex[16] = "0123456789ABCDEF";
+
+static gchar *
+gnome_vfs_escape_string_internal (const gchar *string, 
+				  UnsafeCharacterSet mask)
+{
+#define ACCEPTABLE_CHAR(a) ((a)>=32 && (a)<128 && (acceptable[(a)-32] & use_mask))
+
+	const gchar *p;
+	gchar *q;
+	gchar *result;
+	guchar c;
+	gint unacceptable;
+	UnsafeCharacterSet use_mask;
+
+	g_return_val_if_fail (mask == UNSAFE_ALL
+			      || mask == UNSAFE_ALLOW_PLUS
+			      || mask == UNSAFE_PATH
+			      || mask == UNSAFE_DOS_PATH
+			      || mask == UNSAFE_HOST
+			      || mask == UNSAFE_SLASHES, NULL);
+
+	if (string == NULL) {
+		return NULL;
+	}
+	
+	unacceptable = 0;
+	use_mask = mask;
+	for (p = string; *p != '\0'; p++) {
+		c = *p;
+		if (!ACCEPTABLE_CHAR (c)) {
+			unacceptable++;
+		}
+		if ((use_mask == UNSAFE_HOST) && 
+		    (unacceptable || (c == '/'))) {
+			/* when escaping a host, if we hit something that needs to be escaped, or we finally
+			 * hit a path separator, revert to path mode (the host segment of the url is over).
+			 */
+			use_mask = UNSAFE_PATH;
+		}
+	}
+	
+	result = g_malloc (p - string + unacceptable * 2 + 1);
+
+	use_mask = mask;
+	for (q = result, p = string; *p != '\0'; p++){
+		c = *p;
+		
+		if (!ACCEPTABLE_CHAR (c)) {
+			*q++ = HEX_ESCAPE; /* means hex coming */
+			*q++ = hex[c >> 4];
+			*q++ = hex[c & 15];
+		} else {
+			*q++ = c;
+		}
+		if ((use_mask == UNSAFE_HOST) &&
+		    (!ACCEPTABLE_CHAR (c) || (c == '/'))) {
+			use_mask = UNSAFE_PATH;
+		}
+	}
+	
+	*q = '\0';
+	
+	return result;
+}
+
+/**
+ * gnome_vfs_escape_string:
+ * @string: string to be escaped
+ *
+ * Escapes @string, replacing any and all special characters 
+ * with equivalent escape sequences.
+ *
+ * Return value: a newly allocated string equivalent to @string
+ * but with all special characters escaped
+ **/
+gchar *
+gnome_vfs_escape_string (const gchar *string)
+{
+	return gnome_vfs_escape_string_internal (string, UNSAFE_ALL);
+}
+
+/**
+ * gnome_vfs_escape_path_string:
+ * @path: string to be escaped
+ *
+ * Escapes @path, replacing only special characters that would not
+ * be found in paths (so '/', '&', '=', and '?' will not be escaped by
+ * this function).
+ *
+ * Return value: a newly allocated string equivalent to @path but
+ * with non-path characters escaped
+ **/
+gchar *
+gnome_vfs_escape_path_string (const gchar *path)
+{
+	return gnome_vfs_escape_string_internal (path, UNSAFE_PATH);
+}
+
+/**
+ * gnome_vfs_escape_host_and_path_string:
+ * @path: string to be escaped
+ *
+ * Escapes @path, replacing only special characters that would not
+ * be found in paths or host name (so '/', '&', '=', ':', '@' 
+ * and '?' will not be escaped by this function).
+ *
+ * Return value: a newly allocated string equivalent to @path but
+ * with non-path/host characters escaped
+ **/
+gchar *
+gnome_vfs_escape_host_and_path_string (const gchar *path)
+{
+	return gnome_vfs_escape_string_internal (path, UNSAFE_HOST);
+}
+
+/**
+ * gnome_vfs_escape_slashes:
+ * @string: string to be escaped
+ *
+ * Escapes only '/' and '%' characters in @string, replacing
+ * them with their escape sequence equivalents.
+ *
+ * Return value: a newly allocated string equivalent to @string,
+ * but with no unescaped '/' or '%' characters
+ **/
+gchar *
+gnome_vfs_escape_slashes (const gchar *string)
+{
+	return gnome_vfs_escape_string_internal (string, UNSAFE_SLASHES);
+}
+
+char *
+gnome_vfs_escape_set (const char *string,
+	              const char *match_set)
+{
+	char *result;
+	const char *scanner;
+	char *result_scanner;
+	int escape_count;
+
+	escape_count = 0;
+
+	if (string == NULL) {
+		return NULL;
+	}
+
+	if (match_set == NULL) {
+		return g_strdup (string);
+	}
+	
+	for (scanner = string; *scanner != '\0'; scanner++) {
+		if (strchr(match_set, *scanner) != NULL) {
+			/* this character is in the set of characters 
+			 * we want escaped.
+			 */
+			escape_count++;
+		}
+	}
+	
+	if (escape_count == 0) {
+		return g_strdup (string);
+	}
+
+	/* allocate two extra characters for every character that
+	 * needs escaping and space for a trailing zero
+	 */
+	result = g_malloc (scanner - string + escape_count * 2 + 1);
+	for (scanner = string, result_scanner = result; *scanner != '\0'; scanner++) {
+		if (strchr(match_set, *scanner) != NULL) {
+			/* this character is in the set of characters 
+			 * we want escaped.
+			 */
+			*result_scanner++ = HEX_ESCAPE;
+			*result_scanner++ = hex[*scanner >> 4];
+			*result_scanner++ = hex[*scanner & 15];
+			
+		} else {
+			*result_scanner++ = *scanner;
+		}
+	}
+
+	*result_scanner = '\0';
+
+	return result;
+}
+
+/**
+ * gnome_vfs_expand_initial_tilde:
+ * @path: a local file path which may start with a '~'
+ *
+ * If @path starts with a ~, representing the user's home
+ * directory, expand it to the actual path location.
+ *
+ * Return value: a newly allocated string with the initial
+ * tilde (if there was one) converted to an actual path
+ **/
+char *
+gnome_vfs_expand_initial_tilde (const char *path)
+{
+	char *slash_after_user_name, *user_name;
+	struct passwd *passwd_file_entry;
+
+	g_return_val_if_fail (path != NULL, NULL);
+
+	if (path[0] != '~') {
+		return g_strdup (path);
+	}
+	
+	if (path[1] == '/' || path[1] == '\0') {
+		return g_strconcat (g_get_home_dir (), &path[1], NULL);
+	}
+
+	slash_after_user_name = strchr (&path[1], '/');
+	if (slash_after_user_name == NULL) {
+		user_name = g_strdup (&path[1]);
+	} else {
+		user_name = g_strndup (&path[1],
+				       slash_after_user_name - &path[1]);
+	}
+	passwd_file_entry = getpwnam (user_name);
+	g_free (user_name);
+
+	if (passwd_file_entry == NULL || passwd_file_entry->pw_dir == NULL) {
+		return g_strdup (path);
+	}
+
+	return g_strconcat (passwd_file_entry->pw_dir,
+			    slash_after_user_name,
+			    NULL);
+}
+
+static int
+hex_to_int (gchar c)
+{
+	return  c >= '0' && c <= '9' ? c - '0'
+		: c >= 'A' && c <= 'F' ? c - 'A' + 10
+		: c >= 'a' && c <= 'f' ? c - 'a' + 10
+		: -1;
+}
+
+static int
+unescape_character (const char *scanner)
+{
+	int first_digit;
+	int second_digit;
+
+	first_digit = hex_to_int (*scanner++);
+	if (first_digit < 0) {
+		return -1;
+	}
+
+	second_digit = hex_to_int (*scanner++);
+	if (second_digit < 0) {
+		return -1;
+	}
+
+	return (first_digit << 4) | second_digit;
+}
+
+/**
+ * gnome_vfs_unescape_string:
+ * @escaped_string: an escaped URI, path, or other string
+ * @illegal_characters: a string containing a sequence of characters
+ * considered "illegal", '\0' is automatically in this list.
+ *
+ * Decodes escaped characters (i.e. PERCENTxx sequences) in @escaped_string.
+ * Characters are encoded in PERCENTxy form, where xy is the ASCII hex code 
+ * for character 16x+y.
+ * 
+ * Return value: a newly allocated string with the unescaped equivalents, 
+ * or %NULL if @escaped_string contained one of the characters 
+ * in @illegal_characters.
+ **/
+char *
+gnome_vfs_unescape_string (const gchar *escaped_string, 
+			   const gchar *illegal_characters)
+{
+	const gchar *in;
+	gchar *out, *result;
+	gint character;
+	
+	if (escaped_string == NULL) {
+		return NULL;
+	}
+
+	result = g_malloc (strlen (escaped_string) + 1);
+	
+	out = result;
+	for (in = escaped_string; *in != '\0'; in++) {
+		character = *in;
+		if (*in == HEX_ESCAPE) {
+			character = unescape_character (in + 1);
+
+			/* Check for an illegal character. We consider '\0' illegal here. */
+			if (character <= 0
+			    || (illegal_characters != NULL
+				&& strchr (illegal_characters, (char)character) != NULL)) {
+				g_free (result);
+				return NULL;
+			}
+			in += 2;
+		}
+		*out++ = (char)character;
+	}
+	
+	*out = '\0';
+	g_assert (out - result <= strlen (escaped_string));
+	return result;
+	
+}
+
+/**
+ * gnome_vfs_unescape_for_display:
+ * @escaped: The string encoded with escaped sequences
+ * 
+ * Similar to gnome_vfs_unescape_string, but it returns something
+ * semi-intelligable to a user even upon receiving traumatic input
+ * such as %00 or URIs in bad form.
+ * 
+ * See also: gnome_vfs_unescape_string.
+ * 
+ * Return value: A pointer to a g_malloc'd string with all characters
+ *               replacing their escaped hex values
+ *
+ * WARNING: You should never use this function on a whole URI!  It
+ * unescapes reserved characters, and can result in a mangled URI
+ * that can not be re-entered.  For example, it unescapes "#" "&" and "?",
+ * which have special meanings in URI strings.
+ **/
+gchar *
+gnome_vfs_unescape_string_for_display (const gchar *escaped)
+{
+	const gchar *in, *start_escape;
+	gchar *out, *result;
+	gint i,j;
+	gchar c;
+	gint invalid_escape;
+
+	if (escaped == NULL) {
+		return NULL;
+	}
+
+	result = g_malloc (strlen (escaped) + 1);
+	
+	out = result;
+	for (in = escaped; *in != '\0'; ) {
+		start_escape = in;
+		c = *in++;
+		invalid_escape = 0;
+		
+		if (c == HEX_ESCAPE) {
+			/* Get the first hex digit. */
+			i = hex_to_int (*in++);
+			if (i < 0) {
+				invalid_escape = 1;
+				in--;
+			}
+			c = i << 4;
+			
+			if (invalid_escape == 0) {
+				/* Get the second hex digit. */
+				i = hex_to_int (*in++);
+				if (i < 0) {
+					invalid_escape = 2;
+					in--;
+				}
+				c |= i;
+			}
+			if (invalid_escape == 0) {
+				/* Check for an illegal character. */
+				if (c == '\0') {
+					invalid_escape = 3;
+				}
+			}
+		}
+		if (invalid_escape != 0) {
+			for (j = 0; j < invalid_escape; j++) {
+				*out++ = *start_escape++;
+			}
+		} else {
+			*out++ = c;
+		}
+	}
+	
+	*out = '\0';
+	g_assert (out - result <= strlen (escaped));
+	return result;
+}
+
+/**
+ * gnome_vfs_remove_optional_escapes:
+ * @uri: an escaped uri
+ * 
+ * Scans the uri and converts characters that do not have to be 
+ * escaped into an un-escaped form. The characters that get treated this
+ * way are defined as unreserved by the RFC.
+ * 
+ * Return value: an error value if the uri is found to be malformed.
+ **/
+GnomeVFSResult
+gnome_vfs_remove_optional_escapes (char *uri)
+{
+	guchar *scanner;
+	int character;
+	int length;
+
+	if (uri == NULL) {
+		return GNOME_VFS_OK;
+	}
+	
+	length = strlen (uri);
+
+	for (scanner = uri; *scanner != '\0'; scanner++, length--) {
+		if (*scanner == HEX_ESCAPE) {
+			character = unescape_character (scanner + 1);
+			if (character < 0) {
+				/* invalid hexadecimal character */
+				return GNOME_VFS_ERROR_INVALID_URI;
+			}
+
+			if (uri_character_kind [character] == UNRESERVED) {
+				/* This character does not need to be escaped, convert it
+				 * to a non-escaped form.
+				 */
+				*scanner = (guchar)character;
+				g_assert (length >= 3);
+
+				/* Shrink the string covering up the two extra digits of the
+				 * escaped character. Include the trailing '\0' in the copy
+				 * to keep the string terminated.
+				 */
+				memmove (scanner + 1, scanner + 3, length - 2);
+			} else {
+				/* This character must stay escaped, skip the entire
+				 * escaped sequence
+				 */
+				scanner += 2;
+			}
+			length -= 2;
+
+		} else if (*scanner > 127
+			|| uri_character_kind [*scanner] == DELIMITERS
+			|| uri_character_kind [*scanner] == UNWISE
+			|| uri_character_kind [*scanner] == CONTROL) {
+			/* It is illegal for this character to be in an un-escaped form
+			 * in the uri.
+			 */
+			return GNOME_VFS_ERROR_INVALID_URI;
+		}
+	}
+	return GNOME_VFS_OK;
+}
+
+static char *
+gnome_vfs_make_uri_canonical_old (const char *original_uri_text)
+{
+	GnomeVFSURI *uri;
+	char *result;
+
+	uri = gnome_vfs_uri_new_private (original_uri_text, TRUE, TRUE, FALSE);
+	if (uri == NULL) {
+		return NULL;
+	} 
+
+	result = gnome_vfs_uri_to_string (uri, GNOME_VFS_URI_HIDE_NONE);
+	gnome_vfs_uri_unref (uri);
+
+	return result;
+}
+
+/**
+ * gnome_vfs_make_path_name_canonical:
+ * @path: a file path, relative or absolute
+ * 
+ * Calls _gnome_vfs_canonicalize_pathname, allocating storage for the 
+ * result and providing for a cleaner memory management.
+ * 
+ * Return value: a canonical version of @path
+ **/
+gchar *
+gnome_vfs_make_path_name_canonical (const gchar *path)
+{
+	char *path_clone;
+	char *result;
+
+	path_clone = g_strdup (path);
+	result = _gnome_vfs_canonicalize_pathname (path_clone);
+	if (result != path_clone) {
+		g_free (path_clone);
+		return g_strdup (result);
+	}
+
+	return path_clone;
+}
+
+/**
+ * gnome_vfs_list_deep_free:
+ * @list: list to be freed
+ *
+ * Free @list, and call g_free() on all data members.
+ **/
+void
+gnome_vfs_list_deep_free (GList *list)
+{
+	GList *p;
+
+	if (list == NULL)
+		return;
+
+	for (p = list; p != NULL; p = p->next) {
+		g_free (p->data);
+	}
+	g_list_free (list);
+}
+
+/**
+ * gnome_vfs_get_local_path_from_uri:
+ * @uri: URI to convert to a local path
+ * 
+ * Create a local path for a file:/// URI. Do not use with URIs
+ * of other methods.
+ *
+ * Return value: a newly allocated string containing the local path 
+ * NULL is returned on error or if the uri isn't a file: URI
+ * without a fragment identifier (or chained URI).
+ **/
+char *
+gnome_vfs_get_local_path_from_uri (const char *uri)
+{
+	const char *path_part;
+
+	if (!_gnome_vfs_istr_has_prefix (uri, "file:/")) {
+		return NULL;
+	}
+	
+	path_part = uri + strlen ("file:");
+	if (strchr (path_part, '#') != NULL) {
+		return NULL;
+	}
+	
+	if (_gnome_vfs_istr_has_prefix (path_part, "///")) {
+		path_part += 2;
+	} else if (_gnome_vfs_istr_has_prefix (path_part, "//")) {
+		return NULL;
+	}
+
+	return gnome_vfs_unescape_string (path_part, "/");
+}
+
+/**
+ * gnome_vfs_get_uri_from_local_path:
+ * @local_full_path: a full local filesystem path (i.e. not relative)
+ * 
+ * Returns a file:/// URI for the local path @local_full_path.
+ *
+ * Return value: a newly allocated string containing the URI corresponding 
+ * to @local_full_path (NULL for some bad errors).
+ **/
+char *
+gnome_vfs_get_uri_from_local_path (const char *local_full_path)
+{
+	char *escaped_path, *result;
+	
+	if (local_full_path == NULL) {
+		return NULL;
+	}
+
+	g_return_val_if_fail (local_full_path[0] == '/', NULL);
+
+	escaped_path = gnome_vfs_escape_path_string (local_full_path);
+	result = g_strconcat ("file://", escaped_path, NULL);
+	g_free (escaped_path);
+	return result;
+}
+
+/**
+ * gnome_vfs_get_volume_free_space:
+ * @vfs_uri:
+ * @size:
+ * 
+ * Stores in @size the amount of free space on a volume.
+ * This only works for URIs with the file: scheme.
+ *
+ * Returns: GNOME_VFS_OK on success, otherwise an error code
+ */
+GnomeVFSResult
+gnome_vfs_get_volume_free_space (const GnomeVFSURI *vfs_uri, 
+				 GnomeVFSFileSize  *size)
+{	
+	GnomeVFSFileSize free_blocks, block_size;
+       	int statfs_result;
+	const char *path, *scheme;
+	char *unescaped_path;
+
+#if HAVE_STATVFS
+	struct statvfs statfs_buffer;
+#else
+	struct statfs statfs_buffer;
+#endif
+
+ 	*size = 0;
+
+	path = gnome_vfs_uri_get_path (vfs_uri);
+	if (path == NULL) {
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	scheme = gnome_vfs_uri_get_scheme (vfs_uri);
+	
+        /* We only handle the file scheme for now */
+	if (g_ascii_strcasecmp (scheme, "file") != 0 || !_gnome_vfs_istr_has_prefix (path, "/")) {
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	unescaped_path = gnome_vfs_unescape_string (path, G_DIR_SEPARATOR_S);
+	
+#if HAVE_STATVFS
+	statfs_result = statvfs (unescaped_path, &statfs_buffer);
+	block_size = statfs_buffer.f_frsize; 
+#else
+#if STATFS_ARGS == 2
+	statfs_result = statfs (unescaped_path, &statfs_buffer);
+#elif STATFS_ARGS == 4
+	statfs_result = statfs (unescaped_path, &statfs_buffer,
+				sizeof (statfs_buffer), 0);
+#endif
+	block_size = statfs_buffer.f_bsize; 
+#endif  
+
+	if (statfs_result != 0) {
+		g_free (unescaped_path);
+		return gnome_vfs_result_from_errno ();
+	}
+
+
+/* CF: I assume ncpfs is linux specific, if you are on a non-linux platform
+ * where ncpfs is available, please file a bug about it on bugzilla.gnome.org
+ * (2004-03-08)
+ */
+#if defined(__linux__)
+	/* ncpfs does not know the amount of available and free space */
+	if (statfs_buffer.f_bavail == 0 && statfs_buffer.f_bfree == 0) {
+		/* statvfs does not contain an f_type field, we try again
+		 * with statfs.
+		 */
+		struct statfs statfs_buffer2;
+		statfs_result = statfs (unescaped_path, &statfs_buffer2);
+		g_free (unescaped_path);
+
+		if (statfs_result != 0) {
+			return gnome_vfs_result_from_errno ();
+		}
+		
+		/* linux/ncp_fs.h: NCP_SUPER_MAGIC == 0x564c */
+		if (statfs_buffer2.f_type == 0x564c)
+		{
+			return GNOME_VFS_ERROR_NOT_SUPPORTED;
+		}
+	} else {
+		/* everything is copacetic... free the unescaped path */
+		g_free (unescaped_path);
+	}
+#else 	
+	g_free (unescaped_path);
+#endif
+	free_blocks = statfs_buffer.f_bavail;
+
+	*size = block_size * free_blocks;
+	
+	return GNOME_VFS_OK;
+}
+
+char *
+gnome_vfs_icon_path_from_filename (const char *relative_filename)
+{
+	const char *gnome_var;
+	char *full_filename;
+	char **paths, **temp_paths;
+
+	if (g_path_is_absolute (relative_filename) &&
+	    g_file_test (relative_filename, G_FILE_TEST_EXISTS))
+		return g_strdup (relative_filename);
+
+	gnome_var = g_getenv ("GNOME_PATH");
+
+	if (gnome_var == NULL) {
+		gnome_var = PREFIX;
+	}
+
+	paths = g_strsplit (gnome_var, ":", 0); 
+
+	for (temp_paths = paths; *temp_paths != NULL; temp_paths++) {
+		full_filename = g_strconcat (*temp_paths, "/share/pixmaps/", relative_filename, NULL);
+		if (g_file_test (full_filename, G_FILE_TEST_EXISTS)) {
+			g_strfreev (paths);
+			return full_filename;
+		}
+		g_free (full_filename);
+		full_filename = NULL;
+	}
+
+	g_strfreev (paths);
+	return NULL;
+}
+
+static char *
+strdup_to (const char *string, const char *end)
+{
+	if (end == NULL) {
+		return g_strdup (string);
+	}
+	return g_strndup (string, end - string);
+}
+
+static gboolean
+is_executable_file (const char *path)
+{
+	struct stat stat_buffer;
+
+	/* Check that it exists. */
+	if (stat (path, &stat_buffer) != 0) {
+		return FALSE;
+	}
+
+	/* Check that it is a file. */
+	if (!S_ISREG (stat_buffer.st_mode)) {
+		return FALSE;
+	}
+
+	/* Check that it's executable. */
+	if (access (path, X_OK) != 0) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+executable_in_path (const char *executable_name)
+{
+	const char *path_list, *piece_start, *piece_end;
+	char *piece, *raw_path, *expanded_path;
+	gboolean is_good;
+
+	path_list = g_getenv ("PATH");
+
+	for (piece_start = path_list; ; piece_start = piece_end + 1) {
+		/* Find the next piece of PATH. */
+		piece_end = strchr (piece_start, ':');
+		piece = strdup_to (piece_start, piece_end);
+		g_strstrip (piece);
+		
+		if (piece[0] == '\0') {
+			is_good = FALSE;
+		} else {
+			/* Try out this path with the executable. */
+			raw_path = g_strconcat (piece, "/", executable_name, NULL);
+			expanded_path = gnome_vfs_expand_initial_tilde (raw_path);
+			g_free (raw_path);
+			
+			is_good = is_executable_file (expanded_path);
+			g_free (expanded_path);
+		}
+		
+		g_free (piece);
+		
+		if (is_good) {
+			return TRUE;
+		}
+
+		if (piece_end == NULL) {
+			return FALSE;
+		}
+	}
+}
+
+static char *
+get_executable_name_from_command_string (const char *command_string)
+{
+	/* FIXME bugzilla.eazel.com 2757: 
+	 * We need to handle quoting here for the full-path case */
+	return g_strstrip (strdup_to (command_string, strchr (command_string, ' ')));
+}
+
+/**
+ * gnome_vfs_is_executable_command_string:
+ * @command_string:
+ * 
+ * Checks if @command_string starts with the full path of an executable file
+ * or an executable in $PATH.
+ *
+ * Returns: TRUE if command_string started with and executable file, 
+ * FALSE otherwise.
+ */
+gboolean
+gnome_vfs_is_executable_command_string (const char *command_string)
+{
+	char *executable_name;
+	char *executable_path;
+	gboolean found;
+
+	/* Check whether command_string is a full path for an executable. */
+	if (command_string[0] == '/') {
+
+		/* FIXME bugzilla.eazel.com 2757:
+		 * Because we don't handle quoting, we can check for full
+		 * path including spaces, but no parameters, and full path
+		 * with no spaces with or without parameters. But this will
+		 * fail for quoted full path with spaces, and parameters.
+		 */
+
+		/* This works if command_string contains a space, but not
+		 * if command_string has parameters.
+		 */
+		if (is_executable_file (command_string)) {
+			return TRUE;
+		}
+
+		/* This works if full path has no spaces, with or without parameters */
+		executable_path = get_executable_name_from_command_string (command_string);
+		found = is_executable_file (executable_path);
+		g_free (executable_path);
+
+		return found;
+	}
+	
+	executable_name = get_executable_name_from_command_string (command_string);
+	found = executable_in_path (executable_name);
+	g_free (executable_name);
+
+	return found;
+}
+
+/**
+ * gnome_vfs_read_entire_file:
+ * @uri: URI of the file to read
+ * @file_size: after reading the file, contains the size of the file read
+ * @file_contents: contains the file_size bytes, the contents of the file at @uri.
+ * 
+ * Reads an entire file into memory for convenience. Beware accidentally
+ * loading large files into memory with this function.
+ *
+ * Return value: An integer representing the result of the operation
+ *
+ * Since: 2.2
+ */
+
+GnomeVFSResult
+gnome_vfs_read_entire_file (const char *uri,
+			    int *file_size,
+			    char **file_contents)
+{
+	GnomeVFSResult result;
+	GnomeVFSHandle *handle;
+	char *buffer;
+	GnomeVFSFileSize total_bytes_read;
+	GnomeVFSFileSize bytes_read;
+
+	g_assert (file_size != NULL);
+	g_assert (file_contents != NULL);
+
+	*file_size = 0;
+	*file_contents = NULL;
+
+	/* Open the file. */
+	result = gnome_vfs_open (&handle, uri, GNOME_VFS_OPEN_READ);
+	if (result != GNOME_VFS_OK) {
+		return result;
+	}
+
+	/* Read the whole thing. */
+	buffer = NULL;
+	total_bytes_read = 0;
+	do {
+		buffer = g_realloc (buffer, total_bytes_read + READ_CHUNK_SIZE);
+		result = gnome_vfs_read (handle,
+					 buffer + total_bytes_read,
+					 READ_CHUNK_SIZE,
+					 &bytes_read);
+		if (result != GNOME_VFS_OK && result != GNOME_VFS_ERROR_EOF) {
+			g_free (buffer);
+			gnome_vfs_close (handle);
+			return result;
+		}
+
+		/* Check for overflow. */
+		if (total_bytes_read + bytes_read < total_bytes_read) {
+			g_free (buffer);
+			gnome_vfs_close (handle);
+			return GNOME_VFS_ERROR_TOO_BIG;
+		}
+
+		total_bytes_read += bytes_read;
+	} while (result == GNOME_VFS_OK);
+
+	/* Close the file. */
+	result = gnome_vfs_close (handle);
+	if (result != GNOME_VFS_OK) {
+		g_free (buffer);
+		return result;
+	}
+
+	/* Return the file. */
+	*file_size = total_bytes_read;
+	*file_contents = g_realloc (buffer, total_bytes_read);
+	return GNOME_VFS_OK;
+}
+
+static char *
+gnome_vfs_make_valid_utf8 (const char *name)
+{
+	GString *string;
+	const char *remainder, *invalid;
+	int remaining_bytes, valid_bytes;
+
+	string = NULL;
+	remainder = name;
+	remaining_bytes = strlen (name);
+
+	while (remaining_bytes != 0) {
+		if (g_utf8_validate (remainder, remaining_bytes, &invalid)) {
+			break;
+		}
+		valid_bytes = invalid - remainder;
+
+		if (string == NULL) {
+			string = g_string_sized_new (remaining_bytes);
+		}
+		g_string_append_len (string, remainder, valid_bytes);
+		g_string_append_c (string, '?');
+
+		remaining_bytes -= valid_bytes + 1;
+		remainder = invalid + 1;
+	}
+
+	if (string == NULL) {
+		return g_strdup (name);
+	}
+
+	g_string_append (string, remainder);
+	g_string_append (string, _(" (invalid Unicode)"));
+	g_assert (g_utf8_validate (string->str, -1, NULL));
+
+	return g_string_free (string, FALSE);
+}
+
+static char *
+gnome_vfs_format_uri_for_display_internal (const char *uri, gboolean filenames_are_locale_encoded)
+{
+	char *canonical_uri, *path, *utf8_path;
+
+	g_return_val_if_fail (uri != NULL, g_strdup (""));
+
+	canonical_uri = gnome_vfs_make_uri_canonical_old (uri);
+
+	/* If there's no fragment and it's a local path. */
+	path = gnome_vfs_get_local_path_from_uri (canonical_uri);
+	
+	if (path != NULL) {
+		if (filenames_are_locale_encoded) {
+			utf8_path = g_locale_to_utf8 (path, -1, NULL, NULL, NULL);
+			if (utf8_path) {
+				g_free (canonical_uri);
+				g_free (path);
+				return utf8_path;
+			} 
+		} else if (g_utf8_validate (path, -1, NULL)) {
+			g_free (canonical_uri);
+			return path;
+		}
+	}
+
+	if (canonical_uri && !g_utf8_validate (canonical_uri, -1, NULL)) {
+		utf8_path = gnome_vfs_make_valid_utf8 (canonical_uri);
+		g_free (canonical_uri);
+		canonical_uri = utf8_path;
+	}
+
+	g_free (path);
+	return canonical_uri;
+}
+
+
+/**
+ * gnome_vfs_format_uri_for_display:
+ *
+ * Filter, modify, unescape and change URIs to make them appropriate
+ * to display to users. The conversion is done such that the roundtrip
+ * to UTF-8 is reversible.
+ * 
+ * Rules:
+ * 	file: URI's without fragments should appear as local paths
+ * 	file: URI's with fragments should appear as file: URI's
+ * 	All other URI's appear as expected
+ *
+ * @uri: a URI
+ *
+ * Returns: a newly allocated UTF-8 string
+ *
+ * Since: 2.2
+ **/
+
+char *
+gnome_vfs_format_uri_for_display (const char *uri) 
+{
+	static gboolean broken_filenames;
+	
+	broken_filenames = (g_getenv ("G_BROKEN_FILENAMES") != NULL);
+
+	return gnome_vfs_format_uri_for_display_internal (uri, broken_filenames);
+}
+
+static gboolean
+is_valid_scheme_character (char c)
+{
+	return g_ascii_isalnum (c) || c == '+' || c == '-' || c == '.';
+}
+
+static gboolean
+has_valid_scheme (const char *uri)
+{
+	const char *p;
+
+	p = uri;
+
+	if (!is_valid_scheme_character (*p)) {
+		return FALSE;
+	}
+
+	do {
+		p++;
+	} while (is_valid_scheme_character (*p));
+
+	return *p == ':';
+}
+
+static char *
+gnome_vfs_escape_high_chars (const guchar *string)
+{
+	char *result;
+	const guchar *scanner;
+	guchar *result_scanner;
+	int escape_count;
+	static const gchar hex[16] = "0123456789ABCDEF";
+
+#define ACCEPTABLE(a) ((a)>=32 && (a)<128)
+	
+	escape_count = 0;
+
+	if (string == NULL) {
+		return NULL;
+	}
+
+	for (scanner = string; *scanner != '\0'; scanner++) {
+		if (!ACCEPTABLE(*scanner)) {
+			escape_count++;
+		}
+	}
+	
+	if (escape_count == 0) {
+		return g_strdup (string);
+	}
+
+	/* allocate two extra characters for every character that
+	 * needs escaping and space for a trailing zero
+	 */
+	result = g_malloc (scanner - string + escape_count * 2 + 1);
+	for (scanner = string, result_scanner = result; *scanner != '\0'; scanner++) {
+		if (!ACCEPTABLE(*scanner)) {
+			*result_scanner++ = '%';
+			*result_scanner++ = hex[*scanner >> 4];
+			*result_scanner++ = hex[*scanner & 15];
+			
+		} else {
+			*result_scanner++ = *scanner;
+		}
+	}
+
+	*result_scanner = '\0';
+
+	return result;
+}
+
+/* http uris look like <something>.<2-4 letters>, possibly followed by a slash and some text. */
+static gboolean
+looks_like_http_uri (const char *str)
+{
+	int len;
+	int i;
+	char c;
+	const char *first_slash;
+
+	first_slash = strchr(str, '/');
+	if (first_slash == NULL) {
+		len = strlen (str);
+	} else {
+		len = first_slash - str;
+	}
+	for (i = 0; i < 5 && i < len; i++) {
+		c = str[len - 1 - i];
+		if (i >= 2 && c == '.') {
+			return TRUE;
+		}
+		if (!g_ascii_isalpha (c)) {
+			return FALSE;
+		}
+	}
+	return FALSE;
+}
+
+/* The strip_trailing_whitespace option is intended to make copy/paste of
+ * URIs less error-prone when it is known that trailing whitespace isn't
+ * part of the uri.
+ */
+static char *
+gnome_vfs_make_uri_from_input_internal (const char *text,
+				  gboolean filenames_are_locale_encoded,
+				  gboolean strip_trailing_whitespace)
+{
+	char *stripped, *path, *uri, *locale_path, *filesystem_path, *escaped;
+
+	g_return_val_if_fail (text != NULL, g_strdup (""));
+
+	/* Strip off leading whitespaces (since they can't be part of a valid
+	   uri).   Only strip off trailing whitespaces when requested since
+	   they might be part of a valid uri.
+	 */
+	if (strip_trailing_whitespace) {
+		stripped = g_strstrip (g_strdup (text));
+	} else {
+		stripped = g_strchug (g_strdup (text));
+	}
+
+	switch (stripped[0]) {
+	case '\0':
+		uri = g_strdup ("");
+		break;
+	case '/':
+		if (filenames_are_locale_encoded) {
+			GError *error = NULL;
+			locale_path = g_locale_from_utf8 (stripped, -1, NULL, NULL, &error);
+			if (locale_path != NULL) {
+				uri = gnome_vfs_get_uri_from_local_path (locale_path);
+				g_free (locale_path);
+			} else {
+				/* We couldn't convert to the locale. */
+				/* FIXME: We should probably give a user-visible error here. */
+				uri = g_strdup("");
+			}
+		} else {
+			uri = gnome_vfs_get_uri_from_local_path (stripped);
+		}
+		break;
+	case '~':
+		if (filenames_are_locale_encoded) {
+			filesystem_path = g_locale_from_utf8 (stripped, -1, NULL, NULL, NULL);
+		} else {
+			filesystem_path = g_strdup (stripped);
+		}
+                /* deliberately falling into default case on fail */
+		if (filesystem_path != NULL) {
+			path = gnome_vfs_expand_initial_tilde (filesystem_path);
+			g_free (filesystem_path);
+			if (*path == '/') {
+				uri = gnome_vfs_get_uri_from_local_path (path);
+				g_free (path);
+				break;
+			}
+			g_free (path);
+		}
+                /* don't insert break here, read above comment */
+	default:
+		if (has_valid_scheme (stripped)) {
+			uri = gnome_vfs_escape_high_chars (stripped);
+		} else if (looks_like_http_uri (stripped)) {
+			escaped = gnome_vfs_escape_high_chars (stripped);
+			uri = g_strconcat ("http://", escaped, NULL);
+			g_free (escaped);
+		} else {
+			escaped = gnome_vfs_escape_high_chars (stripped);
+			uri = g_strconcat ("file://", escaped, NULL);
+			g_free (escaped);
+		}
+	}
+
+	g_free (stripped);
+
+	return uri;
+	
+}
+
+/**
+ * gnome_vfs_make_uri_from_input:
+ * @uri: a possibly mangled "uri", in UTF8
+ *
+ * Takes a user input path/URI and makes a valid URI out of it.
+ *
+ * This function is the reverse of gnome_vfs_format_uri_for_display
+ * but it also handles the fact that the user could have typed
+ * arbitrary UTF8 in the entry showing the string.
+ *
+ * Returns: a newly allocated uri.
+ *
+ * Since: 2.2
+ **/
+char *
+gnome_vfs_make_uri_from_input (const char *location)
+{
+	static gboolean broken_filenames;
+
+	broken_filenames = (g_getenv ("G_BROKEN_FILENAMES") != NULL);
+
+	return gnome_vfs_make_uri_from_input_internal (location, broken_filenames, TRUE);
+}
+
+/**
+ * gnome_vfs_make_uri_from_input_with_dirs:
+ * @uri: a relative or absolute path
+ * @dirs: directory to use as a base directory if @uri is a relative path.
+ *
+ * Determines a fully qualified URL from a relative or absolute input path.
+ * Basically calls gnome_vfs_make_uri_from_input except it specifically
+ * tries to support paths relative to the specified directories (can be homedir
+ * and/or current directory).
+ *
+ * Return value: a newly allocated string containing the fully qualified URL
+ *
+ * Since: 2.4
+ */
+char *
+gnome_vfs_make_uri_from_input_with_dirs (const char *in,
+					 GnomeVFSMakeURIDirs dirs)
+{
+	char *uri, *path, *dir;
+
+	switch (in[0]) {
+	case '\0':
+		uri = g_strdup ("");
+		break;
+		
+	case '~':
+	case '/':
+		uri = gnome_vfs_make_uri_from_input (in);
+		break;
+		
+	default:
+		/* this might be a relative path, check if it exists relative
+		 * to current dir and home dir.
+		 */
+		uri = NULL;
+		if (dirs & GNOME_VFS_MAKE_URI_DIR_CURRENT) {
+			dir = g_get_current_dir ();
+			path = g_build_filename (dir, in, NULL);
+			g_free (dir);
+			
+			if (g_file_test (path, G_FILE_TEST_EXISTS)) {
+				uri = gnome_vfs_make_uri_from_input (path);
+			}
+			g_free (path);
+		}
+
+		if (uri == NULL &&
+		    dirs & GNOME_VFS_MAKE_URI_DIR_HOMEDIR) {
+			path = g_build_filename (g_get_home_dir (), in, NULL);
+		
+			if (g_file_test (path, G_FILE_TEST_EXISTS)) {
+				uri = gnome_vfs_make_uri_from_input (path);
+			}
+			g_free (path);
+		}
+
+		if (uri == NULL) {
+			uri = gnome_vfs_make_uri_from_input (in);
+		}
+	}
+	
+	return uri;
+}
+
+
+/**
+ * gnome_vfs_make_uri_canonical_strip_fragment:
+ * @uri:
+ *
+ * If the @uri passed contains a fragment (anything after a '#') strips if,
+ * then makes the URI canonical.
+ *
+ * Returns: a newly allocated string containing a canonical URI.
+ *
+ * Since: 2.2
+ **/
+
+char *
+gnome_vfs_make_uri_canonical_strip_fragment (const char *uri)
+{
+	const char *fragment;
+	char *without_fragment, *canonical;
+
+	fragment = strchr (uri, '#');
+	if (fragment == NULL) {
+		return gnome_vfs_make_uri_canonical (uri);
+	}
+
+	without_fragment = g_strndup (uri, fragment - uri);
+	canonical = gnome_vfs_make_uri_canonical (without_fragment);
+	g_free (without_fragment);
+	return canonical;
+}
+
+static gboolean
+uris_match (const char *uri_1, const char *uri_2, gboolean ignore_fragments)
+{
+	char *canonical_1, *canonical_2;
+	gboolean result;
+
+	if (ignore_fragments) {
+		canonical_1 = gnome_vfs_make_uri_canonical_strip_fragment (uri_1);
+		canonical_2 = gnome_vfs_make_uri_canonical_strip_fragment (uri_2);
+	} else {
+		canonical_1 = gnome_vfs_make_uri_canonical (uri_1);
+		canonical_2 = gnome_vfs_make_uri_canonical (uri_2);
+	}
+
+	result = strcmp (canonical_1, canonical_2) ? FALSE : TRUE;
+
+	g_free (canonical_1);
+	g_free (canonical_2);
+	
+	return result;
+}
+
+/**
+ * gnome_vfs_uris_match:
+ * @uri_1: stringified URI to compare with @uri_2.
+ * @uri_2: stringified URI to compare with @uri_1.
+ * 
+ * Compare two URIs.
+ *
+ * Return value: TRUE if they are the same, FALSE otherwise.
+ *
+ * Since: 2.2
+ **/
+
+gboolean
+gnome_vfs_uris_match (const char *uri_1, const char *uri_2)
+{
+	return uris_match (uri_1, uri_2, FALSE);
+}
+
+static gboolean
+gnome_vfs_str_has_prefix (const char *haystack, const char *needle)
+{
+        const char *h, *n;
+
+        /* Eat one character at a time. */
+        h = haystack == NULL ? "" : haystack;
+        n = needle == NULL ? "" : needle;
+        do {
+                if (*n == '\0') {
+                        return TRUE;
+                }
+                if (*h == '\0') {
+                        return FALSE;
+                }
+        } while (*h++ == *n++);
+        return FALSE;
+}
+
+
+static gboolean
+gnome_vfs_uri_is_local_scheme (const char *uri)
+{
+	gboolean is_local_scheme;
+	char *temp_scheme;
+	int i;
+	char *local_schemes[] = {"file:", "help:", "ghelp:", "gnome-help:",
+				 "trash:", "man:", "info:", 
+				 "hardware:", "search:", "pipe:",
+				 "gnome-trash:", NULL};
+
+	is_local_scheme = FALSE;
+	for (temp_scheme = *local_schemes, i = 0; temp_scheme != NULL; i++, temp_scheme = local_schemes[i]) {
+		is_local_scheme = _gnome_vfs_istr_has_prefix (uri, temp_scheme);
+		if (is_local_scheme) {
+			break;
+		}
+	}
+	
+
+	return is_local_scheme;
+}
+
+static char *
+gnome_vfs_handle_trailing_slashes (const char *uri)
+{
+	char *temp, *uri_copy;
+	gboolean previous_char_is_column, previous_chars_are_slashes_without_column;
+	gboolean previous_chars_are_slashes_with_column;
+	gboolean is_local_scheme;
+
+	g_assert (uri != NULL);
+
+	uri_copy = g_strdup (uri);
+	if (strlen (uri_copy) <= 2) {
+		return uri_copy;
+	}
+
+	is_local_scheme = gnome_vfs_uri_is_local_scheme (uri);
+
+	previous_char_is_column = FALSE;
+	previous_chars_are_slashes_without_column = FALSE;
+	previous_chars_are_slashes_with_column = FALSE;
+
+	/* remove multiple trailing slashes */
+	for (temp = uri_copy; *temp != '\0'; temp++) {
+		if (*temp == '/' && !previous_char_is_column) {
+			previous_chars_are_slashes_without_column = TRUE;
+		} else if (*temp == '/' && previous_char_is_column) {
+			previous_chars_are_slashes_without_column = FALSE;
+			previous_char_is_column = TRUE;
+			previous_chars_are_slashes_with_column = TRUE;
+		} else {
+			previous_chars_are_slashes_without_column = FALSE;
+			previous_char_is_column = FALSE;
+			previous_chars_are_slashes_with_column = FALSE;
+		}
+
+		if (*temp == ':') {
+			previous_char_is_column = TRUE;
+		}
+	}
+
+	if (*temp == '\0' && previous_chars_are_slashes_without_column) {
+		if (is_local_scheme) {
+			/* go back till you remove them all. */
+			for (temp--; *(temp) == '/'; temp--) {
+				*temp = '\0';
+			}
+		} else {
+			/* go back till you remove them all but one. */
+			for (temp--; *(temp - 1) == '/'; temp--) {
+				*temp = '\0';
+			}			
+		}
+	}
+
+	if (*temp == '\0' && previous_chars_are_slashes_with_column) {
+		/* go back till you remove them all but three. */
+		for (temp--; *(temp - 3) != ':' && *(temp - 2) != ':' && *(temp - 1) != ':'; temp--) {
+			*temp = '\0';
+		}
+	}
+
+
+	return uri_copy;
+}
+
+/**
+ * gnome_vfs_make_uri_canonical:
+ * @uri: and absolute or relative URI, it might have scheme.
+ *
+ * Standarizes the format of the uri being passed, so that it can be used
+ * later in other functions that expect a canonical URI.
+ *
+ * Returns: a newly allocated string that contains the canonical 
+ * representation of @uri.
+ *
+ * Since: 2.2
+ **/
+
+char *
+gnome_vfs_make_uri_canonical (const char *uri)
+{
+	char *canonical_uri, *old_uri, *p;
+	gboolean relative_uri;
+
+	relative_uri = FALSE;
+
+	if (uri == NULL) {
+		return NULL;
+	}
+
+	/* FIXME bugzilla.eazel.com 648: 
+	 * This currently ignores the issue of two uris that are not identical but point
+	 * to the same data except for the specific cases of trailing '/' characters,
+	 * file:/ and file:///, and "lack of file:".
+	 */
+
+	canonical_uri = gnome_vfs_handle_trailing_slashes (uri);
+
+	/* Note: In some cases, a trailing slash means nothing, and can
+	 * be considered equivalent to no trailing slash. But this is
+	 * not true in every case; specifically not for web addresses passed
+	 * to a web-browser. So we don't have the trailing-slash-equivalence
+	 * logic here, but we do use that logic in EelDirectory where
+	 * the rules are more strict.
+	 */
+
+	/* Add file: if there is no scheme. */
+	if (strchr (canonical_uri, ':') == NULL) {
+		old_uri = canonical_uri;
+
+		if (old_uri[0] != '/') {
+			/* FIXME bugzilla.eazel.com 5069: 
+			 *  bandaid alert. Is this really the right thing to do?
+			 * 
+			 * We got what really is a relative path. We do a little bit of
+			 * a stretch here and assume it was meant to be a cryptic absolute path,
+			 * and convert it to one. Since we can't call gnome_vfs_uri_new and
+			 * gnome_vfs_uri_to_string to do the right make-canonical conversion,
+			 * we have to do it ourselves.
+			 */
+			relative_uri = TRUE;
+			canonical_uri = gnome_vfs_make_path_name_canonical (old_uri);
+			g_free (old_uri);
+			old_uri = canonical_uri;
+			canonical_uri = g_strconcat ("file:///", old_uri, NULL);
+		} else {
+			canonical_uri = g_strconcat ("file:", old_uri, NULL);
+		}
+		g_free (old_uri);
+	}
+
+	/* Lower-case the scheme. */
+	for (p = canonical_uri; *p != ':'; p++) {
+		g_assert (*p != '\0');
+		*p = g_ascii_tolower (*p);
+	}
+
+	if (!relative_uri) {
+		old_uri = canonical_uri;
+		canonical_uri = gnome_vfs_make_uri_canonical_old (canonical_uri);
+		if (canonical_uri != NULL) {
+			g_free (old_uri);
+		} else {
+			canonical_uri = old_uri;
+		}
+	}
+	
+	/* FIXME bugzilla.eazel.com 2802:
+	 * Work around gnome-vfs's desire to convert file:foo into file://foo
+	 * by converting to file:///foo here. When you remove this, check that
+	 * typing "foo" into location bar does not crash and returns an error
+	 * rather than displaying the contents of /
+	 */
+	if (gnome_vfs_str_has_prefix (canonical_uri, "file://")
+	    && !gnome_vfs_str_has_prefix (canonical_uri, "file:///")) {
+		old_uri = canonical_uri;
+		canonical_uri = g_strconcat ("file:/", old_uri + 5, NULL);
+		g_free (old_uri);
+	}
+
+	return canonical_uri;
+}
+
+/**
+ * gnome_vfs_get_uri_scheme:
+ * @uri: a stringified URI
+ *
+ * Retrieve the scheme used in @uri 
+ *
+ * Return value: A newly allocated string containing the scheme, NULL
+ * if @uri it doesn't seem to contain a scheme
+ *
+ * Since: 2.2
+ **/
+
+char *
+gnome_vfs_get_uri_scheme (const char *uri)
+{
+	char *colon;
+
+	g_return_val_if_fail (uri != NULL, NULL);
+
+	colon = strchr (uri, ':');
+	
+	if (colon == NULL) {
+		return NULL;
+	}
+
+	return g_ascii_strdown (uri, colon - uri);
+}
+
+/* Note that NULL's and full paths are also handled by this function.
+ * A NULL location will return the current working directory
+ */
+static char *
+file_uri_from_local_relative_path (const char *location)
+{
+	char *current_dir;
+	char *base_uri, *base_uri_slash;
+	char *location_escaped;
+	char *uri;
+
+	current_dir = g_get_current_dir ();
+	base_uri = gnome_vfs_get_uri_from_local_path (current_dir);
+	/* g_get_current_dir returns w/o trailing / */
+	base_uri_slash = g_strconcat (base_uri, "/", NULL);
+
+	location_escaped = gnome_vfs_escape_path_string (location);
+
+	uri = gnome_vfs_uri_make_full_from_relative (base_uri_slash, location_escaped);
+
+	g_free (location_escaped);
+	g_free (base_uri_slash);
+	g_free (base_uri);
+	g_free (current_dir);
+
+	return uri;
+}
+
+/**
+ * gnome_vfs_make_uri_from_shell_arg:
+ * @uri: a possibly mangled "uri"
+ *
+ * Similar to gnome_vfs_make_uri_from_input, except that:
+ * 
+ * 1) guesses relative paths instead of http domains
+ * 2) doesn't bother stripping leading/trailing white space
+ * 3) doesn't bother with ~ expansion--that's done by the shell
+ *
+ * Returns: a newly allocated uri
+ *
+ * Since: 2.2
+ **/
+
+char *
+gnome_vfs_make_uri_from_shell_arg (const char *location)
+{
+	char *uri;
+
+	g_return_val_if_fail (location != NULL, g_strdup (""));
+
+	switch (location[0]) {
+	case '\0':
+		uri = g_strdup ("");
+		break;
+	case '/':
+		uri = gnome_vfs_get_uri_from_local_path (location);
+		break;
+	default:
+		if (has_valid_scheme (location)) {
+			uri = g_strdup (location);
+		} else {
+			uri = file_uri_from_local_relative_path (location);
+		}
+	}
+
+	return uri;
+}
+
+/**
+ * gnome_vfs_make_uri_full_from_relative:
+ * @base_uri: uri to use as the base for the full uri
+ * @relative_uri: full or relative path to append to the base uri
+ *
+ * Returns a full URI given a full base URI, and a secondary URI which may
+ * be relative.
+ *
+ * This function is deprecated, please use 
+ * gnome_vfs_uri_make_full_from_relative from gnome-vfs-uri.h
+ *
+ * Return value: the URI (NULL for some bad errors).
+ *
+ * Since: 2.2
+ **/
+
+char *
+gnome_vfs_make_uri_full_from_relative (const char *base_uri, 
+				       const char *relative_uri)
+{
+	return gnome_vfs_uri_make_full_from_relative (base_uri, relative_uri);
+}
+
+GnomeVFSResult
+_gnome_vfs_uri_resolve_all_symlinks_uri (GnomeVFSURI *uri,
+					 GnomeVFSURI **result_uri)
+{
+	GnomeVFSURI *new_uri, *resolved_uri;
+	GnomeVFSFileInfo *info;
+	GnomeVFSResult res;
+	char *p;
+	int n_followed_symlinks;
+
+	/* Ref the original uri so we don't lose it */
+	uri = gnome_vfs_uri_ref (uri);
+
+	*result_uri = NULL;
+
+	info = gnome_vfs_file_info_new ();
+
+	p = uri->text;
+	n_followed_symlinks = 0;
+	while (*p != 0) {
+		while (*p == GNOME_VFS_URI_PATH_CHR)
+			p++;
+		while (*p != 0 && *p != GNOME_VFS_URI_PATH_CHR)
+			p++;
+
+		new_uri = gnome_vfs_uri_dup (uri);
+		g_free (new_uri->text);
+		new_uri->text = g_strndup (uri->text, p - uri->text);
+		
+		gnome_vfs_file_info_clear (info);
+		res = gnome_vfs_get_file_info_uri (new_uri, info, GNOME_VFS_FILE_INFO_DEFAULT);
+		if (res != GNOME_VFS_OK) {
+			gnome_vfs_uri_unref (new_uri);
+			goto out;
+		}
+		if (info->type == GNOME_VFS_FILE_TYPE_SYMBOLIC_LINK &&
+		    info->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME) {
+			n_followed_symlinks++;
+			if (n_followed_symlinks > MAX_SYMLINKS_FOLLOWED) {
+				res = GNOME_VFS_ERROR_TOO_MANY_LINKS;
+				gnome_vfs_uri_unref (new_uri);
+				goto out;
+			}
+			resolved_uri = gnome_vfs_uri_resolve_relative (new_uri,
+								       info->symlink_name);
+			if (*p != 0) {
+				gnome_vfs_uri_unref (uri);
+				uri = gnome_vfs_uri_append_path (resolved_uri, p);
+				gnome_vfs_uri_unref (resolved_uri);
+			} else {
+				gnome_vfs_uri_unref (uri);
+				uri = resolved_uri;
+			}
+
+			p = uri->text;
+		} 
+		gnome_vfs_uri_unref (new_uri);
+	}
+
+	res = GNOME_VFS_OK;
+	*result_uri = gnome_vfs_uri_dup (uri);
+ out:
+	gnome_vfs_file_info_unref (info);
+	gnome_vfs_uri_unref (uri);
+	return res;
+}
+
+GnomeVFSResult
+_gnome_vfs_uri_resolve_all_symlinks (const char *text_uri,
+				     char **resolved_text_uri)
+{
+	GnomeVFSURI *uri, *resolved_uri;
+	GnomeVFSResult res;
+
+	*resolved_text_uri = NULL;
+
+	uri = gnome_vfs_uri_new (text_uri);
+
+	if (uri == NULL) {
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+	if (uri->text == NULL) {
+		gnome_vfs_uri_unref (uri);
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	res = _gnome_vfs_uri_resolve_all_symlinks_uri (uri, &resolved_uri);
+
+	if (res == GNOME_VFS_OK) {
+		*resolved_text_uri = gnome_vfs_uri_to_string (resolved_uri, GNOME_VFS_URI_HIDE_NONE);
+		gnome_vfs_uri_unref (resolved_uri);
+	}
+	gnome_vfs_uri_unref (uri);
+	return res;
+}
+
+gboolean 
+_gnome_vfs_uri_is_in_subdir (GnomeVFSURI *uri, GnomeVFSURI *dir)
+{
+	GnomeVFSFileInfo *dirinfo, *info;
+	GnomeVFSURI *resolved_dir, *parent, *tmp;
+	GnomeVFSResult res;
+	gboolean is_in_dir;
+
+	resolved_dir = NULL;
+	parent = NULL;
+
+	is_in_dir = FALSE;
+	
+	dirinfo = gnome_vfs_file_info_new ();
+	info = gnome_vfs_file_info_new ();
+
+	res = gnome_vfs_get_file_info_uri (dir, dirinfo, GNOME_VFS_FILE_INFO_DEFAULT);
+	if (res != GNOME_VFS_OK || dirinfo->type != GNOME_VFS_FILE_TYPE_DIRECTORY) {
+		goto out;
+	}
+
+	res = _gnome_vfs_uri_resolve_all_symlinks_uri (dir, &resolved_dir);
+	if (res != GNOME_VFS_OK) {
+		goto out;
+	}
+	
+	res = _gnome_vfs_uri_resolve_all_symlinks_uri (uri, &tmp);
+	if (res != GNOME_VFS_OK) {
+		goto out;
+	}
+	
+	parent = gnome_vfs_uri_get_parent (tmp);
+	gnome_vfs_uri_unref (tmp);
+
+	while (parent != NULL) {
+		res = gnome_vfs_get_file_info_uri (parent, info, GNOME_VFS_FILE_INFO_DEFAULT);
+		if (res != GNOME_VFS_OK) {
+			break;
+		}
+
+		if (dirinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_DEVICE &&
+		    dirinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_INODE &&
+		    info->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_DEVICE &&
+		    info->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_INODE) {
+			if (dirinfo->device == info->device &&
+			    dirinfo->inode == info->inode) {
+				is_in_dir = TRUE;
+				break;
+			}
+		} else {
+			if (gnome_vfs_uri_equal (dir, parent)) {
+				is_in_dir = TRUE;
+				break;
+			}
+		}
+		
+		tmp = gnome_vfs_uri_get_parent (parent);
+		gnome_vfs_uri_unref (parent);
+		parent = tmp;
+	}
+
+ out:
+	if (resolved_dir != NULL) {
+		gnome_vfs_uri_unref (resolved_dir);
+	}
+	if (parent != NULL) {
+		gnome_vfs_uri_unref (parent);
+	}
+	gnome_vfs_file_info_unref (info);
+	gnome_vfs_file_info_unref (dirinfo);
+	return is_in_dir;
+}
+
+/**
+ * gnome_vfs_url_show:
+ * 
+ * Launches the default application or component associated with the given url.
+ *
+ * Return value: GNOME_VFS_OK if the default action was launched,
+ * GNOME_VFS_ERROR_BAD_PARAMETERS for an invalid or non-existant url,
+ * GNOME_VFS_ERROR_NOT_SUPPORTED if no default action is associated with the URL.
+ * Also error codes from gnome_vfs_mime_action_launch and
+ * gnome_vfs_url_show_using_handler for other errors.
+ *
+ * Since: 2.4
+ */
+GnomeVFSResult
+gnome_vfs_url_show (const char *url)
+{
+	return gnome_vfs_url_show_with_env (url, NULL);
+}
+
+/**
+ * gnome_vfs_url_show_with_env:
+ * 
+ * Like gnome_vfs_url_show except that the default action will be launched
+ * with the given environment.
+ *
+ * Return value: GNOME_VFS_OK if the default action was launched.
+ *
+ * Since: 2.4
+ */
+GnomeVFSResult
+gnome_vfs_url_show_with_env (const char  *url,
+                             char       **envp)
+{
+	GnomeVFSMimeApplication *app;
+	GnomeVFSMimeAction *action;
+	GnomeVFSResult result;
+	GList params;
+	char *type;
+	char *scheme;
+
+	g_return_val_if_fail (url != NULL, GNOME_VFS_ERROR_BAD_PARAMETERS);
+
+	scheme = gnome_vfs_get_uri_scheme (url);
+	if (scheme == NULL) {
+		return GNOME_VFS_ERROR_BAD_PARAMETERS;
+	}
+	
+	/* check if this scheme requires special handling */
+	if (_gnome_vfs_use_handler_for_scheme (scheme)) {
+		result = _gnome_vfs_url_show_using_handler_with_env (url, envp);
+		g_free (scheme);
+		return result;
+	}
+	
+	type = _gnome_vfs_get_slow_mime_type (url);
+
+	if (type == NULL) {
+		g_free (scheme);
+		return GNOME_VFS_ERROR_BAD_PARAMETERS;
+	}
+
+	params.data = (char *) url;
+	params.prev = NULL;
+	params.next = NULL;
+	
+	app = gnome_vfs_mime_get_default_application_for_scheme (type, scheme);
+	g_free (scheme);
+	
+	if (app != NULL) {
+		result = gnome_vfs_mime_application_launch_with_env (app, &params, envp);
+		gnome_vfs_mime_application_free (app);
+		g_free (type);
+		return result;
+	}
+	
+	action = gnome_vfs_mime_get_default_action (type);
+	
+	if (action != NULL) {
+		result = gnome_vfs_mime_action_launch_with_env (action, &params, envp);
+		gnome_vfs_mime_action_free (action);
+		g_free (type);
+		return result;
+	}
+	
+	g_free (type);
+	return GNOME_VFS_ERROR_NO_DEFAULT;	
+}	  
+
diff -Naur gnome-vfs-2.8.1-old/modules/bzip2-method.c gnome-vfs-2.8.1/modules/bzip2-method.c
--- gnome-vfs-2.8.1-old/modules/bzip2-method.c	Thu Jan 22 10:28:47 2004
+++ gnome-vfs-2.8.1/modules/bzip2-method.c	Wed Oct  6 10:52:25 2004
@@ -37,13 +37,6 @@
 
 #include <bzlib.h>
 
-#ifdef HAVE_OLDER_BZIP2
-#define BZ2_bzDecompressInit  bzDecompressInit
-#define BZ2_bzCompressInit    bzCompressInit
-#define BZ2_bzDecompress      bzDecompress
-#define BZ2_bzCompress        bzCompress
-#endif
-
 #define BZ_BUFSIZE   5000
 
 struct _Bzip2MethodHandle {
diff -Naur gnome-vfs-2.8.1-old/modules/file-method.c gnome-vfs-2.8.1/modules/file-method.c
--- gnome-vfs-2.8.1-old/modules/file-method.c	Mon Aug 30 06:11:02 2004
+++ gnome-vfs-2.8.1/modules/file-method.c	Wed Oct  6 10:52:35 2004
@@ -94,19 +94,10 @@
 }
 #endif
 
-#ifdef HAVE_OPEN64
-#define OPEN open64
-#else
 #define OPEN open
-#endif
-
-#if defined(HAVE_LSEEK64) && defined(HAVE_OFF64_T)
 #define LSEEK lseek64
-#define OFF_T off64_t
-#else
 #define LSEEK lseek
 #define OFF_T off_t
-#endif
 
 
 static gchar *
diff -Naur gnome-vfs-2.8.1-old/modules/file-method.c.orig gnome-vfs-2.8.1/modules/file-method.c.orig
--- gnome-vfs-2.8.1-old/modules/file-method.c.orig	Wed Dec 31 19:00:00 1969
+++ gnome-vfs-2.8.1/modules/file-method.c.orig	Mon Aug 30 06:11:02 2004
@@ -0,0 +1,2345 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* file-method.c - Local file access method for the GNOME Virtual File
+   System.
+
+   Copyright (C) 1999 Free Software Foundation
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Authors: 
+   	Ettore Perazzoli <ettore@comm2000.it>
+   	Pavel Cisler <pavel@eazel.com>
+ */
+
+#include <config.h>
+
+#include <libgnomevfs/gnome-vfs-cancellation.h>
+#include <libgnomevfs/gnome-vfs-context.h>
+#include <libgnomevfs/gnome-vfs-i18n.h>
+#include <libgnomevfs/gnome-vfs-method.h>
+#include <libgnomevfs/gnome-vfs-mime.h>
+#include <libgnomevfs/gnome-vfs-module-shared.h>
+#include <libgnomevfs/gnome-vfs-module.h>
+#include <libgnomevfs/gnome-vfs-utils.h>
+#include <libgnomevfs/gnome-vfs-mime.h>
+#include <libgnomevfs/gnome-vfs-monitor-private.h>
+#include <libgnomevfs/gnome-vfs-private-utils.h>
+#include <libgnomevfs/gnome-vfs-ops.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <glib/gstrfuncs.h>
+#include <glib/gutils.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <utime.h>
+#include <string.h>
+#ifdef HAVE_FAM
+#include <fam.h>
+#include <glib/giochannel.h>
+#endif
+
+#ifdef HAVE_FAM
+static FAMConnection *fam_connection = NULL;
+static gint fam_watch_id = 0;
+G_LOCK_DEFINE_STATIC (fam_connection);
+
+typedef struct {
+	FAMRequest request;
+	GnomeVFSURI *uri;
+	gboolean     cancelled;
+} FileMonitorHandle;
+
+#endif
+
+#ifdef PATH_MAX
+#define	GET_PATH_MAX()	PATH_MAX
+#else
+static int
+GET_PATH_MAX (void)
+{
+	static unsigned int value;
+
+	/* This code is copied from GNU make.  It returns the maximum
+	   path length by using `pathconf'.  */
+
+	if (value == 0) {
+		long int x = pathconf(G_DIR_SEPARATOR_S, _PC_PATH_MAX);
+
+		if (x > 0)
+			value = x;
+		else
+			return MAXPATHLEN;
+	}
+
+	return value;
+}
+#endif
+
+#ifdef HAVE_OPEN64
+#define OPEN open64
+#else
+#define OPEN open
+#endif
+
+#if defined(HAVE_LSEEK64) && defined(HAVE_OFF64_T)
+#define LSEEK lseek64
+#define OFF_T off64_t
+#else
+#define LSEEK lseek
+#define OFF_T off_t
+#endif
+
+
+static gchar *
+get_path_from_uri (GnomeVFSURI const *uri)
+{
+	gchar *path;
+
+	path = gnome_vfs_unescape_string (uri->text, 
+		G_DIR_SEPARATOR_S);
+		
+	if (path == NULL) {
+		return NULL;
+	}
+
+	if (path[0] != G_DIR_SEPARATOR) {
+		g_free (path);
+		return NULL;
+	}
+
+	return path;
+}
+
+static gchar *
+get_base_from_uri (GnomeVFSURI const *uri)
+{
+	gchar *escaped_base, *base;
+
+	escaped_base = gnome_vfs_uri_extract_short_path_name (uri);
+	base = gnome_vfs_unescape_string (escaped_base, G_DIR_SEPARATOR_S);
+	g_free (escaped_base);
+	return base;
+}
+
+typedef struct {
+	GnomeVFSURI *uri;
+	gint fd;
+} FileHandle;
+
+static FileHandle *
+file_handle_new (GnomeVFSURI *uri,
+		 gint fd)
+{
+	FileHandle *result;
+	result = g_new (FileHandle, 1);
+
+	result->uri = gnome_vfs_uri_ref (uri);
+	result->fd = fd;
+
+	return result;
+}
+
+static void
+file_handle_destroy (FileHandle *handle)
+{
+	gnome_vfs_uri_unref (handle->uri);
+	g_free (handle);
+}
+
+static GnomeVFSResult
+do_open (GnomeVFSMethod *method,
+	 GnomeVFSMethodHandle **method_handle,
+	 GnomeVFSURI *uri,
+	 GnomeVFSOpenMode mode,
+	 GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gint fd;
+	mode_t unix_mode;
+	gchar *file_name;
+	struct stat statbuf;
+
+	_GNOME_VFS_METHOD_PARAM_CHECK (method_handle != NULL);
+	_GNOME_VFS_METHOD_PARAM_CHECK (uri != NULL);
+
+	if (mode & GNOME_VFS_OPEN_READ) {
+		if (mode & GNOME_VFS_OPEN_WRITE)
+			unix_mode = O_RDWR;
+		else
+			unix_mode = O_RDONLY;
+	} else {
+		if (mode & GNOME_VFS_OPEN_WRITE)
+			unix_mode = O_WRONLY;
+		else
+			return GNOME_VFS_ERROR_INVALID_OPEN_MODE;
+	}
+
+	if (! (mode & GNOME_VFS_OPEN_RANDOM) && (mode & GNOME_VFS_OPEN_WRITE))
+		unix_mode |= O_TRUNC;
+	
+	file_name = get_path_from_uri (uri);
+	if (file_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	do
+		fd = OPEN (file_name, unix_mode);
+	while (fd == -1
+	       && errno == EINTR
+	       && ! gnome_vfs_context_check_cancellation (context));
+
+	g_free (file_name);
+
+	if (fd == -1)
+		return gnome_vfs_result_from_errno ();
+
+	if (fstat (fd, &statbuf) != 0)
+		return gnome_vfs_result_from_errno ();
+
+	if (S_ISDIR (statbuf.st_mode)) {
+		close (fd);
+		return GNOME_VFS_ERROR_IS_DIRECTORY;
+	}
+
+	file_handle = file_handle_new (uri, fd);
+	
+	*method_handle = (GnomeVFSMethodHandle *) file_handle;
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_create (GnomeVFSMethod *method,
+	   GnomeVFSMethodHandle **method_handle,
+	   GnomeVFSURI *uri,
+	   GnomeVFSOpenMode mode,
+	   gboolean exclusive,
+	   guint perm,
+	   GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gint fd;
+	mode_t unix_mode;
+	gchar *file_name;
+
+	_GNOME_VFS_METHOD_PARAM_CHECK (method_handle != NULL);
+	_GNOME_VFS_METHOD_PARAM_CHECK (uri != NULL);
+
+	unix_mode = O_CREAT | O_TRUNC;
+	
+	if (!(mode & GNOME_VFS_OPEN_WRITE))
+		return GNOME_VFS_ERROR_INVALID_OPEN_MODE;
+
+	if (mode & GNOME_VFS_OPEN_READ)
+		unix_mode |= O_RDWR;
+	else
+		unix_mode |= O_WRONLY;
+
+	if (exclusive)
+		unix_mode |= O_EXCL;
+
+	file_name = get_path_from_uri (uri);
+	if (file_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	do
+		fd = OPEN (file_name, unix_mode, perm);
+	while (fd == -1
+	       && errno == EINTR
+	       && ! gnome_vfs_context_check_cancellation (context));
+
+	g_free (file_name);
+
+	if (fd == -1)
+		return gnome_vfs_result_from_errno ();
+
+	file_handle = file_handle_new (uri, fd);
+
+	*method_handle = (GnomeVFSMethodHandle *) file_handle;
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_close (GnomeVFSMethod *method,
+	  GnomeVFSMethodHandle *method_handle,
+	  GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gint close_retval;
+
+	g_return_val_if_fail (method_handle != NULL, GNOME_VFS_ERROR_INTERNAL);
+
+	file_handle = (FileHandle *) method_handle;
+
+	do
+		close_retval = close (file_handle->fd);
+	while (close_retval != 0
+	       && errno == EINTR
+	       && ! gnome_vfs_context_check_cancellation (context));
+
+	/* FIXME bugzilla.eazel.com 1163: Should do this even after a failure?  */
+	file_handle_destroy (file_handle);
+
+	if (close_retval != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_read (GnomeVFSMethod *method,
+	 GnomeVFSMethodHandle *method_handle,
+	 gpointer buffer,
+	 GnomeVFSFileSize num_bytes,
+	 GnomeVFSFileSize *bytes_read,
+	 GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gint read_val;
+
+	g_return_val_if_fail (method_handle != NULL, GNOME_VFS_ERROR_INTERNAL);
+
+	file_handle = (FileHandle *) method_handle;
+
+	do {
+		read_val = read (file_handle->fd, buffer, num_bytes);
+	} while (read_val == -1
+	         && errno == EINTR
+	         && ! gnome_vfs_context_check_cancellation (context));
+
+	if (read_val == -1) {
+		*bytes_read = 0;
+		return gnome_vfs_result_from_errno ();
+	} else {
+		*bytes_read = read_val;
+
+		/* Getting 0 from read() means EOF! */
+		if (read_val == 0) {
+			return GNOME_VFS_ERROR_EOF;
+		}
+	}
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_write (GnomeVFSMethod *method,
+	  GnomeVFSMethodHandle *method_handle,
+	  gconstpointer buffer,
+	  GnomeVFSFileSize num_bytes,
+	  GnomeVFSFileSize *bytes_written,
+	  GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gint write_val;
+
+	g_return_val_if_fail (method_handle != NULL, GNOME_VFS_ERROR_INTERNAL);
+
+	file_handle = (FileHandle *) method_handle;
+
+	do
+		write_val = write (file_handle->fd, buffer, num_bytes);
+	while (write_val == -1
+	       && errno == EINTR
+	       && ! gnome_vfs_context_check_cancellation (context));
+
+	if (write_val == -1) {
+		*bytes_written = 0;
+		return gnome_vfs_result_from_errno ();
+	} else {
+		*bytes_written = write_val;
+		return GNOME_VFS_OK;
+	}
+}
+
+
+static gint
+seek_position_to_unix (GnomeVFSSeekPosition position)
+{
+	switch (position) {
+	case GNOME_VFS_SEEK_START:
+		return SEEK_SET;
+	case GNOME_VFS_SEEK_CURRENT:
+		return SEEK_CUR;
+	case GNOME_VFS_SEEK_END:
+		return SEEK_END;
+	default:
+		g_warning (_("Unknown GnomeVFSSeekPosition %d"), position);
+		return SEEK_SET; /* bogus */
+	}
+}
+
+static GnomeVFSResult
+do_seek (GnomeVFSMethod *method,
+	 GnomeVFSMethodHandle *method_handle,
+	 GnomeVFSSeekPosition whence,
+	 GnomeVFSFileOffset offset,
+	 GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gint lseek_whence;
+
+	file_handle = (FileHandle *) method_handle;
+	lseek_whence = seek_position_to_unix (whence);
+
+	if (LSEEK (file_handle->fd, offset, lseek_whence) == -1) {
+		if (errno == ESPIPE)
+			return GNOME_VFS_ERROR_NOT_SUPPORTED;
+		else
+			return gnome_vfs_result_from_errno ();
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_tell (GnomeVFSMethod *method,
+	 GnomeVFSMethodHandle *method_handle,
+	 GnomeVFSFileOffset *offset_return)
+{
+	FileHandle *file_handle;
+	OFF_T offset;
+
+	file_handle = (FileHandle *) method_handle;
+
+	offset = LSEEK (file_handle->fd, 0, SEEK_CUR);
+	if (offset == -1) {
+		if (errno == ESPIPE)
+			return GNOME_VFS_ERROR_NOT_SUPPORTED;
+		else
+			return gnome_vfs_result_from_errno ();
+	}
+
+	*offset_return = offset;
+	return GNOME_VFS_OK;
+}
+
+
+static GnomeVFSResult
+do_truncate_handle (GnomeVFSMethod *method,
+		    GnomeVFSMethodHandle *method_handle,
+		    GnomeVFSFileSize where,
+		    GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+
+	g_return_val_if_fail (method_handle != NULL, GNOME_VFS_ERROR_INTERNAL);
+
+	file_handle = (FileHandle *) method_handle;
+
+	if (ftruncate (file_handle->fd, where) == 0) {
+		return GNOME_VFS_OK;
+	} else {
+		switch (errno) {
+		case EBADF:
+		case EROFS:
+			return GNOME_VFS_ERROR_READ_ONLY;
+		case EINVAL:
+			return GNOME_VFS_ERROR_NOT_SUPPORTED;
+		default:
+			return GNOME_VFS_ERROR_GENERIC;
+		}
+	}
+}
+
+static GnomeVFSResult
+do_truncate (GnomeVFSMethod *method,
+	     GnomeVFSURI *uri,
+	     GnomeVFSFileSize where,
+	     GnomeVFSContext *context)
+{
+	gchar *path;
+
+	path = get_path_from_uri (uri);
+	if (path == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	if (truncate (path, where) == 0) {
+		g_free (path);
+		return GNOME_VFS_OK;
+	} else {
+		g_free (path);
+		switch (errno) {
+		case EBADF:
+		case EROFS:
+			return GNOME_VFS_ERROR_READ_ONLY;
+		case EINVAL:
+			return GNOME_VFS_ERROR_NOT_SUPPORTED;
+		default:
+			return GNOME_VFS_ERROR_GENERIC;
+		}
+	}
+}
+
+typedef struct {
+	GnomeVFSURI *uri;
+	DIR *dir;
+	GnomeVFSFileInfoOptions options;
+
+	struct dirent *current_entry;
+
+	gchar *name_buffer;
+	gchar *name_ptr;
+} DirectoryHandle;
+
+static DirectoryHandle *
+directory_handle_new (GnomeVFSURI *uri,
+		      DIR *dir,
+		      GnomeVFSFileInfoOptions options)
+{
+	DirectoryHandle *result;
+	gchar *full_name;
+	guint full_name_len;
+
+	result = g_new (DirectoryHandle, 1);
+
+	result->uri = gnome_vfs_uri_ref (uri);
+	result->dir = dir;
+
+	/* Reserve extra space for readdir_r, see man page */
+	result->current_entry = g_malloc (sizeof (struct dirent) + GET_PATH_MAX() + 1);
+
+	full_name = get_path_from_uri (uri);
+	g_assert (full_name != NULL); /* already done by caller */
+	full_name_len = strlen (full_name);
+
+	result->name_buffer = g_malloc (full_name_len + GET_PATH_MAX () + 2);
+	memcpy (result->name_buffer, full_name, full_name_len);
+	
+	if (full_name_len > 0 && full_name[full_name_len - 1] != '/')
+		result->name_buffer[full_name_len++] = '/';
+
+	result->name_ptr = result->name_buffer + full_name_len;
+
+	g_free (full_name);
+
+	result->options = options;
+
+	return result;
+}
+
+static void
+directory_handle_destroy (DirectoryHandle *directory_handle)
+{
+	gnome_vfs_uri_unref (directory_handle->uri);
+	g_free (directory_handle->name_buffer);
+	g_free (directory_handle->current_entry);
+	g_free (directory_handle);
+}
+
+/* MIME detection code.  */
+static void
+get_mime_type (GnomeVFSFileInfo *info,
+	       const char *full_name,
+	       GnomeVFSFileInfoOptions options,
+	       struct stat *stat_buffer)
+{
+	const char *mime_type;
+
+	mime_type = NULL;
+	if ((options & GNOME_VFS_FILE_INFO_FOLLOW_LINKS) == 0
+		&& (info->type == GNOME_VFS_FILE_TYPE_SYMBOLIC_LINK)) {
+		/* we are a symlink and aren't asked to follow -
+		 * return the type for a symlink
+		 */
+		mime_type = "x-special/symlink";
+	} else {
+		if (options & GNOME_VFS_FILE_INFO_FORCE_FAST_MIME_TYPE) {
+			mime_type = gnome_vfs_get_file_mime_type (full_name,
+								  stat_buffer, TRUE);
+		} else if (options & GNOME_VFS_FILE_INFO_FORCE_SLOW_MIME_TYPE) {
+			mime_type = gnome_vfs_get_file_mime_type (full_name,
+								  stat_buffer, FALSE);
+		} else {
+			mime_type = gnome_vfs_get_file_mime_type_fast (full_name,
+								       stat_buffer);
+		}
+	}
+
+	g_assert (mime_type);
+	info->mime_type = g_strdup (mime_type);
+	info->valid_fields |= GNOME_VFS_FILE_INFO_FIELDS_MIME_TYPE;
+}
+
+static gchar *
+read_link (const gchar *full_name)
+{
+	gchar *buffer;
+	guint size;
+
+	size = 256;
+	buffer = g_malloc (size);
+          
+	while (1) {
+		int read_size;
+
+                read_size = readlink (full_name, buffer, size);
+		if (read_size < 0) {
+			g_free (buffer);
+			return NULL;
+		}
+                if (read_size < size) {
+			buffer[read_size] = 0;
+			return buffer;
+		}
+                size *= 2;
+		buffer = g_realloc (buffer, size);
+	}
+}
+
+static void
+get_access_info (GnomeVFSFileInfo *file_info,
+              const gchar *full_name)
+{
+     /* FIXME: should check errno after calling access because we don't
+      * want to set valid_fields if something bad happened during one
+      * of the access calls
+      */
+     if (access (full_name, R_OK) == 0) {
+             file_info->permissions |= GNOME_VFS_PERM_ACCESS_READABLE;
+     }
+
+     if (access (full_name, W_OK) == 0) {
+             file_info->permissions |= GNOME_VFS_PERM_ACCESS_WRITABLE;
+     }
+
+     if (access (full_name, X_OK) == 0) {
+             file_info->permissions |= GNOME_VFS_PERM_ACCESS_EXECUTABLE;
+     }
+     file_info->valid_fields |= GNOME_VFS_FILE_INFO_FIELDS_ACCESS;
+}
+
+static GnomeVFSResult
+get_stat_info (GnomeVFSFileInfo *file_info,
+	       const gchar *full_name,
+	       GnomeVFSFileInfoOptions options,
+	       struct stat *statptr)
+{
+	struct stat statbuf;
+	gboolean followed_symlink;
+	gboolean is_symlink;
+	gboolean recursive;
+	char *link_file_path;
+	char *symlink_name;
+	char *symlink_dir;
+	char *newpath;
+	
+	followed_symlink = FALSE;
+	
+	recursive = FALSE;
+
+	GNOME_VFS_FILE_INFO_SET_LOCAL (file_info, TRUE);
+
+	if (statptr == NULL) {
+		statptr = &statbuf;
+	}
+
+	if (lstat (full_name, statptr) != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+
+	is_symlink = S_ISLNK (statptr->st_mode);
+
+	if ((options & GNOME_VFS_FILE_INFO_FOLLOW_LINKS) && is_symlink) {
+		if (stat (full_name, statptr) != 0) {
+			if (errno == ELOOP) {
+				recursive = TRUE;
+			}
+
+			/* It's a broken symlink, revert to the lstat. This is sub-optimal but
+			 * acceptable because it's not a common case.
+			 */
+			if (lstat (full_name, statptr) != 0) {
+				return gnome_vfs_result_from_errno ();
+			}
+		}
+		GNOME_VFS_FILE_INFO_SET_SYMLINK (file_info, TRUE);
+		followed_symlink = TRUE;
+	}
+
+	gnome_vfs_stat_to_file_info (file_info, statptr);
+
+	if (is_symlink) {
+		symlink_name = NULL;
+		link_file_path = g_strdup (full_name);
+		
+		/* We will either successfully read the link name or return
+		 * NULL if read_link fails -- flag it as a valid field either
+		 * way.
+		 */
+		file_info->valid_fields |= GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME;
+
+		while (TRUE) {			
+			/* Deal with multiple-level symlinks by following them as
+			 * far as we can.
+			 */
+
+			g_free (symlink_name);
+			symlink_name = read_link (link_file_path);
+			if (symlink_name == NULL) {
+				g_free (link_file_path);
+				return gnome_vfs_result_from_errno ();
+			}
+			if ((options & GNOME_VFS_FILE_INFO_FOLLOW_LINKS) &&
+			    symlink_name[0] != '/') {
+				symlink_dir = g_path_get_dirname (link_file_path);
+				newpath = g_build_filename (symlink_dir,
+							    symlink_name, NULL);
+				g_free (symlink_dir);
+				g_free (symlink_name);
+				symlink_name = gnome_vfs_make_path_name_canonical (newpath);
+				g_free (newpath);
+			}
+			
+			if ((options & GNOME_VFS_FILE_INFO_FOLLOW_LINKS) == 0
+			                /* if we had an earlier ELOOP, don't get in an infinite loop here */
+			        || recursive
+					/* we don't care to follow links */
+				|| lstat (symlink_name, statptr) != 0
+					/* we can't make out where this points to */
+				|| !S_ISLNK (statptr->st_mode)) {
+					/* the next level is not a link */
+				break;
+			}
+			g_free (link_file_path);
+			link_file_path = g_strdup (symlink_name);
+		}
+		g_free (link_file_path);
+
+		file_info->symlink_name = symlink_name;
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+get_stat_info_from_handle (GnomeVFSFileInfo *file_info,
+			   FileHandle *handle,
+			   GnomeVFSFileInfoOptions options,
+			   struct stat *statptr)
+{
+	struct stat statbuf;
+
+	if (statptr == NULL) {
+		statptr = &statbuf;
+	}
+
+	if (fstat (handle->fd, statptr) != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+	
+	gnome_vfs_stat_to_file_info (file_info, statptr);
+	GNOME_VFS_FILE_INFO_SET_LOCAL (file_info, TRUE);
+
+	return GNOME_VFS_OK;
+}
+
+
+static GnomeVFSResult
+do_open_directory (GnomeVFSMethod *method,
+		   GnomeVFSMethodHandle **method_handle,
+		   GnomeVFSURI *uri,
+		   GnomeVFSFileInfoOptions options,
+		   GnomeVFSContext *context)
+{
+	gchar *directory_name;
+	DIR *dir;
+
+	directory_name = get_path_from_uri (uri);
+	if (directory_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	dir = opendir (directory_name);
+	g_free (directory_name);
+	if (dir == NULL)
+		return gnome_vfs_result_from_errno ();
+
+	*method_handle
+		= (GnomeVFSMethodHandle *) directory_handle_new (uri, dir,
+								 options);
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_close_directory (GnomeVFSMethod *method,
+		    GnomeVFSMethodHandle *method_handle,
+		    GnomeVFSContext *context)
+{
+	DirectoryHandle *directory_handle;
+
+	directory_handle = (DirectoryHandle *) method_handle;
+
+	closedir (directory_handle->dir);
+
+	directory_handle_destroy (directory_handle);
+
+	return GNOME_VFS_OK;
+}
+
+#ifndef HAVE_READDIR_R
+G_LOCK_DEFINE_STATIC (readdir);
+#endif
+
+static GnomeVFSResult
+do_read_directory (GnomeVFSMethod *method,
+		   GnomeVFSMethodHandle *method_handle,
+		   GnomeVFSFileInfo *file_info,
+		   GnomeVFSContext *context)
+{
+	struct dirent *result;
+	struct stat statbuf;
+	gchar *full_name;
+	DirectoryHandle *handle;
+
+	handle = (DirectoryHandle *) method_handle;
+	
+	errno = 0;
+#ifdef HAVE_READDIR_R	
+	if (readdir_r (handle->dir, handle->current_entry, &result) != 0) {
+		/* Work around a Solaris bug.
+		 * readdir64_r returns -1 instead of 0 at EOF.
+		 */
+		if (errno == 0) {
+			return GNOME_VFS_ERROR_EOF;
+		}
+		return gnome_vfs_result_from_errno ();
+	}
+#else
+	G_LOCK (readdir);
+	errno = 0;
+	result = readdir (handle->dir);
+
+	if (result == NULL && errno != 0) {
+		GnomeVFSResult ret = gnome_vfs_result_from_errno ();
+		G_UNLOCK (readdir);
+		return ret;
+	}
+	if (result != NULL) {
+		memcpy (handle->current_entry, result, sizeof (struct dirent));
+	}
+	G_UNLOCK (readdir);
+#endif
+	
+	if (result == NULL) {
+		return GNOME_VFS_ERROR_EOF;
+	}
+
+	file_info->name = g_strdup (result->d_name);
+
+	strcpy (handle->name_ptr, result->d_name);
+	full_name = handle->name_buffer;
+
+	if (get_stat_info (file_info, full_name, handle->options, &statbuf) != GNOME_VFS_OK) {
+		/* Return OK - this should not terminate the directory iteration
+		 * and we will know from the valid_fields that we don't have the
+		 * stat info.
+		 */
+		return GNOME_VFS_OK;
+	}
+	
+	if (handle->options & GNOME_VFS_FILE_INFO_GET_MIME_TYPE) {
+		get_mime_type (file_info, full_name, handle->options, &statbuf);
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_get_file_info (GnomeVFSMethod *method,
+		  GnomeVFSURI *uri,
+		  GnomeVFSFileInfo *file_info,
+		  GnomeVFSFileInfoOptions options,
+		  GnomeVFSContext *context)
+{
+	GnomeVFSResult result;
+	gchar *full_name;
+	struct stat statbuf;
+
+	full_name = get_path_from_uri (uri);
+	if (full_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	file_info->valid_fields = GNOME_VFS_FILE_INFO_FIELDS_NONE;
+
+	file_info->name = get_base_from_uri (uri);
+	g_assert (file_info->name != NULL);
+
+	result = get_stat_info (file_info, full_name, options, &statbuf);
+	if (result != GNOME_VFS_OK) {
+		g_free (full_name);
+		return result;
+	}
+
+	if (options & GNOME_VFS_FILE_INFO_GET_ACCESS_RIGHTS) {
+		get_access_info (file_info, full_name);
+	}
+
+	if (options & GNOME_VFS_FILE_INFO_GET_MIME_TYPE) {
+		get_mime_type (file_info, full_name, options, &statbuf);
+	}
+
+	g_free (full_name);
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_get_file_info_from_handle (GnomeVFSMethod *method,
+			      GnomeVFSMethodHandle *method_handle,
+			      GnomeVFSFileInfo *file_info,
+			      GnomeVFSFileInfoOptions options,
+			      GnomeVFSContext *context)
+{
+	FileHandle *file_handle;
+	gchar *full_name;
+	struct stat statbuf;
+	GnomeVFSResult result;
+
+	file_handle = (FileHandle *) method_handle;
+
+	file_info->valid_fields = GNOME_VFS_FILE_INFO_FIELDS_NONE;
+
+	full_name = get_path_from_uri (file_handle->uri);
+	if (full_name == NULL) {
+		return GNOME_VFS_ERROR_INVALID_URI;
+	}
+
+	file_info->name = get_base_from_uri (file_handle->uri);
+	g_assert (file_info->name != NULL);
+
+	result = get_stat_info_from_handle (file_info, file_handle,
+					    options, &statbuf);
+	if (result != GNOME_VFS_OK) {
+		g_free (full_name);
+		return result;
+	}
+
+	if (options & GNOME_VFS_FILE_INFO_GET_MIME_TYPE) {
+		get_mime_type (file_info, full_name, options, &statbuf);
+	}
+
+	g_free (full_name);
+
+	return GNOME_VFS_OK;
+}
+
+GHashTable *fstype_hash = NULL;
+G_LOCK_DEFINE_STATIC (fstype_hash);
+extern char *filesystem_type (char *path, char *relpath, struct stat *statp);
+
+static gboolean
+do_is_local (GnomeVFSMethod *method,
+	     const GnomeVFSURI *uri)
+{
+	gchar *path;
+	gpointer local = NULL;
+
+	g_return_val_if_fail (uri != NULL, FALSE);
+
+	path = get_path_from_uri (uri);
+	if (path == NULL)
+		return TRUE; /* GNOME_VFS_ERROR_INVALID_URI */
+
+	G_LOCK (fstype_hash);
+	if (fstype_hash == NULL)
+		fstype_hash = g_hash_table_new_full (
+			g_str_hash, g_str_equal, g_free, NULL);
+	else
+		local = g_hash_table_lookup (fstype_hash, path);
+
+	if (local == NULL) {
+		struct stat statbuf;
+		if (stat (path, &statbuf) == 0) {
+			char *type = filesystem_type (path, path, &statbuf);
+			gboolean is_local = ((strcmp (type, "nfs") != 0) && 
+					     (strcmp (type, "afs") != 0) &&
+					     (strcmp (type, "ncpfs") != 0));
+			local = GINT_TO_POINTER (is_local ? 1 : -1);
+			g_hash_table_insert (fstype_hash, path, local);
+		}
+	} else
+		g_free (path);
+
+	G_UNLOCK (fstype_hash);
+	return GPOINTER_TO_INT (local) > 0;
+}
+
+
+static GnomeVFSResult
+do_make_directory (GnomeVFSMethod *method,
+		   GnomeVFSURI *uri,
+		   guint perm,
+		   GnomeVFSContext *context)
+{
+	gint retval;
+	gchar *full_name;
+
+	full_name = get_path_from_uri (uri);
+	if (full_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	retval = mkdir (full_name, perm);
+
+	g_free (full_name);
+
+	if (retval != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_remove_directory (GnomeVFSMethod *method,
+		     GnomeVFSURI *uri,
+		     GnomeVFSContext *context)
+{
+	gchar *full_name;
+	gint retval;
+
+	full_name = get_path_from_uri (uri);
+	if (full_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	retval = rmdir (full_name);
+
+	g_free (full_name);
+
+	if (retval != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+
+	return GNOME_VFS_OK;
+}
+
+#undef DEBUG_FIND_DIRECTORY
+/* Get rid of debugging code once we know the logic works. */
+
+#define TRASH_DIRECTORY_NAME_BASE ".Trash"
+#define MAX_TRASH_SEARCH_DEPTH 5
+
+/* mkdir_recursive 
+ * Works like mkdir, except it creates all the levels of directories in @path.
+ */
+static int
+mkdir_recursive (const char *path, int permission_bits)
+{
+	struct stat stat_buffer;
+	const char *dir_separator_scanner;
+	char *current_path;
+
+	/* try creating a director for each level */
+	for (dir_separator_scanner = path;; dir_separator_scanner++) {
+		/* advance to the next directory level */
+		for (;;dir_separator_scanner++) {
+			if (!*dir_separator_scanner) {
+				break;
+			}	
+			if (*dir_separator_scanner == G_DIR_SEPARATOR) {
+				break;
+			}
+		}
+		if (dir_separator_scanner - path > 0) {
+			current_path = g_strndup (path, dir_separator_scanner - path);
+			mkdir (current_path, permission_bits);
+			if (stat (current_path, &stat_buffer) != 0) {
+				/* we failed to create a directory and it wasn't there already;
+				 * bail
+				 */
+				g_free (current_path);
+				return -1;
+			}
+			g_free (current_path);
+		}
+		if (!*dir_separator_scanner) {
+			break;
+		}	
+	}
+	return 0;
+}
+
+
+static char *
+append_to_path (const char *path, const char *name)
+{
+	return g_strconcat (path, G_DIR_SEPARATOR_S, name, NULL);
+}
+
+static char *
+append_trash_path (const char *path)
+{	
+	/* When creating trash outside of /home/pavel, create it in the form:
+	 * .Trash-pavel to allow sharing the name space for several users.
+	 * Treat "/" specially to avoid creating non-canonical "//foo" path.
+	 */
+	if (strcmp (path, "/") == 0) {
+		return g_strconcat (path, TRASH_DIRECTORY_NAME_BASE,
+		"-", g_get_user_name (), NULL);
+	} else {
+		return g_strconcat (path, G_DIR_SEPARATOR_S, TRASH_DIRECTORY_NAME_BASE,
+			"-", g_get_user_name (), NULL);
+	}
+}
+
+static char *
+find_trash_in_hierarchy (const char *start_dir, dev_t near_device_id, GnomeVFSContext *context)
+{
+	char *trash_path;
+	struct stat stat_buffer;
+
+	if (gnome_vfs_context_check_cancellation (context))
+		return NULL;
+
+	/* check if there is a trash in this directory */
+	trash_path = append_trash_path (start_dir);
+	if (lstat (trash_path, &stat_buffer) == 0 && S_ISDIR (stat_buffer.st_mode)) {
+		/* found it, we are done */
+		g_assert (near_device_id == stat_buffer.st_dev);
+		return trash_path;
+	}
+	g_free (trash_path);
+
+	return NULL;
+}
+
+static GList *cached_trash_directories;
+G_LOCK_DEFINE_STATIC (cached_trash_directories);
+
+/* Element used to store chached Trash entries in the local, in-memory Trash item cache. */
+typedef struct {
+	char *path;
+	char *device_mount_point;
+	dev_t device_id;
+} TrashDirectoryCachedItem;
+
+typedef struct {
+	dev_t device_id;
+} FindByDeviceIDParameters;
+
+static int
+match_trash_item_by_device_id (gconstpointer item, gconstpointer data)
+{
+	const TrashDirectoryCachedItem *cached_item;
+	FindByDeviceIDParameters *parameters;
+
+	cached_item = (const TrashDirectoryCachedItem *)item;
+	parameters = (FindByDeviceIDParameters *)data;
+	
+	return cached_item->device_id == parameters->device_id ? 0 : -1;
+}
+
+static char *
+try_creating_trash_in (const char *path, guint permissions)
+{
+	char *trash_path;
+
+
+	trash_path = append_trash_path (path);
+	if (mkdir_recursive (trash_path, permissions) == 0) {
+#ifdef DEBUG_FIND_DIRECTORY
+		g_print ("created trash in %s\n", trash_path);
+#endif
+		return trash_path;
+	}
+
+#ifdef DEBUG_FIND_DIRECTORY
+	g_print ("failed to create trash in %s\n", trash_path);
+#endif
+	g_free (trash_path);
+	return NULL;
+}
+
+static char *
+find_disk_top_directory (const char *item_on_disk,
+			 dev_t near_device_id,
+			 GnomeVFSContext *context)
+{
+	char *disk_top_directory;
+	struct stat stat_buffer;
+
+	disk_top_directory = g_strdup (item_on_disk);
+
+	/* Walk up in the hierarchy, finding the top-most point that still
+	 * matches our device ID -- the root directory of the volume.
+	 */
+	for (;;) {
+		char *previous_search_directory;
+		char *last_slash;
+		
+		previous_search_directory = g_strdup (disk_top_directory);
+		last_slash = strrchr (disk_top_directory, '/');
+		if (last_slash == NULL) {
+			g_free (previous_search_directory);
+			break;
+		}
+		
+		*last_slash = '\0';
+		if (stat (disk_top_directory, &stat_buffer) < 0
+			|| stat_buffer.st_dev != near_device_id) {
+			/* we ran past the root of the disk we are exploring */
+			g_free (disk_top_directory);
+			disk_top_directory = previous_search_directory;
+			break;
+		}
+		/* FIXME bugzilla.eazel.com 2733: This must result in
+		 * a cancelled error, but there's no way for the
+		 * caller to know that. We probably have to add a
+		 * GnomeVFSResult to this function.  
+		 */
+		if (gnome_vfs_context_check_cancellation (context)) {
+			g_free (previous_search_directory);
+			g_free (disk_top_directory);
+			return NULL;
+		}
+	}
+	return disk_top_directory;
+}
+
+#define TRASH_ENTRY_CACHE_PARENT ".gnome/gnome-vfs"
+#define TRASH_ENTRY_CACHE_NAME ".trash_entry_cache"
+#define NON_EXISTENT_TRASH_ENTRY "-"
+
+/* Save the localy cached Trashed paths on disk in the user's home
+ * directory.
+ */
+static void
+save_trash_entry_cache (void)
+{
+	int cache_file;
+	char *cache_file_parent, *cache_file_path;
+	GList *p;
+	char *buffer, *escaped_path, *escaped_mount_point;
+
+	cache_file_parent = append_to_path (g_get_home_dir (), TRASH_ENTRY_CACHE_PARENT);
+	cache_file_path = append_to_path (cache_file_parent, TRASH_ENTRY_CACHE_NAME);
+
+	if (mkdir_recursive (cache_file_parent, 0777) != 0) {
+		g_warning ("failed to create trash item cache file");
+		return;
+	}
+
+	cache_file = open (cache_file_path, O_CREAT | O_TRUNC | O_RDWR, 0666);
+	if (cache_file < 0) {
+		g_warning ("failed to create trash item cache file");
+		return;
+	}
+
+	for (p = cached_trash_directories; p != NULL; p = p->next) {
+		/* Use proper escaping to not confuse paths with spaces in them */
+		escaped_path = gnome_vfs_escape_path_string (
+			((TrashDirectoryCachedItem *)p->data)->path);
+		escaped_mount_point = gnome_vfs_escape_path_string(
+			((TrashDirectoryCachedItem *)p->data)->device_mount_point);
+			
+		buffer = g_strdup_printf ("%s %s\n", escaped_mount_point, escaped_path);
+		write (cache_file, buffer, strlen (buffer));
+
+#ifdef DEBUG_FIND_DIRECTORY
+	g_print ("saving trash item cache %s\n", buffer);
+#endif
+
+		g_free (buffer);
+		g_free (escaped_mount_point);
+		g_free (escaped_path);
+	}
+	close (cache_file);
+	
+	g_free (cache_file_path);
+	g_free (cache_file_parent);
+}
+
+typedef struct {
+	const char *mount_point;
+	const char *trash_path;
+	dev_t device_id;
+	gboolean done;
+} UpdateOneCachedEntryContext;
+
+/* Updates one entry in the local Trash item cache to reflect the
+ * location we just found or in which we created a new Trash.
+ */
+static void
+update_one_cached_trash_entry (gpointer element, gpointer cast_to_context)
+{
+	UpdateOneCachedEntryContext *context;
+	TrashDirectoryCachedItem *item;
+
+	context = (UpdateOneCachedEntryContext *)cast_to_context;
+	item = (TrashDirectoryCachedItem *)element;
+
+	if (context->done) {
+		/* We already took care of business in a previous iteration. */
+		return;
+	}
+
+	if (strcmp (context->mount_point, item->device_mount_point) == 0) {
+		/* This is the item we are looking for, update it. */
+		g_free (item->path);
+		item->path = g_strdup (context->trash_path);
+		item->device_id = context->device_id;
+
+		/* no more work */
+		context->done = TRUE;
+	}
+}
+
+static void
+add_local_cached_trash_entry (dev_t near_device_id, const char *trash_path, const char *mount_point)
+{
+	TrashDirectoryCachedItem *new_cached_item;
+	UpdateOneCachedEntryContext update_context;
+
+	/* First check if we already have an entry for this mountpoint,
+	 * if so, update it.
+	 */
+
+	update_context.mount_point = mount_point;
+	update_context.trash_path = trash_path;
+	update_context.device_id = near_device_id;
+	update_context.done = FALSE;
+
+	g_list_foreach (cached_trash_directories, update_one_cached_trash_entry, &update_context);
+	if (update_context.done) {
+		/* Sucessfully updated, no more work left. */
+		return;
+	}
+	
+	/* Save the new trash item to the local cache. */
+	new_cached_item = g_new (TrashDirectoryCachedItem, 1);
+	new_cached_item->path = g_strdup (trash_path);
+	new_cached_item->device_mount_point = g_strdup (mount_point);
+	new_cached_item->device_id = near_device_id;
+
+
+	cached_trash_directories = g_list_prepend (cached_trash_directories, new_cached_item);
+}
+
+static void
+add_cached_trash_entry (dev_t near_device_id, const char *trash_path, const char *mount_point)
+{
+	add_local_cached_trash_entry (near_device_id, trash_path, mount_point);
+	/* write out the local cache */
+	save_trash_entry_cache ();
+}
+
+static void
+destroy_cached_trash_entry (TrashDirectoryCachedItem *entry)
+{
+	g_free (entry->path);
+	g_free (entry->device_mount_point);
+	g_free (entry);
+}
+
+/* Read the cached entries for the file cache into the local Trash item cache. */
+static void
+read_saved_cached_trash_entries (void)
+{
+	char *cache_file_path;
+	FILE *cache_file;
+	char buffer[2048];
+	char escaped_mount_point[PATH_MAX], escaped_trash_path[PATH_MAX];
+	char *mount_point, *trash_path;
+	struct stat stat_buffer;
+	gboolean removed_item;
+
+	/* empty the old locally cached entries */
+	g_list_foreach (cached_trash_directories, 
+		(GFunc)destroy_cached_trash_entry, NULL);
+	g_list_free (cached_trash_directories);
+	cached_trash_directories = NULL;
+
+	/* read in the entries from disk */
+	cache_file_path = g_strconcat (g_get_home_dir (), G_DIR_SEPARATOR_S,
+		TRASH_ENTRY_CACHE_PARENT, G_DIR_SEPARATOR_S, TRASH_ENTRY_CACHE_NAME, NULL);
+	cache_file = fopen (cache_file_path, "r");
+
+	if (cache_file != NULL) {
+		removed_item = FALSE;
+		for (;;) {
+			if (fgets (buffer, sizeof (buffer), cache_file) == NULL) {
+				break;
+			}
+
+			mount_point = NULL;
+			trash_path = NULL;
+			if (sscanf (buffer, "%s %s", escaped_mount_point, escaped_trash_path) == 2) {
+				/* the paths are saved in escaped form */
+				trash_path = gnome_vfs_unescape_string (escaped_trash_path, "/");
+				mount_point = gnome_vfs_unescape_string (escaped_mount_point, "/"); 
+
+				if (trash_path != NULL 
+					&& mount_point != NULL
+					&& (strcmp (trash_path, NON_EXISTENT_TRASH_ENTRY) != 0 && lstat (trash_path, &stat_buffer) == 0)
+					&& stat (mount_point, &stat_buffer) == 0) {
+					/* We know the trash exist and we checked that it's really
+					 * there - this is a good entry, copy it into the local cache.
+					 * We don't want to rely on old non-existing trash entries, as they
+					 * could have changed now, and they stick around filling up the cache,
+					 * and slowing down startup.
+					 */
+					 add_local_cached_trash_entry (stat_buffer.st_dev, trash_path, mount_point);
+#ifdef DEBUG_FIND_DIRECTORY
+					g_print ("read trash item cache entry %s %s\n", trash_path, mount_point);
+#endif
+				} else {
+					removed_item = TRUE;
+				}
+			}
+			
+			g_free (trash_path);
+			g_free (mount_point);
+		}
+		fclose (cache_file);
+		/* Save cache to get rid of stuff from on-disk cache */
+		if (removed_item) {
+			save_trash_entry_cache ();
+		}
+	}
+	
+	g_free (cache_file_path);
+}
+
+/* Create a Trash directory on the same disk as @full_name_near. */
+static char *
+create_trash_near (const char *full_name_near, dev_t near_device_id, const char *disk_top_directory,
+	guint permissions, GnomeVFSContext *context)
+{
+	return try_creating_trash_in (disk_top_directory, permissions);
+}
+
+
+static gboolean
+cached_trash_entry_exists (const TrashDirectoryCachedItem *entry)
+{
+	struct stat stat_buffer;
+	return lstat (entry->path, &stat_buffer) == 0;
+}
+
+/* Search through the local cache looking for an entry that matches a given
+ * device ID. If @check_disk specified, check if the entry we found actually exists.
+ */
+static char *
+find_locally_cached_trash_entry_for_device_id (dev_t device_id, gboolean check_disk)
+{
+	GList *matching_item;
+	FindByDeviceIDParameters tmp;
+	const char *trash_path;
+
+	tmp.device_id = device_id;
+
+	matching_item = g_list_find_custom (cached_trash_directories, 
+		&tmp, match_trash_item_by_device_id);
+
+	if (matching_item == NULL) {
+		return NULL;
+	}
+
+	trash_path = ((TrashDirectoryCachedItem *)matching_item->data)->path;
+
+	if (trash_path == NULL) {
+		/* we already know that this disk does not contain a trash directory */
+#ifdef DEBUG_FIND_DIRECTORY
+		g_print ("cache indicates no trash for %s \n", trash_path);
+#endif
+		return g_strdup (NON_EXISTENT_TRASH_ENTRY);
+	}
+
+	if (check_disk) {
+		/* We found something, make sure it still exists. */
+		if (strcmp (((TrashDirectoryCachedItem *)matching_item->data)->path, NON_EXISTENT_TRASH_ENTRY) != 0
+			&& !cached_trash_entry_exists ((TrashDirectoryCachedItem *)matching_item->data)) {
+			/* The cached item doesn't really exist, make a new one
+			 * and delete the cached entry
+			 */
+#ifdef DEBUG_FIND_DIRECTORY
+			g_print ("entry %s doesn't exist, removing \n", 
+				((TrashDirectoryCachedItem *)matching_item->data)->path);
+#endif
+			destroy_cached_trash_entry ((TrashDirectoryCachedItem *)matching_item->data);
+			cached_trash_directories = g_list_remove (cached_trash_directories, 
+				matching_item->data);
+			return NULL;
+		}
+	}
+
+#ifdef DEBUG_FIND_DIRECTORY
+	g_print ("local cache found %s \n", trash_path);
+#endif
+	g_assert (matching_item != NULL);
+	return g_strdup (trash_path);
+}
+
+/* Look for an entry in the file and local caches. */
+static char *
+find_cached_trash_entry_for_device (dev_t device_id, gboolean check_disk)
+{
+	if (cached_trash_directories == NULL) {
+		if (!check_disk) {
+			return NULL;
+		}
+		read_saved_cached_trash_entries ();
+	}
+	return find_locally_cached_trash_entry_for_device_id (device_id, check_disk);
+}
+
+/* Search for a Trash entry or create one. Called when there is no cached entry. */
+static char *
+find_or_create_trash_near (const char *full_name_near, dev_t near_device_id, 
+	gboolean create_if_needed, gboolean find_if_needed, guint permissions, 
+	GnomeVFSContext *context)
+{
+	char *result;
+	char *disk_top_directory;
+
+	result = NULL;
+	/* figure out the topmost disk directory */
+	disk_top_directory = find_disk_top_directory (full_name_near, 
+						      near_device_id, context);
+
+	if (disk_top_directory == NULL) {
+		/* Failed to find it, don't look at this disk until we
+		 * are ready to try to create a Trash on it again.
+		 */
+#ifdef DEBUG_FIND_DIRECTORY
+		g_print ("failed to find top disk directory for %s\n", full_name_near);
+#endif
+		add_cached_trash_entry (near_device_id, NON_EXISTENT_TRASH_ENTRY, disk_top_directory);
+		return NULL;
+	}
+
+	if (find_if_needed) {
+		/* figure out the topmost disk directory */
+		result = find_trash_in_hierarchy (disk_top_directory, near_device_id, context);
+		if (result == NULL) {
+			/* We just found out there is no Trash on the disk, 
+			 * remember this for next time.
+			 */
+			result = g_strdup(NON_EXISTENT_TRASH_ENTRY);
+		}
+	}
+
+	if (result == NULL && create_if_needed) {
+		/* didn't find a Trash, create one */
+		result = create_trash_near (full_name_near, near_device_id, disk_top_directory,
+			permissions, context);
+	}
+
+	if (result != NULL) {
+		/* remember whatever we found for next time */
+		add_cached_trash_entry (near_device_id, result, disk_top_directory);
+	}
+
+	g_free (disk_top_directory);
+
+	return result;
+}
+
+/* Find or create a trash directory on the same disk as @full_name_near. Check
+ * the local and file cache for matching Trash entries first.
+ *
+ *     This is the only entry point for the trash cache code,
+ * we holds the lock while operating on it only here.
+ */
+static char *
+find_trash_directory (const char *full_name_near, dev_t near_device_id, 
+		      gboolean create_if_needed, gboolean find_if_needed,
+		      guint permissions, GnomeVFSContext *context)
+{
+	char *result;
+
+	G_LOCK (cached_trash_directories);
+
+	/* look in the saved trash locations first */
+	result = find_cached_trash_entry_for_device (near_device_id, find_if_needed);
+
+	if (find_if_needed) {
+		if (result != NULL && strcmp (result, NON_EXISTENT_TRASH_ENTRY) == 0 && create_if_needed) {
+			/* We know there is no Trash yet because we remember
+			 * from the last time we looked.
+			 * If we were asked to create one, ignore the fact that
+			 * we already looked for it, look again and create a
+			 * new trash if we find nothing. 
+			 */
+#ifdef DEBUG_FIND_DIRECTORY
+			g_print ("cache indicates no trash for %s, force a creation \n", full_name_near);
+#endif
+			g_free (result);
+			result = NULL;
+		}
+
+		if (result == NULL) {
+			/* No luck sofar. Look for the Trash on the disk, optionally create it
+			 * if we find nothing.
+			 */
+			result = find_or_create_trash_near (full_name_near, near_device_id, 
+				create_if_needed, find_if_needed, permissions, context);
+		}
+	} else if (create_if_needed) {
+		if (result == NULL || strcmp (result, NON_EXISTENT_TRASH_ENTRY) == 0) {
+			result = find_or_create_trash_near (full_name_near, near_device_id, 
+				create_if_needed, find_if_needed, permissions, context);
+		}
+	}
+	
+	if (result != NULL && strcmp(result, NON_EXISTENT_TRASH_ENTRY) == 0) {
+		/* This means that we know there is no Trash */
+		g_free (result);
+		result = NULL;
+	}
+
+	G_UNLOCK (cached_trash_directories);
+	
+	return result;
+}
+
+static GnomeVFSResult
+do_find_directory (GnomeVFSMethod *method,
+		   GnomeVFSURI *near_uri,
+		   GnomeVFSFindDirectoryKind kind,
+		   GnomeVFSURI **result_uri,
+		   gboolean create_if_needed,
+		   gboolean find_if_needed,
+		   guint permissions,
+		   GnomeVFSContext *context)
+{
+	gint retval;
+	char *full_name_near;
+	struct stat near_item_stat;
+	struct stat home_volume_stat;
+	const char *home_directory;
+	char *target_directory_path;
+	char *target_directory_uri;
+
+	
+	target_directory_path = NULL;
+	*result_uri = NULL;
+
+	full_name_near = get_path_from_uri (near_uri);
+	if (full_name_near == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	/* We will need the URI and the stat structure for the home directory. */
+	home_directory = g_get_home_dir ();
+
+	if (gnome_vfs_context_check_cancellation (context)) {
+		g_free (full_name_near);
+		return GNOME_VFS_ERROR_CANCELLED;
+	}
+
+	retval = lstat (full_name_near, &near_item_stat);
+	if (retval != 0) {
+		g_free (full_name_near);
+		return gnome_vfs_result_from_errno ();
+	}
+
+	if (gnome_vfs_context_check_cancellation (context)) {
+		g_free (full_name_near);
+		return GNOME_VFS_ERROR_CANCELLED;
+	}
+	
+	retval = stat (home_directory, &home_volume_stat);
+	if (retval != 0) {
+		g_free (full_name_near);
+		return gnome_vfs_result_from_errno ();
+	}
+	
+	if (gnome_vfs_context_check_cancellation (context)) {
+		g_free (full_name_near);
+		return GNOME_VFS_ERROR_CANCELLED;
+	}
+
+	switch (kind) {
+	case GNOME_VFS_DIRECTORY_KIND_TRASH:
+		/* Use 0700 (S_IRWXU) for the permissions,
+		 * regardless of the requested permissions, so other
+		 * users can't view the trash files.
+		 */
+		permissions = S_IRWXU;	
+		if (near_item_stat.st_dev != home_volume_stat.st_dev) {
+			/* This volume does not contain our home, we have to find/create the Trash
+			 * elsewhere on the volume. Use a heuristic to find a good place.
+			 */
+			FindByDeviceIDParameters tmp;
+			tmp.device_id = near_item_stat.st_dev;
+
+			if (gnome_vfs_context_check_cancellation (context))
+				return GNOME_VFS_ERROR_CANCELLED;
+
+			target_directory_path = find_trash_directory (full_name_near,  
+				near_item_stat.st_dev, create_if_needed, find_if_needed,
+				permissions, context);
+
+			if (gnome_vfs_context_check_cancellation (context)) {
+				return GNOME_VFS_ERROR_CANCELLED;
+			}
+		} else  {
+			/* volume with a home directory, just create a trash in home */
+			target_directory_path = append_to_path (home_directory, TRASH_DIRECTORY_NAME_BASE);
+		}
+		break;
+		
+	case GNOME_VFS_DIRECTORY_KIND_DESKTOP:
+		if (near_item_stat.st_dev != home_volume_stat.st_dev) {
+			/* unsupported */
+			break;
+		}
+		target_directory_path = append_to_path (home_directory, "Desktop");
+		break;
+
+	default:
+		break;
+	}
+
+	g_free (full_name_near);
+
+	if (target_directory_path == NULL) {
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	if (create_if_needed && access (target_directory_path, F_OK) != 0) {
+		mkdir_recursive (target_directory_path, permissions);
+	}
+
+	if (access (target_directory_path, F_OK) != 0) {
+		g_free (target_directory_path);
+		return GNOME_VFS_ERROR_NOT_FOUND;
+	}
+
+	target_directory_uri = gnome_vfs_get_uri_from_local_path (target_directory_path);
+	g_free (target_directory_path);
+	*result_uri = gnome_vfs_uri_new (target_directory_uri);
+	g_free (target_directory_uri);
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+rename_helper (const gchar *old_full_name,
+	       const gchar *new_full_name,
+	       gboolean force_replace,
+	       GnomeVFSContext *context)
+{
+	gboolean old_exists;
+	struct stat statbuf;
+	gint retval;
+	gchar *temp_name;
+	GnomeVFSHandle *temp_handle;
+	GnomeVFSResult result;
+
+	retval = stat (new_full_name, &statbuf);
+	if (retval == 0) {
+		/* Special case for files on case insensitive (vfat) filesystems:
+		 * If the old and the new name only differ by case,
+		 * try renaming via a temp file name.
+		 */
+		if (g_ascii_strcasecmp (old_full_name, new_full_name) == 0
+		    && strcmp (old_full_name, new_full_name) != 0 && ! force_replace) {
+
+			if (gnome_vfs_context_check_cancellation (context))
+				return GNOME_VFS_ERROR_CANCELLED;
+			
+			result = gnome_vfs_create_temp (old_full_name, &temp_name, &temp_handle);
+			if (result != GNOME_VFS_OK)
+				return result;
+			gnome_vfs_close (temp_handle);
+			unlink (temp_name);
+			
+			retval = rename (old_full_name, temp_name);
+			if (retval == 0) {
+				if (stat (new_full_name, &statbuf) != 0 
+				    && rename (temp_name, new_full_name) == 0) {
+					/* Success */
+					return GNOME_VFS_OK;
+				}
+				/* Revert the filename back to original */ 
+				retval = rename (temp_name, old_full_name);
+				if (retval == 0) {
+					return GNOME_VFS_ERROR_FILE_EXISTS;
+				}
+			}
+			return gnome_vfs_result_from_errno_code (retval);
+		
+		} else if (! force_replace) {
+			/* If we are not allowed to replace an existing file, 
+			 * return an error.
+			 */
+			return GNOME_VFS_ERROR_FILE_EXISTS;
+		}
+		old_exists = TRUE;
+	} else {
+		old_exists = FALSE;
+	}
+
+	if (gnome_vfs_context_check_cancellation (context))
+		return GNOME_VFS_ERROR_CANCELLED;
+
+	retval = rename (old_full_name, new_full_name);
+
+	/* FIXME bugzilla.eazel.com 1186: The following assumes that,
+	 * if `new_uri' and `old_uri' are on different file systems,
+	 * `rename()' will always return `EXDEV' instead of `EISDIR',
+	 * even if the old file is not a directory while the new one
+	 * is. If this is not the case, we have to stat() both the
+	 * old and new file.
+	 */
+	if (retval != 0 && errno == EISDIR && force_replace && old_exists) {
+		/* The Unix version of `rename()' fails if the original file is
+		   not a directory, while the new one is.  But we have been
+		   explicitly asked to replace the destination name, so if the
+		   new name points to a directory, we remove it manually.  */
+		if (S_ISDIR (statbuf.st_mode)) {
+			if (gnome_vfs_context_check_cancellation (context))
+				return GNOME_VFS_ERROR_CANCELLED;
+			retval = rmdir (new_full_name);
+			if (retval != 0) {
+				return gnome_vfs_result_from_errno ();
+			}
+
+			if (gnome_vfs_context_check_cancellation (context))
+				return GNOME_VFS_ERROR_CANCELLED;
+
+			retval = rename (old_full_name, new_full_name);
+		}
+	}
+
+	if (retval != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_move (GnomeVFSMethod *method,
+	 GnomeVFSURI *old_uri,
+	 GnomeVFSURI *new_uri,
+	 gboolean force_replace,
+	 GnomeVFSContext *context)
+{
+	gchar *old_full_name;
+	gchar *new_full_name;
+	GnomeVFSResult result;
+
+	old_full_name = get_path_from_uri (old_uri);
+	if (old_full_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	new_full_name = get_path_from_uri (new_uri);
+	if (new_full_name == NULL) {
+		g_free (old_full_name);
+		return GNOME_VFS_ERROR_INVALID_URI;
+	}
+
+	result = rename_helper (old_full_name, new_full_name,
+				force_replace, context);
+
+	g_free (old_full_name);
+	g_free (new_full_name);
+
+	return result;
+}
+
+static GnomeVFSResult
+do_unlink (GnomeVFSMethod *method,
+	   GnomeVFSURI *uri,
+	   GnomeVFSContext *context)
+{
+	gchar *full_name;
+	gint retval;
+
+	full_name = get_path_from_uri (uri);
+	if (full_name == NULL) {
+		return GNOME_VFS_ERROR_INVALID_URI;
+	}
+
+	retval = unlink (full_name);
+
+	g_free (full_name);
+
+	if (retval != 0) {
+		return gnome_vfs_result_from_errno ();
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_create_symbolic_link (GnomeVFSMethod *method,
+			 GnomeVFSURI *uri,
+			 const char *target_reference,
+			 GnomeVFSContext *context)
+{
+	const char *link_scheme, *target_scheme;
+	char *link_full_name, *target_full_name;
+	GnomeVFSResult result;
+	GnomeVFSURI *target_uri;
+
+	g_assert (target_reference != NULL);
+	g_assert (uri != NULL);
+	
+	/* what we actually want is a function that takes a const char * and 
+	 * tells whether it is a valid URI
+	 */
+	target_uri = gnome_vfs_uri_new (target_reference);
+	if (target_uri == NULL) {
+		return GNOME_VFS_ERROR_INVALID_URI;
+	}
+
+	link_scheme = gnome_vfs_uri_get_scheme (uri);
+	g_assert (link_scheme != NULL);
+
+	target_scheme = gnome_vfs_uri_get_scheme (target_uri);
+	if (target_scheme == NULL) {
+		target_scheme = "file";
+	}
+	
+	if ((strcmp (link_scheme, "file") == 0) && (strcmp (target_scheme, "file") == 0)) {
+		/* symlink between two places on the local filesystem */
+		if (strncmp (target_reference, "file", 4) != 0) {
+			/* target_reference wasn't a full URI */
+			target_full_name = strdup (target_reference); 
+		} else {
+			target_full_name = get_path_from_uri (target_uri);
+		}
+
+		link_full_name = get_path_from_uri (uri);
+
+		if (symlink (target_full_name, link_full_name) != 0) {
+			result = gnome_vfs_result_from_errno ();
+		} else {
+			result = GNOME_VFS_OK;
+		}
+
+		g_free (target_full_name);
+		g_free (link_full_name);
+	} else {
+		/* FIXME bugzilla.eazel.com 2792: do a URI link */
+		result = GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	gnome_vfs_uri_unref (target_uri);
+
+	return result;
+}
+
+/* When checking whether two locations are on the same file system, we are
+   doing this to determine whether we can recursively move or do other
+   sorts of transfers.  When a symbolic link is the "source", its
+   location is the location of the link file, because we want to
+   know about transferring the link, whereas for symbolic links that
+   are "targets", we use the location of the object being pointed to,
+   because that is where we will be moving/copying to. */
+static GnomeVFSResult
+do_check_same_fs (GnomeVFSMethod *method,
+		  GnomeVFSURI *source_uri,
+		  GnomeVFSURI *target_uri,
+		  gboolean *same_fs_return,
+		  GnomeVFSContext *context)
+{
+	gchar *full_name_source, *full_name_target;
+	struct stat s_source, s_target;
+	gint retval;
+
+	full_name_source = get_path_from_uri (source_uri);
+	retval = lstat (full_name_source, &s_source);
+	g_free (full_name_source);
+
+	if (retval != 0)
+		return gnome_vfs_result_from_errno ();
+
+	if (gnome_vfs_context_check_cancellation (context))
+		return GNOME_VFS_ERROR_CANCELLED;
+ 
+	full_name_target = get_path_from_uri (target_uri);
+	retval = stat (full_name_target, &s_target);
+	g_free (full_name_target);
+
+	if (retval != 0)
+		return gnome_vfs_result_from_errno ();
+
+	*same_fs_return = (s_source.st_dev == s_target.st_dev);
+
+	return GNOME_VFS_OK;
+}
+
+static GnomeVFSResult
+do_set_file_info (GnomeVFSMethod *method,
+		  GnomeVFSURI *uri,
+		  const GnomeVFSFileInfo *info,
+		  GnomeVFSSetFileInfoMask mask,
+		  GnomeVFSContext *context)
+{
+	gchar *full_name;
+
+	full_name = get_path_from_uri (uri);
+	if (full_name == NULL)
+		return GNOME_VFS_ERROR_INVALID_URI;
+
+	if (mask & GNOME_VFS_SET_FILE_INFO_NAME) {
+		GnomeVFSResult result;
+		gchar *dir, *encoded_dir;
+		gchar *new_name;
+
+		encoded_dir = gnome_vfs_uri_extract_dirname (uri);
+		dir = gnome_vfs_unescape_string (encoded_dir, G_DIR_SEPARATOR_S);
+		g_free (encoded_dir);
+		g_assert (dir != NULL);
+
+		/* FIXME bugzilla.eazel.com 645: This needs to return
+		 * an error for incoming names with "/" characters in
+		 * them, instead of moving the file.
+		 */
+
+		if (dir[strlen(dir) - 1] != '/') {
+			new_name = g_strconcat (dir, "/", info->name, NULL);
+		} else {
+			new_name = g_strconcat (dir, info->name, NULL);
+		}
+
+		result = rename_helper (full_name, new_name, FALSE, context);
+
+		g_free (dir);
+		g_free (new_name);
+
+		if (result != GNOME_VFS_OK) {
+			g_free (full_name);
+			return result;
+		}
+	}
+
+	if (gnome_vfs_context_check_cancellation (context)) {
+		g_free (full_name);
+		return GNOME_VFS_ERROR_CANCELLED;
+	}
+
+	if (mask & GNOME_VFS_SET_FILE_INFO_PERMISSIONS) {
+		if (chmod (full_name, info->permissions) != 0) {
+			g_free (full_name);
+			return gnome_vfs_result_from_errno ();
+		}
+	}
+
+	if (gnome_vfs_context_check_cancellation (context)) {
+		g_free (full_name);
+		return GNOME_VFS_ERROR_CANCELLED;
+	}
+
+	if (mask & GNOME_VFS_SET_FILE_INFO_OWNER) {
+		if (chown (full_name, info->uid, info->gid) != 0) {
+			g_free (full_name);
+			return gnome_vfs_result_from_errno ();
+		}
+	}
+
+	if (gnome_vfs_context_check_cancellation (context)) {
+		g_free (full_name);
+		return GNOME_VFS_ERROR_CANCELLED;
+	}
+
+	if (mask & GNOME_VFS_SET_FILE_INFO_TIME) {
+		struct utimbuf utimbuf;
+
+		utimbuf.actime = info->atime;
+		utimbuf.modtime = info->mtime;
+
+		if (utime (full_name, &utimbuf) != 0) {
+			g_free (full_name);
+			return gnome_vfs_result_from_errno ();
+		}
+	}
+
+	g_free (full_name);
+
+	return GNOME_VFS_OK;
+}
+
+#ifdef HAVE_FAM
+static gboolean
+fam_do_iter_unlocked (void)
+{
+	while (fam_connection != NULL && FAMPending(fam_connection)) {
+		FAMEvent ev;
+		FileMonitorHandle *handle;
+		gboolean cancelled;
+		GnomeVFSMonitorEventType event_type;
+
+		if (FAMNextEvent(fam_connection, &ev) != 1) {
+			FAMClose(fam_connection);
+			g_free(fam_connection);
+			g_source_remove (fam_watch_id);
+			fam_watch_id = 0;
+			fam_connection = NULL;
+			return FALSE;
+		}
+
+		handle = (FileMonitorHandle *)ev.userdata;
+		cancelled = handle->cancelled;
+		event_type = -1;
+
+		switch (ev.code) {
+			case FAMChanged:
+				event_type = GNOME_VFS_MONITOR_EVENT_CHANGED;
+				break;
+			case FAMDeleted:
+				event_type = GNOME_VFS_MONITOR_EVENT_DELETED;
+				break;
+			case FAMStartExecuting:
+				event_type = GNOME_VFS_MONITOR_EVENT_STARTEXECUTING;
+				break;
+			case FAMStopExecuting:
+				event_type = GNOME_VFS_MONITOR_EVENT_STOPEXECUTING;
+				break;
+			case FAMCreated:
+				event_type = GNOME_VFS_MONITOR_EVENT_CREATED;
+				break;
+			case FAMAcknowledge:
+				if (handle->cancelled) {
+					gnome_vfs_uri_unref (handle->uri);
+					g_free (handle);
+				}
+				break;
+			case FAMExists:
+			case FAMEndExist:
+			case FAMMoved:
+				/* Not supported */
+				break;
+		}
+
+		if (event_type != -1 && !cancelled) {
+			GnomeVFSURI *info_uri;
+			gchar *info_str;
+
+			/* 
+			 * FAM can send events with either a absolute or
+			 * relative (from the monitored URI) path, so check if
+			 * the filename starts with '/'.  
+			 */
+			if (ev.filename[0] == '/') {
+				info_str = gnome_vfs_get_uri_from_local_path (ev.filename);
+				info_uri = gnome_vfs_uri_new (info_str);
+				g_free (info_str);
+			} else
+				info_uri = gnome_vfs_uri_append_file_name (handle->uri, ev.filename);
+
+			/* This queues an idle, so there are no reentrancy issues */
+			gnome_vfs_monitor_callback ((GnomeVFSMethodHandle *)handle,
+						    info_uri, 
+						    event_type);
+			gnome_vfs_uri_unref (info_uri);
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+fam_callback (GIOChannel *source,
+	      GIOCondition condition,
+	      gpointer data)
+{
+	gboolean res;
+	G_LOCK (fam_connection);
+
+	res = fam_do_iter_unlocked ();
+
+	G_UNLOCK (fam_connection);
+
+	return res;
+}
+
+
+
+static gboolean
+monitor_setup (void)
+{
+	GIOChannel *ioc;
+
+	G_LOCK (fam_connection);
+
+	if (fam_connection == NULL) {
+		fam_connection = g_malloc0(sizeof(FAMConnection));
+		if (FAMOpen2(fam_connection, "gnome-vfs user") != 0) {
+#ifdef DEBUG_FAM
+			g_print ("FAMOpen failed, FAMErrno=%d\n", FAMErrno);
+#endif
+			g_free(fam_connection);
+			fam_connection = NULL;
+			G_UNLOCK (fam_connection);
+			return FALSE;
+		}
+		ioc = g_io_channel_unix_new (FAMCONNECTION_GETFD(fam_connection));
+		fam_watch_id = g_io_add_watch (ioc,
+					       G_IO_IN | G_IO_HUP | G_IO_ERR,
+					       fam_callback, fam_connection);
+		g_io_channel_unref (ioc);
+	}
+
+	G_UNLOCK (fam_connection);
+
+	return TRUE;
+}
+#endif
+
+static GnomeVFSResult
+do_monitor_add (GnomeVFSMethod *method,
+		GnomeVFSMethodHandle **method_handle_return,
+		GnomeVFSURI *uri,
+		GnomeVFSMonitorType monitor_type)
+{
+#ifdef HAVE_FAM
+	FileMonitorHandle *handle;
+	char *filename;
+
+	if (!monitor_setup ()) {
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	filename = get_path_from_uri (uri);
+	if (filename == NULL) {
+		return GNOME_VFS_ERROR_INVALID_URI;
+	}
+	
+	handle = g_new0 (FileMonitorHandle, 1);
+	handle->uri = uri;
+	handle->cancelled = FALSE;
+	gnome_vfs_uri_ref (uri);
+
+	G_LOCK (fam_connection);
+	/* We need to queue up incoming messages to avoid blocking on write
+	   if there are many monitors being added */
+	fam_do_iter_unlocked ();
+
+	if (fam_connection == NULL) {
+		G_UNLOCK (fam_connection);
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+	
+	if (monitor_type == GNOME_VFS_MONITOR_FILE) {
+		FAMMonitorFile (fam_connection, filename, 
+			&handle->request, handle);
+	} else {
+		FAMMonitorDirectory (fam_connection, filename, 
+			&handle->request, handle);
+	}
+
+	G_UNLOCK (fam_connection);
+	
+	*method_handle_return = (GnomeVFSMethodHandle *)handle;
+
+	g_free (filename);
+
+	return GNOME_VFS_OK;
+#else
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif
+}
+
+static GnomeVFSResult
+do_monitor_cancel (GnomeVFSMethod *method,
+		   GnomeVFSMethodHandle *method_handle)
+{
+#ifdef HAVE_FAM
+	FileMonitorHandle *handle = (FileMonitorHandle *)method_handle;
+
+	if (!monitor_setup ()) {
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+
+	if (handle->cancelled)
+		return GNOME_VFS_OK;
+
+	handle->cancelled = TRUE;
+	G_LOCK (fam_connection);
+
+	/* We need to queue up incoming messages to avoid blocking on write
+	   if there are many monitors being canceled */
+	fam_do_iter_unlocked ();
+
+	if (fam_connection == NULL) {
+		G_UNLOCK (fam_connection);
+		return GNOME_VFS_ERROR_NOT_SUPPORTED;
+	}
+	
+	FAMCancelMonitor (fam_connection, &handle->request);
+	G_UNLOCK (fam_connection);
+
+	return GNOME_VFS_OK;
+#else
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif
+}
+
+static GnomeVFSResult
+do_file_control (GnomeVFSMethod *method,
+		 GnomeVFSMethodHandle *method_handle,
+		 const char *operation,
+		 gpointer operation_data,
+		 GnomeVFSContext *context)
+{
+	if (strcmp (operation, "file:test") == 0) {
+		*(char **)operation_data = g_strdup ("test ok");
+		return GNOME_VFS_OK;
+	}
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+}
+
+static GnomeVFSMethod method = {
+	sizeof (GnomeVFSMethod),
+	do_open,
+	do_create,
+	do_close,
+	do_read,
+	do_write,
+	do_seek,
+	do_tell,
+	do_truncate_handle,
+	do_open_directory,
+	do_close_directory,
+	do_read_directory,
+	do_get_file_info,
+	do_get_file_info_from_handle,
+	do_is_local,
+	do_make_directory,
+	do_remove_directory,
+	do_move,
+	do_unlink,
+	do_check_same_fs,
+	do_set_file_info,
+	do_truncate,
+	do_find_directory,
+	do_create_symbolic_link,
+	do_monitor_add,
+	do_monitor_cancel,
+	do_file_control
+};
+
+GnomeVFSMethod *
+vfs_module_init (const char *method_name, const char *args)
+{
+	return &method;
+}
+
+void
+vfs_module_shutdown (GnomeVFSMethod *method)
+{
+}
diff -Naur gnome-vfs-2.8.1-old/modules/pty-open.c gnome-vfs-2.8.1/modules/pty-open.c
--- gnome-vfs-2.8.1-old/modules/pty-open.c	Wed Aug 25 09:50:03 2004
+++ gnome-vfs-2.8.1/modules/pty-open.c	Wed Oct  6 10:53:01 2004
@@ -554,51 +554,6 @@
 static char *
 _gnome_vfs_pty_ptsname(int master)
 {
-#if defined(HAVE_PTSNAME_R)
-	gsize len = 1024;
-	char *buf = NULL;
-	int i;
-	do {
-		buf = g_malloc0(len);
-		i = ptsname_r(master, buf, len - 1);
-		switch (i) {
-		case 0:
-			/* Return the allocated buffer with the name in it. */
-#ifdef GNOME_VFS_DEBUG
-			if (_gnome_vfs_debug_on(GNOME_VFS_DEBUG_PTY)) {
-				fprintf(stderr, "PTY slave is `%s'.\n", buf);
-			}
-#endif
-			return buf;
-			break;
-		default:
-			g_free(buf);
-			buf = NULL;
-			break;
-		}
-		len *= 2;
-	} while ((i != 0) && (errno == ERANGE));
-#elif defined(HAVE_PTSNAME)
-	char *p;
-	if ((p = ptsname(master)) != NULL) {
-#ifdef GNOME_VFS_DEBUG
-		if (_gnome_vfs_debug_on(GNOME_VFS_DEBUG_PTY)) {
-			fprintf(stderr, "PTY slave is `%s'.\n", p);
-		}
-#endif
-		return g_strdup(p);
-	}
-#elif defined(TIOCGPTN)
-	int pty = 0;
-	if (ioctl(master, TIOCGPTN, &pty) == 0) {
-#ifdef GNOME_VFS_DEBUG
-		if (_gnome_vfs_debug_on(GNOME_VFS_DEBUG_PTY)) {
-			fprintf(stderr, "PTY slave is `/dev/pts/%d'.\n", pty);
-		}
-#endif
-		return g_strdup_printf("/dev/pts/%d", pty);
-	}
-#endif
 	return NULL;
 }
 
@@ -606,18 +561,13 @@
 _gnome_vfs_pty_getpt(void)
 {
 	int fd, flags;
-#ifdef HAVE_GETPT
-	/* Call the system's function for allocating a pty. */
-	fd = getpt();
-#elif defined(HAVE_POSIX_OPENPT)
-	fd = posix_openpt(O_RDWR | O_NOCTTY);
-#else
-	/* Try to allocate a pty by accessing the pty master multiplex. */
-	fd = open("/dev/ptmx", O_RDWR | O_NOCTTY);
-	if ((fd == -1) && (errno == ENOENT)) {
-		fd = open("/dev/ptc", O_RDWR | O_NOCTTY); /* AIX */
-	}
-#endif
+
+        /* Try to allocate a pty by accessing the pty master multiplex. */
+        fd = open("/dev/ptmx", O_RDWR | O_NOCTTY);
+        if ((fd == -1) && (errno == ENOENT)) {
+                fd = open("/dev/ptc", O_RDWR | O_NOCTTY); /* AIX */
+        }
+
 	/* Set it to blocking. */
 	flags = fcntl(fd, F_GETFL);
 	flags &= ~(O_NONBLOCK);
@@ -628,24 +578,13 @@
 static int
 _gnome_vfs_pty_grantpt(int master)
 {
-#ifdef HAVE_GRANTPT
-	return grantpt(master);
-#else
 	return 0;
-#endif
 }
 
 static int
 _gnome_vfs_pty_unlockpt(int fd)
 {
-#ifdef HAVE_UNLOCKPT
-	return unlockpt(fd);
-#elif defined(TIOCSPTLCK)
-	int zero = 0;
-	return ioctl(fd, TIOCSPTLCK, &zero);
-#else
 	return -1;
-#endif
 }
 
 static int

diff -ruN blootbot.orig/etc/directories blootbot/etc/directories
--- blootbot.orig/etc/directories	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/etc/directories	2002-11-08 20:33:43.000000000 -0700
@@ -0,0 +1,5 @@
+$bot_state_dir = '@FINKPREFIX@/var/lib/blootbot';
+$bot_data_dir  = '@FINKPREFIX@/share/blootbot/data';
+$bot_src_dir   = '@FINKPREFIX@/share/blootbot/src';
+$bot_log_dir   = '@FINKPREFIX@/var/log/blootbot';
+$bot_run_dir   = '@FINKPREFIX@/var/run/blootbot';
diff -ruN blootbot.orig/etc/template.config blootbot/etc/template.config
--- blootbot.orig/etc/template.config	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/etc/template.config	2002-11-08 20:56:24.000000000 -0700
@@ -0,0 +1,228 @@
+# parameter settings file for the infobot
+# kevin lenzo (lenzo@cs.cmu.edu)
+# modified by xk <xk@leguin.openprojects.net>
+###
+
+#AUTO - delete this line to stop debconf from changing things in this file
+
+# [str] Interface: [IRC/CLI]
+set Interface		IRC
+
+# IRC.
+set ircNick		blootbot
+set ircUser		blootbot
+set ircName		blootbot
+set ircUMode		+iw
+###set ircHost		vh.virtualhost.org
+
+set owner		asuffield
+
+# nickserv/chanserv support.
+set nickServ_pass	none
+
+# default quit message
+set quitMsg		Edit the config file!!!
+
+# temp directory.
+set tempDir		/tmp/blootbot
+
+# username to run as
+set runAsUser		blootbot
+
+#####
+# logfile
+#####
+
+# [file] where to put logging info. comment out to disable.
+set logfile		@FINKPREFIX@/var/log/blootbot/$ircUser.log
+
+# [str] Type of logging.
+#   DAILY	-- Create a new log each day.
+#   DEFAULT	-- One continuous log file.
+set logType		DAILY
+
+# [int] Maximum log size, if logfile is defined, in bytes.
+set maxLogSize		10000000
+
+#####
+# Factoid DB Configuration
+#####
+
+# [str] Ability to remember/tell factoids
+#	none	-- disable.
+#	mysql	-- ...
+#	pgsql	-- postgresql (NOT SUPPORTED)
+#	dbm	-- berkeley dbm (SHOULD WORK 95%)
+set DBType		mysql
+
+# [str] DBM filename prefix // MYSQL/PGSQL database.
+#	eg: blootbot-factoids, blootbot-seen
+#	eg: /var/db/mysql/blootbot/factoids.*
+set DBName		blootbot
+
+# [str] Hostname of database server
+set SQLHost		localhost
+
+# [str] mysql user allowed to insert,update,delete stuff from tables.
+set SQLUser		blootbot
+
+# [str] mysql password.
+set SQLPass		bl00tb0t
+
+# [str] sql debug file.
+###set SQLDebug		SQL_debug.log
+
+#####
+# factoid-related configuration
+#####
+
+# [bool] Factoid support.
+set factoids		true
+
+# [days] After what time will deleted factoids will be deleted.
+set factoidDeleteDelay	30
+
+# [int] maximum length of factoid key.
+set maxKeySize		32
+
+# [int] maximum length of factoid value.
+set maxDataSize		450
+
+# [int] minimum length of unaddressed (message) question without question
+#	before it is answered involuntarily.
+#	This ignores the 'addressing' setting.
+#	0 to disable.
+set minVolunteerLength	0
+
+# [str] when should the bot bother learning new factoids.
+#   ADDRESSED	-- only learn when addressed.
+#   HUNGRY	-- learn irrelevent of addressing. this will catch
+#		   _everything_, use at your own risk. I tried this ages
+#		   ago and it caught quite funny responses but who knows
+#		   if my modifications will prevent this or not, perhaps
+#		   IsInvalid must be disabled?
+set learn		ADDRESSED
+
+# [str] different behaviour with URLs.
+#   REQUIRE	-- means it will need to be a url type (e.g. file:, http:)
+#   OPTIONAL	-- will take anything
+#   REJECT	-- will not accept any urls.  this makes it easy to
+#		   run 2 with different nicks and styles.
+#		   ^^^ what's the point of this???
+set acceptUrl		OPTIONAL
+
+# [bool] profanity checking.
+set profanityCheck	false
+
+# [str] other bots to ask for factoids which they may have.
+#set friendlyBots	none
+
+set allowTelling true
+set allowConv true
+
+#####
+# factoid related and unrelated features, mainly Extras.
+#####
+
+# [str] addressing is when you name the bot. FIXME
+#   REQUIRE	-- the bot only does something if addressed.
+#   OPTIONAL	-- the bot responds (does not learn) irrelevent of
+#		   addressing.
+set addressing		REQUIRE
+
+# should work. FIXME.
+#set addressCharacter	~
+
+# [str] how the bot should send messages.
+#   PRIVATE	-- reply to private messages only, rejecting public msgs.
+#   DEFAULT	-- reply to public _and_ private queries.
+set talkMethod		DEFAULT
+
+# [str] how long the output string should be before it is changed from
+#	public to private.
+#	"+" before bot commands overrides this option temporarily.
+###set minLengthBeforePrivate 192
+
+# [int] maximum length of reply for Extras function before popping list to
+#	reduce number of elements.
+set maxListReplyLength	450
+
+# [int] maximum number of elements in list allowed for Extras function
+#	before popping elements to reduce total count.
+set maxListReplyCount	15
+
+# [0/1] allow people outside any channels the bot is on to use the bot
+#	for factoids and commands.
+set disallowOutsiders	1
+
+# [int] time, in seconds. (different messages)
+set floodMessages	10:30
+# [int] same messages.
+set floodRepeat		2:10
+
+# [int] Amount of time for auto-ignore (flooding) to expire.
+set ignoreAutoExpire	5
+
+# [int] Amount of time for forced-online ignore to expire. minutes.
+set ignoreTempExpire	60
+
+#####
+# Internal (simple) bot commands
+#####
+
+# [0/1] irc-cli calculator.
+set perlMath		1
+
+# [0/1] ord/chr etc
+set allowConv		1
+
+# [0/1] do you want to allow DNS lookup
+set allowDNS		1
+
+# [0/1] Forking... disable for non-nix OS or to reduce mem usage.
+#	Disabling should make the bot work on Win32 and MacOS.
+set forking		1
+
+# [int] Backlog... ideal to see what happened to the bot on console.
+#	maximum number of lines to backlog.
+set backlog		24
+
+#####
+# Miscellaneous...
+#####
+
+# [int] Display a bit too much info about stuff.
+#   0	-- disable.
+#   1	-- standard.
+#   2	-- extra.
+set VERBOSITY		1
+
+# [0/1] Warn messages.
+set WARN		1
+
+# [0/1] Debugging messages.
+set DEBUG		1
+
+# [0/1] Work In Progress...
+set WIP			0
+
+# debugging...
+###set dumpvars		1
+###set dumpvarsAtExit	1
+# log to specific file or global log file.
+###set dumpvarsLogFile	dumpvars.log
+
+# [0/1] allow 'use strict', makes bot unreliable.
+set useStrict		0
+
+#####
+# Extras
+#####
+
+# [str] anything which requires LWP + http proxy.
+##set httpProxy http://router.home.org:3128/
+
+####
+#### now modify blootbot.chans for per-channel specific configuration
+#### see sample.chans for info.
+####
diff -ruN blootbot.orig/files/ircII.servers blootbot/files/ircII.servers
--- blootbot.orig/files/ircII.servers	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/files/ircII.servers	2002-11-08 12:54:14.000000000 -0700
@@ -0,0 +1,7 @@
+###
+### ircII.servers
+###
+
+irc.home.org
+irc.linux.com
+irc.openprojects.net
diff -ruN blootbot.orig/files/template.chan blootbot/files/template.chan
--- blootbot.orig/files/template.chan	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/files/template.chan	2002-11-08 12:53:57.000000000 -0700
@@ -0,0 +1,43 @@
+#v1: blootbot -- pkgtool -- written Tue Feb 27 13:46:17 2001
+
+#debian-bots
+    +autojoin
+    +joinfloodCheck
+
+_default
+    +allowConv
+    +allowDNS
+    +cookie
+    +countdown
+    +debian
+    +debianExtra
+    debianRefreshInterval 7
+    +dict
+    floodMessages 10:30
+    floodRepeat 2:10
+    +freshmeat
+    freshmeatRefreshInterval 24
+    +karma
+    +kernel
+    +lart
+    +limitcheck
+    +log
+    +nickometer
+    +perlMath
+    +quote
+    +rootWarn
+    rootWarnMode passive
+    +search
+    +seen
+    seenFlushInterval 60
+    seenMaxDays 90
+    +seenStats
+    +slashdot
+    +spell
+    +tell
+    +topic
+    +units
+    +uptime
+    +userinfo
+    +wwwsearch
+
diff -ruN blootbot.orig/files/template.config blootbot/files/template.config
--- blootbot.orig/files/template.config	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/files/template.config	2002-11-08 12:53:57.000000000 -0700
@@ -0,0 +1,209 @@
+# parameter settings file for the infobot
+# kevin lenzo (lenzo@cs.cmu.edu)
+# modified by xk <xk@leguin.openprojects.net>
+###
+
+# [str] Interface: [IRC/CLI]
+set Interface		IRC
+
+# IRC.
+set ircNick		blootbot
+set ircUser		blootbot
+set ircName		blootbot
+set ircUMode		+iw
+###set ircHost		vh.virtualhost.org
+
+set owner		asuffield
+
+# nickserv/chanserv support.
+set nickServ_pass	none
+
+# default quit message
+set quitMsg		Edit the config file!!!
+
+# temp directory.
+set tempDir		/tmp/blootbot
+
+#####
+# logfile
+#####
+
+# [file] where to put logging info. comment out to disable.
+set logfile		log/$ircUser.log
+
+# [str] Type of logging.
+#   DAILY	-- Create a new log each day.
+#   DEFAULT	-- One continuous log file.
+set logType		DAILY
+
+# [int] Maximum log size, if logfile is defined, in bytes.
+set maxLogSize		10000000
+
+#####
+# Factoid DB Configuration
+#####
+
+# [str] Ability to remember/tell factoids
+#	none	-- disable.
+#	mysql	-- ...
+#	pgsql	-- postgresql (NOT SUPPORTED)
+#	dbm	-- berkeley dbm (SHOULD WORK 95%)
+set DBType		mysql
+
+# [str] DBM filename prefix // MYSQL/PGSQL database.
+#	eg: blootbot-factoids, blootbot-seen
+#	eg: /var/db/mysql/blootbot/factoids.*
+set DBName		blootbot
+
+# [str] Hostname of database server
+set SQLHost		localhost
+
+# [str] mysql user allowed to insert,update,delete stuff from tables.
+set SQLUser		blootbot
+
+# [str] mysql password.
+set SQLPass		xyzzy
+
+# [str] sql debug file.
+###set SQLDebug		SQL_debug.log
+
+#####
+# factoid-related configuration
+#####
+
+# [bool] Factoid support.
+set factoids		true
+
+# [days] After what time will deleted factoids will be deleted.
+set factoidDeleteDelay	30
+
+# [int] maximum length of factoid key.
+set maxKeySize		32
+
+# [int] maximum length of factoid value.
+set maxDataSize		450
+
+# [int] minimum length of unaddressed (message) question without question
+#	before it is answered involuntarily.
+#	This ignores the 'addressing' setting.
+#	0 to disable.
+set minVolunteerLength	0
+
+# [str] when should the bot bother learning new factoids.
+#   ADDRESSED	-- only learn when addressed.
+#   HUNGRY	-- learn irrelevent of addressing. this will catch
+#		   _everything_, use at your own risk. I tried this ages
+#		   ago and it caught quite funny responses but who knows
+#		   if my modifications will prevent this or not, perhaps
+#		   IsInvalid must be disabled?
+set learn		ADDRESSED
+
+# [str] different behaviour with URLs.
+#   REQUIRE	-- means it will need to be a url type (e.g. file:, http:)
+#   OPTIONAL	-- will take anything
+#   REJECT	-- will not accept any urls.  this makes it easy to
+#		   run 2 with different nicks and styles.
+#		   ^^^ what's the point of this???
+set acceptUrl		OPTIONAL
+
+# [bool] profanity checking.
+set profanityCheck	false
+
+# [str] other bots to ask for factoids which they may have.
+#set friendlyBots	none
+
+set allowTelling true
+set allowConv true
+
+#####
+# factoid related and unrelated features, mainly Extras.
+#####
+
+# [str] addressing is when you name the bot. FIXME
+#   REQUIRE	-- the bot only does something if addressed.
+#   OPTIONAL	-- the bot responds (does not learn) irrelevent of
+#		   addressing.
+set addressing		REQUIRE
+
+# should work. FIXME.
+#set addressCharacter	~
+
+# [str] how the bot should send messages.
+#   PRIVATE	-- reply to private messages only, rejecting public msgs.
+#   DEFAULT	-- reply to public _and_ private queries.
+set talkMethod		DEFAULT
+
+# [str] how long the output string should be before it is changed from
+#	public to private.
+#	"+" before bot commands overrides this option temporarily.
+###set minLengthBeforePrivate 192
+
+# [int] maximum length of reply for Extras function before popping list to
+#	reduce number of elements.
+set maxListReplyLength	300
+
+# [int] maximum number of elements in list allowed for Extras function
+#	before popping elements to reduce total count.
+set maxListReplyCount	15
+
+# [0/1] allow people outside any channels the bot is on to use the bot
+#	for factoids and commands.
+set disallowOutsiders	1
+
+# [int] Amount of time for auto-ignore (flooding) to expire.
+set ignoreAutoExpire	5
+
+# [int] Amount of time for forced-online ignore to expire. minutes.
+set ignoreTempExpire	60
+
+#####
+# Internal (simple) bot commands
+#####
+
+# [0/1] Forking... disable for non-nix OS or to reduce mem usage.
+#	Disabling should make the bot work on Win32 and MacOS.
+set forking		1
+
+# [int] Backlog... ideal to see what happened to the bot on console.
+#	maximum number of lines to backlog.
+set backlog		24
+
+#####
+# Miscellaneous...
+#####
+
+# [int] Display a bit too much info about stuff.
+#   0	-- disable.
+#   1	-- standard.
+#   2	-- extra.
+set VERBOSITY		1
+
+# [0/1] Warn messages.
+set WARN		1
+
+# [0/1] Debugging messages.
+set DEBUG		1
+
+# [0/1] Work In Progress...
+set WIP			0
+
+# debugging...
+###set dumpvars		1
+###set dumpvarsAtExit	1
+# log to specific file or global log file.
+###set dumpvarsLogFile	dumpvars.log
+
+# [0/1] allow 'use strict', makes bot unreliable.
+set useStrict		0
+
+#####
+# Extras
+#####
+
+# [str] anything which requires LWP + http proxy.
+set httpProxy http://router.home.org:3128/
+
+####
+#### now modify blootbot.chans for per-channel specific configuration
+#### see sample.chans for info.
+####
diff -ruN blootbot.orig/files/template.servers blootbot/files/template.servers
--- blootbot.orig/files/template.servers	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/files/template.servers	2002-11-08 12:53:57.000000000 -0700
@@ -0,0 +1,5 @@
+###
+### ircII.servers
+###
+
+irc.openprojects.net
diff -ruN blootbot.orig/files/template.users blootbot/files/template.users
--- blootbot.orig/files/template.users	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/files/template.users	2002-11-08 12:53:57.000000000 -0700
@@ -0,0 +1,11 @@
+#v1: blootbot -- pkgtool -- written Tue Feb 27 13:46:17 2001
+
+_default
+--FLAGS		+mrt
+--HOSTS		*!*@*
+
+asuffield
+--FLAGS		+mrsteon
+--HOSTS		*!*@*
+--PASS		FEnMsplZ88AAA
+
diff -ruN blootbot.orig/src/CommandStubs.pl blootbot/src/CommandStubs.pl
--- blootbot.orig/src/CommandStubs.pl	2002-05-13 08:11:22.000000000 -0600
+++ blootbot/src/CommandStubs.pl	2002-11-08 21:48:31.000000000 -0700
@@ -155,25 +155,25 @@
 &addCmdHook("extra", 'd?bugs', ('CODEREF' => 'DBugs::Parse',
 	'Forker' => 1, 'Identifier' => 'debianExtra',
 	'Cmdstats' => 'Debian Bugs') );
-&addCmdHook("extra", 'dauthor', ('CODEREF' => 'Debian::searchAuthor',
-	'Forker' => 1, 'Identifier' => 'debian',
-	'Cmdstats' => 'Debian Author Search', 'Help' => "dauthor" ) );
-&addCmdHook("extra", '(d|search)desc', ('CODEREF' => 'Debian::searchDescFE',
-	'Forker' => 1, 'Identifier' => 'debian',
-	'Cmdstats' => 'Debian Desc Search', 'Help' => "ddesc" ) );
-&addCmdHook("extra", 'dnew', ('CODEREF' => 'DebianNew',
-	'Identifier' => 'debian' ) );
-&addCmdHook("extra", 'dincoming', ('CODEREF' => 'Debian::generateIncoming',
-	'Forker' => 1, 'Identifier' => 'debian' ) );
-&addCmdHook("extra", 'dstats', ('CODEREF' => 'Debian::infoStats',
-	'Forker' => 1, 'Identifier' => 'debian',
-	'Cmdstats' => 'Debian Statistics' ) );
-&addCmdHook("extra", 'd?contents', ('CODEREF' => 'Debian::searchContents',
-	'Forker' => 1, 'Identifier' => 'debian',
-	'Cmdstats' => 'Debian Contents Search', 'Help' => "contents" ) );
-&addCmdHook("extra", 'd?find', ('CODEREF' => 'Debian::DebianFind',
-	'Forker' => 1, 'Identifier' => 'debian',
-	'Cmdstats' => 'Debian Search', 'Help' => "find" ) );
+&addCmdHook("extra", 'fauthor', ('CODEREF' => 'Fink::searchAuthor',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Author Search', 'Help' => "dauthor" ) );
+&addCmdHook("extra", '(f|search)desc', ('CODEREF' => 'Fink::searchDescFE',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Desc Search', 'Help' => "ddesc" ) );
+&addCmdHook("extra", 'fnew', ('CODEREF' => 'FinkNew',
+        'Identifier' => 'fink' ) );
+&addCmdHook("extra", 'fincoming', ('CODEREF' => 'Fink::generateIncoming',
+        'Forker' => 1, 'Identifier' => 'fink' ) );
+&addCmdHook("extra", 'fstats', ('CODEREF' => 'Fink::infoStats',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Statistics' ) );
+&addCmdHook("extra", 'f?contents', ('CODEREF' => 'Fink::searchContents',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Contents Search', 'Help' => "contents" ) );
+&addCmdHook("extra", 'f?find', ('CODEREF' => 'Fink::FinkFind',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Search', 'Help' => "find" ) );
 &addCmdHook("extra", 'insult', ('CODEREF' => 'Insult::Insult',
 	'Forker' => 1, 'Identifier' => 'insult', 'Help' => "insult" ) );
 &addCmdHook("extra", 'kernel', ('CODEREF' => 'Kernel::Kernel',
@@ -249,15 +249,15 @@
 	return;
     }
 
-    my $debiancmd	 = 'conflicts?|depends?|desc|file|info|provides?';
-    $debiancmd		.= '|recommends?|suggests?|maint|maintainer';
+    my $finkcmd	 = 'conflicts?|depends?|desc|file|info|provides?';
+    $finkcmd		.= '|recommends?|suggests?|maint|maintainer';
 
-    if ($message =~ /^($debiancmd)(\s+(.*))?$/i) {
-	return unless (&hasParam("debian"));
+    if ($message =~ /^($finkcmd)(\s+(.*))?$/i) {
+	return unless (&hasParam("fink"));
 	my $package = lc $3;
 
 	if (defined $package) {
-	    &Forker("debian", sub { &Debian::infoPackages($1, $package); } );
+	    &Forker("fink", sub { &Fink::infoPackages($1, $package); } );
 	} else {
 	    &help($1);
 	}
@@ -747,8 +747,8 @@
     }
 }
 
-sub DebianNew {
-    my $idx   = "debian/Packages-woody.idx";
+sub FinkNew {
+    my $idx   = "fink/Packages-unstable.idx";
     my $error = 0;
     my %pkg;
     my @new;
@@ -757,8 +757,8 @@
     $error++ unless ( -e "$idx-old");
 
     if ($error) {
-	$error = "no woody/woody-old index file found.";
-	&ERROR("Debian: $error");
+	$error = "no unstable/unstable-old index file found.";
+	&ERROR("Fink: $error");
 	&msg($who, $error);
 	return;
     }
@@ -784,7 +784,7 @@
     }
     close IDX1;
 
-    &::pSReply( &::formListReply(0, "New debian packages:", @new) );
+    &::pSReply( &::formListReply(0, "New fink packages:", @new) );
 }
 
 sub do_verstats {
diff -ruN blootbot.orig/src/Factoids/Question.pl blootbot/src/Factoids/Question.pl
--- blootbot.orig/src/Factoids/Question.pl	2001-10-06 07:00:05.000000000 -0600
+++ blootbot/src/Factoids/Question.pl	2002-11-08 21:49:16.000000000 -0700
@@ -145,6 +145,15 @@
 ###	return $result if (defined $result);
     }
 
+    ### TODO: Use &Forker(); move function to Fink.pl
+    if (&IsChanConf("finkForFactoid")) {
+        &loadMyModule($myModules{'fink'});
+        $result = &Fink::FinkFind($query);  # ???
+        ### TODO: fink module should tell, through shm, that it went
+        ###       ok or not.
+###     return $result if (defined $result);
+    }
+
     if ($questionWord ne "" or $finalQMark) {
 	# if it has not been explicitly marked as a question
 	if ($addressed and $reply eq "") {
diff -ruN blootbot.orig/src/IRC/IrcHooks.pl blootbot/src/IRC/IrcHooks.pl
--- blootbot.orig/src/IRC/IrcHooks.pl	2002-02-18 07:00:09.000000000 -0700
+++ blootbot/src/IRC/IrcHooks.pl	2002-11-08 21:32:34.000000000 -0700
@@ -262,7 +262,7 @@
     if (exists $dcc{'SEND'}{$nick} and -f "$param{tempDir}/$nick.txt") {
 	&status("${b_green}DCC SEND$ob close from $b_cyan$nick$ob");
 
-	&status("dcc_close: purging $nick.txt from Debian.pl");
+	&status("dcc_close: purging $nick.txt from Debian.pl or Fink.pl");
 	unlink "$param{tempDir}/$nick.txt";
 
 	delete $dcc{'SEND'}{$nick};
diff -ruN blootbot.orig/src/IRC/Schedulers.pl blootbot/src/IRC/Schedulers.pl
--- blootbot.orig/src/IRC/Schedulers.pl	2002-01-11 07:00:12.000000000 -0700
+++ blootbot/src/IRC/Schedulers.pl	2002-11-08 21:37:56.000000000 -0700
@@ -853,6 +853,17 @@
     }
     closedir DEBIAN;
 
+    # fink check.
+    opendir(FINK, "$bot_state_dir/fink");
+    foreach ( grep /gz$/, readdir(FINK) ) {
+        my $exit = CORE::system("gzip -t $bot_state_dir/fink/$_");
+        next unless ($exit);
+
+        &status("fink: unlinking file => $_");
+        unlink "$bot_state_dir/fink/$_";       
+    }
+    closedir FINK;
+
     # compress logs that should have been compressed.
     # todo: use strftime?
     my ($day,$month,$year) = (localtime(time()))[3,4,5];
diff -ruN blootbot.orig/src/Modules/Fink.pl blootbot/src/Modules/Fink.pl
--- blootbot.orig/src/Modules/Fink.pl	1969-12-31 17:00:00.000000000 -0700
+++ blootbot/src/Modules/Fink.pl	2002-11-08 21:27:09.000000000 -0700
@@ -0,0 +1,1113 @@
+#
+#   Fink.pl: Frontend to fink contents and packages files
+#      Author: dms (Fink.pl)
+#     Version: v0.8 (20000918)
+#     Created: 20000106
+#
+
+package Fink;
+
+use strict;
+
+# format: "alias=real".
+my $announce	= 0;
+my $defaultdist	= "unstable";
+my $refresh = &::getChanConfDefault("finkRefreshInterval",7)
+			* 60 * 60 * 24;
+my $debug	= 0;
+my $fink_dir	= "$::bot_state_dir/fink";
+
+### new... the right way.
+my %dists	= (
+	"unstable"	=> "unstable",
+	"stable"	=> "stable",
+);
+
+my %urlcontents = (
+	"Contents-##DIST-darwin-powerpc.gz" =>
+		"file:/".
+		"@FINKPREFIX@/fink/dists/##DIST/Contents-darwin-powerpc.gz",
+);
+
+my %urlpackages = (
+	"Packages-##DIST-main-darwin-powerpc.gz" =>
+		"file:/".
+		"@FINKPREFIX@/fink/dists/##DIST/main/binary-darwin-powerpc/Packages.gz",
+	"Packages-##DIST-crypto-darwin-powerpc.gz" =>
+		"file:/".
+		"@FINKPREFIX@/fink/dists/##DIST/crypto/binary-darwin-powerpc/Packages.gz",
+);
+
+#####################
+### COMMON FUNCTION....
+#######################
+
+####
+# Usage: &FinkDownload($dist, %hash);
+sub FinkDownload {
+    my ($dist, %urls)	= @_;
+    my $bad	= 0;
+    my $good	= 0;
+
+    if (! -d $fink_dir) {
+	&::status("Fink: creating fink dir.");
+	mkdir($fink_dir, 0755);
+    }
+
+    # fe dists.
+    # Download the files.
+    my $file;
+    foreach $file (keys %urls) {
+	my $url = $urls{$file};
+	$url  =~ s/##DIST/$dist/g;
+	$file =~ s/##DIST/$dist/g;
+	my $update = 0;
+
+	if ( -f $file ) {
+	    my $last_refresh = (stat $file)[9];
+	    $update++ if (time() - $last_refresh > $refresh);
+	} else {
+	    $update++;
+	}
+
+	next unless ($update);
+
+	&::DEBUG("announce == $announce.") if ($debug);
+	if ($good + $bad == 0 and !$announce) {
+	    &::status("Fink: Downloading files for '$dist'.");
+	    &::msg($::who, "Updating fink files... please wait.");
+	    $announce++;
+	}
+
+	if (exists $::fink{$url}) {
+	    &::DEBUG("2: ".(time - $::fink{$url})." <= $refresh") if ($debug);
+	    next if (time() - $::fink{$url} <= $refresh);
+	    &::DEBUG("stale for url $url; updating!") if ($debug);
+	}
+
+	if ($url =~ /^ftp:\/\/(.*?)\/(\S+)\/(\S+)$/) {
+	    my ($host,$path,$thisfile) = ($1,$2,$3);
+
+	    if (!&::ftpGet($host,$path,$thisfile,$file)) {
+		&::WARN("deb: down: $file == BAD.");
+		$bad++;
+		next;
+	    }
+
+	    if (! -f $file) {
+		&::WARN("deb: down: ftpGet: !file");
+		$bad++;
+		next;
+	    }
+
+	    &::DEBUG("deb: download: good.") if ($debug);
+	    $good++;
+	} else {
+	    &::ERROR("Fink: invalid format of url => ($url).");
+	    $bad++;
+	    next;
+	}
+    }
+
+    # ok... lets just run this.
+    &::miscCheck();
+
+    if ($good) {
+	&generateIndex($dist);
+	return 1;
+    } else {
+	return -1 unless ($bad);	# no download.
+	&::DEBUG("DD: !good and bad($bad). :(");
+	return 0;
+    }
+}
+
+###########################
+# FINK CONTENTS SEARCH FUNCTIONS.
+########
+
+####
+# Usage: &searchContents($query);
+sub searchContents {
+    my ($dist, $query)	= &getDistroFromStr($_[0]);
+    &::status("Fink: Contents search for '$query' in '$dist'.");
+    my $dccsend	= 0;
+
+    $dccsend++		if ($query =~ s/^dcc\s+//i);
+
+    $query =~ s/\\([\^\$])/$1/g;	# hrm?
+    $query =~ s/^\s+|\s+$//g;
+
+    if (!&::validExec($query)) {
+	&::msg($::who, "search string looks fuzzy.");
+	return;
+    }
+
+    if ($dist eq "incoming") {		# nothing yet.
+	&::DEBUG("sC: dist = 'incoming'. no contents yet.");
+	return;
+    } else {
+	my %urls = &fixDist($dist, %urlcontents);
+	# download contents file.
+	&::DEBUG("deb: download 1.") if ($debug);
+	if (!&FinkDownload($dist, %urls)) {
+	    &::WARN("Fink: could not download files.");
+	}
+    }
+
+    # start of search.
+    my $start_time = &::timeget();
+
+    my $found	= 0;
+    my $front	= 0;
+    my %contents;
+    my $grepRE;
+    ### TODO: search properly if /usr/bin/blah is done.
+    if ($query =~ s/\$$//) {
+	&::DEBUG("deb: search-regex found.") if ($debug);
+	$grepRE = "$query\[ \t]";
+    } elsif ($query =~ s/^\^//) {
+	&::DEBUG("deb: front marker regex found.") if ($debug);
+	$front = 1;
+	$grepRE = $query;
+    } else {
+	$grepRE = "$query*\[ \t]";
+    }
+
+    # fix up grepRE for "*".
+    $grepRE =~ s/\*/.*/g;
+
+    my @files;
+    foreach (keys %urlcontents) {
+	s/##DIST/$dist/g;
+
+	next unless ( -f "$fink_dir/$_" );
+	push(@files, "$fink_dir/$_");
+    }
+
+    if (!scalar @files) {
+	&::ERROR("sC: no files?");
+	&::msg($::who, "failed.");
+	return;
+    }
+
+    my $files = join(' ', @files);
+
+    my $regex	= $query;
+    $regex	=~ s/\./\\./g;
+    $regex	=~ s/\*/\\S*/g;
+    $regex	=~ s/\?/./g;
+
+    open(IN,"zegrep -h '$grepRE' $files |");
+    # wonderful abuse of last and next and unless ;)
+    while (<IN>) {
+	last if ($found > 100);
+
+	next unless (/^\.?\/?(.*?)[\t\s]+(\S+)\n$/);
+	my ($file,$package) = ("/".$1,$2);
+
+	if ($query =~ /[\/\*\\]/) {
+	    next unless (eval { $file =~ /$regex/ });
+	    return unless &checkEval($@);
+	} else {
+	    my ($basename) = $file =~ /^.*\/(.*)$/;
+	    next unless (eval { $basename =~ /$regex/ });
+	    return unless &checkEval($@);
+	}
+	next if ($query !~ /\.\d\.gz/ and $file =~ /\/man\//);
+	next if ($front and eval { $file !~ /^\/$query/ });
+	return unless &checkEval($@);
+
+	$contents{$package}{$file} = 1;
+	$found++;
+    }
+    close IN;
+
+    my $pkg;
+
+    ### send results with dcc.
+    if ($dccsend) {
+	if (exists $::dcc{'SEND'}{$::who}) {
+	    &::msg($::who, "DCC already active!");
+	    return;
+	}
+
+	if (!scalar %contents) {
+	    &::msg($::who,"search returned no results.");
+	    return;
+	}
+
+	my $file = "$::param{tempDir}/$::who.txt";
+	if (!open OUT, ">$file") {
+	    &::ERROR("Fink: cannot write file for dcc send.");
+	    return;
+	}
+
+	foreach $pkg (keys %contents) {
+	    foreach (keys %{ $contents{$pkg} }) {
+		# TODO: correct padding.
+		print OUT "$_\t\t\t$pkg\n";
+	    }
+	}
+	close OUT;
+
+	&::shmWrite($::shm, "DCC SEND $::who $file");
+
+	return;
+    }
+
+    &::status("Fink: $found contents results found.");
+
+    my @list;
+    foreach $pkg (keys %contents) {
+	my @tmplist = &::fixFileList(keys %{ $contents{$pkg} });
+	my @sublist = sort { length $a <=> length $b } @tmplist;
+
+	pop @sublist while (scalar @sublist > 3);
+
+	$pkg =~ s/\,/\037\,\037/g;	# underline ','.
+	push(@list, "(". join(', ',@sublist) .") in $pkg");
+    }
+    # sort the total list from shortest to longest...
+    @list = sort { length $a <=> length $b } @list;
+
+    # show how long it took.
+    my $delta_time = &::timedelta($start_time);
+    &::status(sprintf("Fink: %.02f sec to complete query.", $delta_time)) if ($delta_time > 0);
+
+    my $prefix = "Fink Search of '$query' ";
+    if (scalar @list) {	# @list.
+	&::pSReply( &::formListReply(0, $prefix, @list) );
+
+    } else {		# !@list.
+	&::DEBUG("deb: ok, !\@list, searching desc for '$query'.") if ($debug);
+	my @list = &searchDesc($query);
+
+	if (!scalar @list) {
+	    my $prefix = "Fink Package/File/Desc Search of '$query' ";
+	    &::pSReply( &::formListReply(0, $prefix, ) );
+
+	} elsif (scalar @list == 1) {	# list = 1.
+	    &::DEBUG("deb: list == 1; showing package info of '$list[0]'.");
+	    &infoPackages("info", $list[0]);
+
+	} else {				# list > 1.
+	    my $prefix = "Fink Desc Search of '$query' ";
+	    &::pSReply( &::formListReply(0, $prefix, @list) );
+	}
+    }
+}
+
+####
+# Usage: &searchAuthor($query);
+sub searchAuthor {
+    my ($dist, $query)	= &getDistroFromStr($_[0]);
+    &::DEBUG("deb: searchAuthor: dist => '$dist', query => '$query'.") if ($debug);
+    $query =~ s/^\s+|\s+$//g;
+
+    # start of search.
+    my $start_time = &::timeget();
+    &::status("Fink: starting author search.");
+
+    my $files;
+    my ($bad,$good) = (0,0);
+    my %urls = %urlpackages;
+
+    foreach (keys %urlpackages) {
+	s/##DIST/$dist/g;
+
+	if (! -f "$fink_dir/$_" ) {
+	    $bad++;
+	    next;
+	}
+
+	$good++;
+	$files .= " ".$_;
+    }
+
+    &::DEBUG("deb: good = $good, bad = $bad...") if ($debug);
+
+    if ($good == 0 and $bad != 0) {
+	my %urls = &fixDist($dist, %urlpackages);
+	&::DEBUG("deb: download 2.");
+
+	if (!&FinkDownload($dist, %urls)) {
+	    &::ERROR("Fink(sA): could not download files.");
+	    return;
+	}
+    }
+
+    my (%maint, %pkg, $package);
+    open(IN,"zegrep -h '^Package|^Maintainer' $files |");
+    while (<IN>) {
+	if (/^Package: (\S+)$/) {
+	    $package = $1;
+
+	} elsif (/^Maintainer: (.*) \<(\S+)\>$/) {
+	    my($name,$email) = ($1,$2);
+	    if ($package eq "") {
+		&::DEBUG("deb: sA: package == NULL.");
+		next;
+	    }
+	    $maint{$name}{$email} = 1;
+	    $pkg{$name}{$package} = 1;
+	    $package = "";
+
+	} else {
+	    &::WARN("fink: invalid line: '$_' (1).");
+	}
+    }
+    close IN;
+
+    my %hash;
+    # TODO: can we use 'map' here?
+    foreach (grep /\Q$query\E/i, keys %maint) {
+	$hash{$_} = 1;
+    }
+
+    # TODO: should we only search email if '@' is used?
+    if (scalar keys %hash < 15) {
+	my $name;
+
+	foreach $name (keys %maint) {
+	    my $email;
+
+	    foreach $email (keys %{ $maint{$name} }) {
+		next unless ($email =~ /\Q$query\E/i);
+		next if (exists $hash{$name});
+		$hash{$name} = 1;
+	    }
+	}
+    }
+
+    my @list = keys %hash;
+    if (scalar @list != 1) {
+	my $prefix = "Fink Author Search of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, @list) );
+	return 1;
+    }
+
+    &::DEBUG("deb: showing all packages by '$list[0]'...") if ($debug);
+
+    my @pkg = sort keys %{ $pkg{$list[0]} };
+
+    # show how long it took.
+    my $delta_time = &::timedelta($start_time);
+    &::status(sprintf("Fink: %.02f sec to complete query.", $delta_time)) if ($delta_time > 0);
+
+    my $email	= join(', ', keys %{ $maint{$list[0]} });
+    my $prefix	= "Fink Packages by $list[0] \002<\002$email\002>\002 ";
+    &::pSReply( &::formListReply(0, $prefix, @pkg) );
+}
+
+####
+# Usage: &searchDesc($query);
+sub searchDesc {
+    my ($dist, $query)	= &getDistroFromStr($_[0]);
+    &::DEBUG("deb: searchDesc: dist => '$dist', query => '$query'.") if ($debug);
+    $query =~ s/^\s+|\s+$//g;
+
+    # start of search.
+    my $start_time = &::timeget();
+    &::status("Fink: starting desc search.");
+
+    my $files;
+    my ($bad,$good) = (0,0);
+    my %urls = %urlpackages;
+
+    foreach (keys %urlpackages) {
+	s/##DIST/$dist/g;
+
+	if (! -f "$fink_dir/$_" ) {
+	    $bad++;
+	    next;
+	}
+
+	$good++;
+	$files .= " $fink_dir/$_";
+    }
+
+    &::DEBUG("deb(2): good = $good, bad = $bad...") if ($debug);
+
+    if ($good == 0 and $bad != 0) {
+	my %urls = &fixDist($dist, %urlpackages);
+	&::DEBUG("deb: download 2c.") if ($debug);
+
+	if (!&FinkDownload($dist, %urls)) {
+	    &::ERROR("deb: sD: could not download files.");
+	    return;
+	}
+    }
+
+    my $regex	= $query;
+    $regex	=~ s/\./\\./g;
+    $regex	=~ s/\*/\\S*/g;
+    $regex	=~ s/\?/./g;
+
+    my (%desc, $package);
+    open(IN,"zegrep -h '^Package|^Description' $files |");
+    while (<IN>) {
+	if (/^Package: (\S+)$/) {
+	    $package = $1;
+	} elsif (/^Description: (.*)$/) {
+	    my $desc = $1;
+	    next unless (eval { $desc =~ /$regex/i });
+	    return unless &checkEval($@);
+
+	    if ($package eq "") {
+		&::WARN("sD: package == NULL?");
+		next;
+	    }
+
+	    $desc{$package} = $desc;
+	    $package = "";
+
+	} else {
+	    &::WARN("fink: invalid line: '$_'. (2)");
+	}
+    }
+    close IN;
+
+    # show how long it took.
+    my $delta_time = &::timedelta($start_time);
+    &::status(sprintf("Fink: %.02f sec to complete query.", $delta_time)) if ($delta_time > 0);
+
+    return keys %desc;
+}
+
+####
+# Usage: &generateIncoming();
+sub generateIncoming {
+    my $pkgfile  = $fink_dir."/Packages-incoming";
+    my $idxfile  = $pkgfile.".idx";
+    my $stale	 = 0;
+    $stale++ if (&::isStale($pkgfile.".gz", $refresh));
+    $stale++ if (&::isStale($idxfile, $refresh));
+    &::DEBUG("deb: gI: stale => '$stale'.") if ($debug);
+    return 0 unless ($stale);
+
+    ### STATIC URL.
+    my %ftp = &::ftpList("llug.sep.bnl.gov", "/pub/fink/Incoming/");
+
+    if (!open PKG, ">$pkgfile") {
+	&::ERROR("cannot write to pkg $pkgfile.");
+	return 0;
+    }
+    if (!open IDX, ">$idxfile") {
+	&::ERROR("cannot write to idx $idxfile.");
+	return 0;
+    }
+
+    print IDX "*$pkgfile.gz\n";
+    my $file;
+    foreach $file (sort keys %ftp) {
+	next unless ($file =~ /deb$/);
+
+	if ($file =~ /^(\S+)\_(\S+)\_(\S+)\.deb$/) {
+	    print IDX "$1\n";
+	    print PKG "Package: $1\n";
+	    print PKG "Version: $2\n";
+	    print PKG "Architecture: ", (defined $4) ? $4 : "all", "\n";
+	}
+	print PKG "Filename: $file\n";
+	print PKG "Size: $ftp{$file}\n";
+	print PKG "\n";
+    }
+    close IDX;
+    close PKG;
+
+    system("gzip -9fv $pkgfile");	# lame fix.
+
+    &::status("Fink: generateIncoming() complete.");
+}
+
+
+##############################
+# FINK PACKAGE INFO FUNCTIONS.
+#########
+
+# Usage: &getPackageInfo($query,$file);
+sub getPackageInfo {
+    my ($package, $file) = @_;
+
+    if (! -f $file) {
+	&::status("gPI: file $file does not exist?");
+	return 'NULL';
+    }
+
+    my $found = 0;
+    my (%pkg, $pkg);
+
+    open(IN, "zcat $file 2>&1 |");
+
+    my $done = 0;
+    while (!eof IN) {
+	$_ = <IN>;
+
+	next if (/^ \S+/);	# package long description.
+
+	# package line.
+	if (/^Package: (.*)\n$/) {
+	    $pkg = $1;
+	    if ($pkg =~ /^$package$/i) {
+		$found++;	# we can use pkg{'package'} instead.
+		$pkg{'package'} = $pkg;
+	    }
+
+	    next;
+	}
+
+	if ($found) {
+	    chop;
+
+	    if (/^Version: (.*)$/) {
+		$pkg{'version'}		= $1;
+	    } elsif (/^Priority: (.*)$/) {
+		$pkg{'priority'}	= $1;
+	    } elsif (/^Section: (.*)$/) {
+		$pkg{'section'}		= $1;
+	    } elsif (/^Size: (.*)$/) {
+		$pkg{'size'}		= $1;
+	    } elsif (/^Installed-Size: (.*)$/i) {
+		$pkg{'installed'}	= $1;
+	    } elsif (/^Description: (.*)$/) {
+		$pkg{'desc'}		= $1;
+	    } elsif (/^Filename: (.*)$/) {
+		$pkg{'find'}		= $1;
+	    } elsif (/^Pre-Depends: (.*)$/) {
+		$pkg{'depends'}		= "pre-depends on $1";
+	    } elsif (/^Depends: (.*)$/) {
+		if (exists $pkg{'depends'}) {
+		    $pkg{'depends'} .= "; depends on $1";
+		} else {
+		    $pkg{'depends'} = "depends on $1";
+		}
+	    } elsif (/^Maintainer: (.*)$/) {
+		$pkg{'maint'} = $1;
+	    } elsif (/^Provides: (.*)$/) {
+		$pkg{'provides'} = $1;
+	    } elsif (/^Suggests: (.*)$/) {
+		$pkg{'suggests'} = $1;
+	    } elsif (/^Conflicts: (.*)$/) {
+		$pkg{'conflicts'} = $1;
+	    }
+
+###	    &::DEBUG("=> '$_'.");
+	}
+
+	# blank line.
+	if (/^$/) {
+	    undef $pkg;
+	    last if ($found);
+	    next;
+	}
+
+	next if (defined $pkg);
+    }
+
+    close IN;
+
+    %pkg;
+}
+
+# Usage: &infoPackages($query,$package);
+sub infoPackages {
+    my ($query,$dist,$package) = ($_[0], &getDistroFromStr($_[1]));
+
+    &::status("Fink: Searching for package '$package' in '$dist'.");
+
+    # download packages file.
+    # hrm...
+    my %urls = &fixDist($dist, %urlpackages);
+    if ($dist ne "incoming") {
+	&::DEBUG("deb: download 3.") if ($debug);
+
+	if (!&FinkDownload($dist, %urls)) {	# no good download.
+	    &::WARN("Fink(iP): could not download ANY files.");
+	}
+    }
+
+    # check if the package is valid.
+    my $incoming = 0;
+    my @files = &validPackage($package, $dist);
+    if (!scalar @files) {
+	&::status("Fink: no valid package found; checking incoming.");
+	@files = &validPackage($package, "incoming");
+	if (scalar @files) {
+	    &::status("Fink: cool, it exists in incoming.");
+	    $incoming++;
+	} else {
+	    &::msg($::who, "Package '$package' does not exist.");
+	    return 0;
+	}
+    }
+
+    if (scalar @files > 1) {
+	&::WARN("same package in more than one file; random.");
+	&::DEBUG("THIS SHOULD BE FIXED SOMEHOW!!!");
+	$files[0] = &::getRandom(@files);
+    }
+
+    if (! -f $files[0]) {
+	&::WARN("files[0] ($files[0]) doesn't exist.");
+	&::msg($::who, "WARNING: $files[0] does not exist? FIXME");
+	return 'NULL';
+    }
+
+    ### TODO: if specific package is requested, note down that a version
+    ###		exists in incoming.
+
+    my $found = 0;
+    my $file = $files[0];
+    my ($pkg);
+
+    ### TODO: use fe, dump to a hash. if only one version of the package
+    ###		exists. do as normal otherwise list all versions.
+    if (! -f $file) {
+	&::ERROR("D:iP: file '$file' DOES NOT EXIST!!! should never happen.");
+	return 0;
+    }
+    my %pkg = &getPackageInfo($package, $file);
+
+    # 'fm'-like output.
+    if ($query eq "info") {
+	if (scalar keys %pkg > 5) {
+	    $pkg{'info'}  = "\002(\002". $pkg{'desc'} ."\002)\002";
+	    $pkg{'info'} .= ", section ".$pkg{'section'};
+	    $pkg{'info'} .= ", is ".$pkg{'priority'};
+#	    $pkg{'info'} .= ". Version: \002$pkg{'version'}\002";
+	    $pkg{'info'} .= ". Version: \002$pkg{'version'}\002 ($dist)";
+	    $pkg{'info'} .= ", Packaged size: \002". int($pkg{'size'}/1024) ."\002 kB";
+	    $pkg{'info'} .= ", Installed size: \002$pkg{'installed'}\002 kB";
+
+	    if ($incoming) {
+		&::status("iP: info requested and pkg is in incoming, too.");
+		my %incpkg = &getPackageInfo($query, $fink_dir ."/Packages-incoming");
+
+		if (scalar keys %incpkg) {
+		   $pkg{'info'} .= ". Is in incoming ($incpkg{'file'}).";
+		} else {
+		    &::ERROR("iP: pkg $query is in incoming but we couldn't get any info?");
+		}
+	    }
+	} else {
+	    &::DEBUG("deb: running finkCheck() due to problems (".scalar(keys %pkg).").");
+	    &finkCheck();
+	    &::DEBUG("deb: end of finkCheck()");
+
+	    &::msg($::who,"Fink: Package appears to exist but I could not retrieve info about it...");
+	    return;
+	}
+    } 
+
+    if ($dist eq "incoming") {
+	$pkg{'info'} .= "Version: \002$pkg{'version'}\002";
+	$pkg{'info'} .= ", Packaged size: \002". int($pkg{'size'}/1024) ."\002 kB";
+	$pkg{'info'} .= ", is in incoming!!!";
+    }
+
+    if (!exists $pkg{$query}) {
+	if ($query eq "suggests") {
+	    $pkg{$query} = "has no suggestions";
+	} elsif ($query eq "conflicts") {
+	    $pkg{$query} = "does not conflict with any other package";
+	} elsif ($query eq "depends") {
+	    $pkg{$query} = "does not depend on anything";
+	} elsif ($query eq "maint") {
+	    $pkg{$query} = "has no maintainer";
+	} else {
+	    $pkg{$query} = "has nothing about $query";
+	}
+    }
+
+    &::pSReply("$package: $pkg{$query}");
+}
+
+# Usage: &infoStats($dist);
+sub infoStats {
+    my ($dist)	= @_;
+    $dist	= &getDistro($dist);
+    return unless (defined $dist);
+
+    &::DEBUG("deb: infoS: dist => '$dist'.");
+
+    # download packages file if needed.
+    my %urls = &fixDist($dist, %urlpackages);
+    &::DEBUG("deb: download 4.");
+    if (!&FinkDownload($dist, %urls)) {
+	&::WARN("Fink(iS): could not download ANY files.");
+	&::msg($::who, "Fink(iS): internal error.");
+	return;
+    }
+
+    my %stats;
+    my %total;
+    my $file;
+    foreach $file (keys %urlpackages) {
+	$file =~ s/##DIST/$dist/g;	# won't work for incoming.
+	&::DEBUG("deb: file => '$file'.");
+	if (exists $stats{$file}{'count'}) {
+	    &::DEBUG("deb: hrm... duplicate open with $file???");
+	    next;
+	}
+
+	open(IN, "zcat $file 2>&1 |");
+
+	if (! -e $file) {
+	    &::DEBUG("deb: iS: $file does not exist.");
+	    next;
+	}
+
+	while (!eof IN) {
+	    $_ = <IN>;
+
+	    next if (/^ \S+/);	# package long description.
+
+	    if (/^Package: (.*)\n$/) {		# counter.
+		$stats{$file}{'count'}++;
+		$total{'count'}++;
+	    } elsif (/^Maintainer: .* <(\S+)>$/) {
+		$stats{$file}{'maint'}{$1}++;
+		$total{'maint'}{$1}++;
+	    } elsif (/^Size: (.*)$/) {		# compressed size.
+		$stats{$file}{'csize'}	+= $1;
+		$total{'csize'}		+= $1;
+	    } elsif (/^i.*size: (.*)$/i) {	# installed size.
+		$stats{$file}{'isize'}	+= $1;
+		$total{'isize'}		+= $1;
+	    }
+
+###	    &::DEBUG("=> '$_'.");
+	}
+	close IN;
+    }
+
+    ### TODO: don't count ppl with multiple email addresses.
+
+    &::pSReply(
+	"Fink Distro Stats on $dist... ".
+	"\002$total{'count'}\002 packages, ".
+	"\002".scalar(keys %{ $total{'maint'} })."\002 maintainers, ".
+	"\002". int($total{'isize'}/1024)."\002 MB installed size, ".
+	"\002". int($total{'csize'}/1024/1024)."\002 MB compressed size."
+    );
+
+### TODO: do individual stats? if so, we need _another_ arg.
+#    foreach $file (keys %stats) {
+#	foreach (keys %{ $stats{$file} }) {
+#	    &::DEBUG("  '$file' '$_' '$stats{$file}{$_}'.");
+#	}
+#    }
+
+    return;
+}
+
+###
+# HELPER FUNCTIONS FOR INFOPACKAGES...
+###
+
+# Usage: &generateIndex();
+sub generateIndex {
+    my (@dists)	= @_;
+    &::DEBUG("D: generateIndex($dists[0]) called!");
+    if (!scalar @dists or $dists[0] eq '') {
+	&::ERROR("gI: no dists to generate index.");
+	return 1;
+    }
+
+    foreach (@dists) {
+	my $dist = &getDistro($_); # incase the alias is returned, possible?
+	my $idx  = $fink_dir."/Packages-$dist.idx";
+
+	# TODO: check if any of the Packages file have been updated then
+	#	regenerate it, even if it's not stale.
+	# TODO: also, regenerate the index if the packages file is newer
+	#	than the index.
+	next unless (&::isStale($idx, $refresh));
+
+	if (/^incoming$/i) {
+	    &::DEBUG("deb: gIndex: calling generateIncoming()!");
+	    &generateIncoming();
+	    next;
+	}
+
+	if (/^woody$/i) {
+	    &::DEBUG("deb: Copying old index of woody to -old");
+	    system("cp $idx $idx-old");
+	}
+
+	&::DEBUG("deb: gIndex: calling FinkDownload($dist, ...).") if ($debug);
+	&FinkDownload($dist, &fixDist($dist, %urlpackages) );
+
+	&::status("Fink: generating index for '$dist'.");
+	if (!open OUT, ">$idx") {
+	    &::ERROR("cannot write to $idx.");
+	    return 0;
+	}
+
+	my $packages;
+	foreach $packages (keys %urlpackages) {
+	    $packages =~ s/##DIST/$dist/;
+	    $packages =  "$fink_dir/$packages";
+
+	    if (! -e $packages) {
+		&::ERROR("gIndex: '$packages' does not exist?");
+		next;
+	    }
+
+	    print OUT "*$packages\n";
+	    open(IN,"zcat $packages |");
+
+	    while (<IN>) {
+		next unless (/^Package: (.*)\n$/);
+		print OUT $1."\n";
+	    }
+	    close IN;
+	}
+	close OUT;
+    }
+
+    return 1;
+}
+
+# Usage: &validPackage($package, $dist);
+sub validPackage {
+    my ($package,$dist) = @_;
+    my @files;
+    my $file;
+
+    ### this majorly sucks, we need some standard in place.
+    # why is this needed... need to investigate later.
+    my $olddist	= $dist;
+    $dist = &getDistro($dist);
+
+    &::DEBUG("deb: validPackage($package, $dist) called.") if ($debug);
+
+    my $error = 0;
+    while (!open IN, $fink_dir."/Packages-$dist.idx") {
+	if ($error) {
+	    &::ERROR("Packages-$dist.idx does not exist (#1).");
+	    return;
+	}
+
+	&generateIndex($dist);
+
+	$error++;
+    }
+
+    my $count = 0;
+    while (<IN>) {
+	if (/^\*(.*)\n$/) {
+	    $file = $1;
+	    next;
+	}
+
+	if (/^\Q$package\E\n$/) {
+	    push(@files,$file);
+	}
+	$count++;
+    }
+    close IN;
+
+    &::VERB("vP: scanned $count items in index.",2);
+
+    return @files;
+}
+
+sub searchPackage {
+    my ($dist, $query) = &getDistroFromStr($_[0]);
+    my $file = $fink_dir."/Packages-$dist.idx";
+    my @files;
+    my $error	= 0;
+    my $warn	= ($query =~ tr/A-Z/a-z/) ? 1 : 0;
+
+    &::status("Fink: Search package matching '$query' in '$dist'.");
+    unlink $file if ( -z $file );
+
+    while (!open IN, $file) {
+	if ($dist eq "incoming") {
+	    &::DEBUG("deb: sP: dist == incoming; calling gI().");
+	    &generateIncoming();
+	}
+
+	if ($error) {
+	    &::ERROR("could not generate index ($file)!");
+	    return;
+	}
+
+	$error++;
+	&::DEBUG("deb: should we be doing this?");
+	&generateIndex(($dist));
+    }
+
+    while (<IN>) {
+	chop;
+
+	if (/^\*(.*)$/) {
+	    $file = $1;
+
+	    if (&::isStale($file, $refresh)) {
+		&::DEBUG("deb: STALE $file! regen.") if ($debug);
+		&generateIndex(($dist));
+###		@files = searchPackage("$query $dist");
+		&::DEBUG("deb: EVIL HACK HACK HACK.") if ($debug);
+		last;
+	    }
+
+	    next;
+	}
+
+	if (/\Q$query\E/) {
+	    push(@files,$_);
+	}
+    }
+    close IN;
+
+    if (scalar @files and $warn) {
+	&::msg($::who, "searching for package name should be fully lowercase!");
+    }
+
+    return @files;
+}
+
+sub getDistro {
+    my $dist = $_[0];
+
+    if (!defined $dist or $dist eq "") {
+	&::DEBUG("deb: gD: dist == NULL; dist = defaultdist.");
+	$dist = $defaultdist;
+    }
+
+    if ($dist =~ /^(slink|hamm|rex|bo)$/i) {
+	&::DEBUG("deb: deprecated version ($dist).");
+	&::msg($::who, "Fink: deprecated distribution version.");
+	return;
+    }
+
+    if (exists $dists{$dist}) {
+	&::VERB("gD: returning dists{$dist} ($dists{$dist})",2);
+	return $dists{$dist};
+
+    } else {
+	if (!grep /^\Q$dist\E$/i, %dists) {
+	    &::msg($::who, "invalid dist '$dist'.");
+	    return;
+	}
+
+	&::VERB("gD: returning $dist (no change or conversion)",2);
+	return $dist;
+    }
+}
+
+sub getDistroFromStr {
+    my ($str) = @_;
+    my $dists	= join '|', %dists;
+    my $dist	= $defaultdist;
+
+    if ($str =~ s/\s+($dists)$//i) {
+	$dist = &getDistro(lc $1);
+	$str =~ s/\\+$//;
+    }
+    $str =~ s/\\([\$\^])/$1/g;
+
+    return($dist,$str);
+}
+
+sub fixDist {
+    my ($dist, %urls) = @_;
+    my %new;
+    my ($key,$val);
+
+    while (($key,$val) = each %urls) {
+	$key =~ s/##DIST/$dist/;
+	$val =~	s/##DIST/$dist/;
+	### TODO: what should we do if the sar wasn't done.
+	$new{$fink_dir."/".$key} = $val;
+    }
+
+    return %new;
+}
+
+sub FinkFind {
+    # HACK! HACK! HACK!
+    my ($str) = @_;
+    my ($dist, $query) = &getDistroFromStr($str);
+    my @results = sort &searchPackage($str);
+
+    if (!scalar @results) {
+	&::Forker("fink", sub { &searchContents($str); } );
+    } elsif (scalar @results == 1) {
+	&::status("searchPackage returned one result; getting info of package instead!");
+	&::Forker("fink", sub { &infoPackages("info", "$results[0] $dist"); } );
+    } else {
+	my $prefix = "Fink Package Listing of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, @results) );
+    }
+}
+
+sub finkCheck {
+    my $error	= 0;
+
+    &::status("finkCheck() called.");
+
+    ### TODO: remove the following loop (check if dir exists before)
+    while (1) {
+	last if (opendir(FINK, $fink_dir));
+
+	if ($error) {
+	    &::ERROR("dC: cannot opendir fink.");
+	    return;
+	}
+
+	mkdir $fink_dir, 0755;
+	$error++;
+    }
+
+    my $retval = 0;
+    my $file;
+    while (defined($file = readdir FINK)) {
+	next unless ($file =~ /(gz|bz2)$/);
+
+	my $exit = system("gzip -t '$fink_dir/$file'");
+	next unless ($exit);
+	&::DEBUG("deb: hmr... => ".(time() - (stat($file))[8])."'.");
+	next unless (time() - (stat($file))[8] > 3600);
+
+	&::DEBUG("deb: dC: exit => '$exit'.");
+	&::WARN("dC: '$fink_dir/$file' corrupted? deleting!");
+	unlink $fink_dir."/".$file;
+	$retval++;
+    }
+
+    return $retval;
+}
+
+sub checkEval {
+    my($str)	= @_;
+
+    if ($str) {
+	&::WARN("cE: $str");
+	return 0;
+    } else {
+	return 1;
+    }
+}
+
+sub searchDescFE {
+#    &::DEBUG("deb: FE called for searchDesc");
+    my ($query)	= @_;
+    my @list = &searchDesc($query);
+
+    if (!scalar @list) {
+	my $prefix = "Fink Desc Search of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, ) );
+    } elsif (scalar @list == 1) {	# list = 1.
+	&::DEBUG("deb: list == 1; showing package info of '$list[0]'.");
+	&infoPackages("info", $list[0]);
+    } else {				# list > 1.
+	my $prefix = "Fink Desc Search of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, @list) );
+    }
+}
+
+1;
diff -ruN blootbot.orig/src/core.pl blootbot/src/core.pl
--- blootbot.orig/src/core.pl	2002-05-13 08:11:23.000000000 -0600
+++ blootbot/src/core.pl	2002-11-08 21:52:14.000000000 -0700
@@ -391,6 +391,13 @@
 	mkdir $dir, 0755;
     }
 
+    foreach ("fink") {
+        my $dir = "$bot_base_dir/$_/";
+        next if ( -d $dir);
+        &status("Making dir $_");
+        mkdir $dir, 0755;
+    }
+
     # read.
     &loadLang($bot_data_dir. "/blootbot.lang");
     &loadIRCServers();
diff -ruN blootbot.orig/src/modules.pl blootbot/src/modules.pl
--- blootbot.orig/src/modules.pl	2002-05-13 08:11:23.000000000 -0600
+++ blootbot/src/modules.pl	2002-11-08 21:31:38.000000000 -0700
@@ -28,6 +28,7 @@
 	"dumpvars"	=> "DumpVars.pl",
 	"symdump"	=> "DumpVars2.pl",
 	"factoids"	=> "Factoids.pl",
+	"fink"		=> "Fink.pl",
 	"freshmeat"	=> "Freshmeat.pl",
 	"kernel"	=> "Kernel.pl",
 	"ircdcc"	=> "UserDCC.pl",

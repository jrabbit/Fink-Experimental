diff -ruN blootbot.orig/blootbot blootbot/blootbot
--- blootbot.orig/blootbot	Tue Jan 21 18:46:12 2003
+++ blootbot/blootbot	Tue Jan 21 18:45:47 2003
@@ -16,14 +16,14 @@
     }
 
     # set any $bot_*_dir var's that aren't already set
-    $bot_base_dir	||= '.';
-    $bot_config_dir	||= 'files/';
-    $bot_data_dir	||= 'files/';
-    $bot_state_dir	||= 'files/';
-    $bot_run_dir	||= '.';
-    $bot_src_dir	||= "$bot_base_dir/src";
-    $bot_log_dir	||= "$bot_base_dir/log";
-    $bot_misc_dir	||= "$bot_base_dir/files";
+    $bot_base_dir	||= '@FINKPREFIX@';
+    $bot_config_dir	||= '@FINKPREFIX@/etc/blootbot';
+    $bot_data_dir	||= '@FINKPREFIX@/var/blootbot';
+    $bot_state_dir	||= '@FINKPREFIX@/var/blootbot';
+    $bot_run_dir	||= '@FINKPREFIX@/var/run';
+    $bot_src_dir	||= "$bot_base_dir/share/blootbot/src";
+    $bot_log_dir	||= "$bot_base_dir/var/log/blootbot";
+    $bot_misc_dir	||= "$bot_base_dir/share/blootbot";
 
     $bot_pid		= $$;
 
diff -ruN blootbot.orig/setup/setup.pl blootbot/setup/setup.pl
--- blootbot.orig/setup/setup.pl	Tue Jan 21 18:46:18 2003
+++ blootbot/setup/setup.pl	Tue Jan 21 18:46:01 2003
@@ -3,16 +3,16 @@
 # written by the xk.
 ###
 
-require "src/core.pl";
-require "src/logger.pl";
-require "src/modules.pl";
-require "src/Misc.pl";
-require "src/interface.pl";
+require "@FINKPREFIX@/share/blootbot/src/core.pl";
+require "@FINKPREFIX@/share/blootbot/src/logger.pl";
+require "@FINKPREFIX@/share/blootbot/src/modules.pl";
+require "@FINKPREFIX@/share/blootbot/src/Misc.pl";
+require "@FINKPREFIX@/share/blootbot/src/interface.pl";
 
-$bot_src_dir = "./src/";
+$bot_src_dir = "@FINKPREFIX@/share/blootbot/src/";
 
 # read param stuff from blootbot.config.
-&loadConfig("files/blootbot.config");
+&loadConfig("@FINKPREFIX@/etc/blootbot/blootbot.config");
 &loadDBModules();
 my $dbname = $param{'DBName'};
 my $query;
diff -ruN blootbot.orig/src/CommandStubs.pl blootbot/src/CommandStubs.pl
--- blootbot.orig/src/CommandStubs.pl	Tue Jan 21 18:46:20 2003
+++ blootbot/src/CommandStubs.pl	Tue Jan 21 22:04:09 2003
@@ -174,6 +174,21 @@
 &addCmdHook("extra", 'd?find', ('CODEREF' => 'Debian::DebianFind',
 	'Forker' => 1, 'Identifier' => 'debian',
 	'Cmdstats' => 'Debian Search', 'Help' => "find" ) );
+&addCmdHook("extra", 'fauthor', ('CODEREF' => 'Fink::searchAuthor',
+        'Forker' => 1, 'Identifier' => 'fink',     
+        'Cmdstats' => 'Fink Author Search', 'Help' => "fauthor" ) );
+&addCmdHook("extra", 'fdesc', ('CODEREF' => 'Fink::searchDescFE',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Desc Search', 'Help' => "fdesc" ) );
+&addCmdHook("extra", 'fstats', ('CODEREF' => 'Fink::infoStats',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Statistics' ) );
+&addCmdHook("extra", 'fcontents', ('CODEREF' => 'Fink::searchContents',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Contents Search', 'Help' => "fcontents" ) );
+&addCmdHook("extra", 'ffind', ('CODEREF' => 'Fink::FinkFind',
+        'Forker' => 1, 'Identifier' => 'fink',
+        'Cmdstats' => 'Fink Search', 'Help' => "ffind" ) );
 &addCmdHook("extra", 'insult', ('CODEREF' => 'Insult::Insult',
 	'Forker' => 1, 'Identifier' => 'insult', 'Help' => "insult" ) );
 &addCmdHook("extra", 'kernel', ('CODEREF' => 'Kernel::Kernel',
@@ -249,10 +264,11 @@
 	return;
     }
 
+    my $enabledebian     = &::getChanConfDefault("debianEnable",0);
     my $debiancmd	 = 'conflicts?|depends?|desc|file|info|provides?';
     $debiancmd		.= '|recommends?|suggests?|maint|maintainer';
 
-    if ($message =~ /^($debiancmd)(\s+(.*))?$/i) {
+    if ($message =~ /^($debiancmd)(\s+(.*))?$/i && $enabledebian == 1) {
 	return unless (&hasParam("debian"));
 	my $package = lc $3;
 
@@ -263,6 +279,23 @@
 	}
 
 	return;
+    }
+
+    my $enablefink     = &::getChanConfDefault("finkEnable",0);   
+    my $finkcmd        = 'conflicts?|depends?|desc|file|info|provides?';
+    $finkcmd          .= '|recommends?|suggests?|maint|maintainer';
+
+    if ($message =~ /^($finkcmd)(\s+(.*))?$/i && $enablefink == 1) {
+        return unless (&hasParam("fink"));
+        my $package = lc $3;
+
+        if (defined $package) {
+            &Forker("fink", sub { &Fink::infoPackages($1, $package); } );
+        } else {
+            &help($1);
+        }
+
+        return;
     }
 
     # google searching. Simon++
diff -ruN blootbot.orig/src/Modules/Fink.pl blootbot/src/Modules/Fink.pl
--- blootbot.orig/src/Modules/Fink.pl	Wed Dec 31 17:00:00 1969
+++ blootbot/src/Modules/Fink.pl	Tue Jan 21 21:43:49 2003
@@ -0,0 +1,1018 @@
+#
+#     Fink.pl: Frontend to fink contents and packages files
+#      Author: dms (Debian.pl), Converted to Fink by TheSin
+#     Version: v0.1 (20030126)
+#     Created: 20030126
+#
+
+package Fink;
+
+use strict;
+
+# format: "alias=real".
+my $announce	= 0;
+my $defaultdist	= "stable";
+my $refresh = &::getChanConfDefault("finkRefreshInterval",7)
+			* 60 * 60 * 24;
+my $debug	= 0;
+my $fink_dir	= "$::bot_state_dir/fink";
+
+my %dists	= (
+	"unstable"	=> "unstable",
+	"stable"	=> "stable",
+);
+
+my %urlcontents = (
+	"Contents-##DIST-darwin-powerpc.gz" =>
+		"http://us.dl.sourceforge.net".
+		"/fink/direct_download 10.2/release".
+		"/dists/##DIST/Contents-darwin-powerpc.gz",
+);
+
+my %urlpackages = (
+	"Packages-##DIST-main-darwin-powerpc.gz" =>
+		"http://us.dl.sourceforge.net".
+		"/fink/direct_download 10.2/release".
+		"/dists/##DIST/main/binary-darwin-powerpc/Packages.gz",
+	"Packages-##DIST-crypto-darwin-powerpc.gz" =>
+		"http://us.dl.sourceforge.net".
+		"/fink/direct_download 10.2/release".
+		"/dists/##DIST/crypto/binary-darwin-powerpc/Packages.gz",
+);
+
+#####################
+### COMMON FUNCTION....
+#######################
+
+####
+# Usage: &FinkDownload($dist, %hash);
+sub FinkDownload {
+    my ($dist, %urls)	= @_;
+    my $bad	= 0;
+    my $good	= 0;
+
+    if (! -d $fink_dir) {
+	&::status("Fink: creating fink dir.");
+	mkdir($fink_dir, 0755);
+    }
+
+    # fe dists.
+    # Download the files.
+    my $file;
+    foreach $file (keys %urls) {
+	my $url = $urls{$file};
+	$url  =~ s/##DIST/$dist/g;
+	$file =~ s/##DIST/$dist/g;
+	my $update = 0;
+
+	if ( -f $file ) {
+	    my $last_refresh = (stat $file)[9];
+	    $update++ if (time() - $last_refresh > $refresh);
+	} else {
+	    $update++;
+	}
+
+	next unless ($update);
+
+	&::DEBUG("announce == $announce.") if ($debug);
+	if ($good + $bad == 0 and !$announce) {
+	    &::status("Fink: Downloading files for '$dist'.");
+	    &::msg($::who, "Updating fink files... please wait.");
+	    $announce++;
+	}
+
+	if (exists $::fink{$url}) {
+	    &::DEBUG("2: ".(time - $::fink{$url})." <= $refresh") if ($debug);
+	    next if (time() - $::fink{$url} <= $refresh);
+	    &::DEBUG("stale for url $url; updating!") if ($debug);
+	}
+
+	if ($url =~ /^ftp:\/\/(.*?)\/(\S+)\/(\S+)$/) {
+	    my ($host,$path,$thisfile) = ($1,$2,$3);
+
+	    if (!&::ftpGet($host,$path,$thisfile,$file)) {
+		&::WARN("deb: down: $file == BAD.");
+		$bad++;
+		next;
+	    }
+
+	    if (! -f $file) {
+		&::WARN("deb: down: ftpGet: !file");
+		$bad++;
+		next;
+	    }
+
+	    &::DEBUG("deb: download: good.") if ($debug);
+	    $good++;
+	} else {
+	    &::ERROR("Fink: invalid format of url => ($url).");
+	    $bad++;
+	    next;
+	}
+    }
+
+    # ok... lets just run this.
+    &::miscCheck();
+
+    if ($good) {
+	&generateIndex($dist);
+	return 1;
+    } else {
+	return -1 unless ($bad);	# no download.
+	&::DEBUG("DD: !good and bad($bad). :(");
+	return 0;
+    }
+}
+
+###########################
+# FINK CONTENTS SEARCH FUNCTIONS.
+########
+
+####
+# Usage: &searchContents($query);
+sub searchContents {
+    my ($dist, $query)	= &getDistroFromStr($_[0]);
+    &::status("Fink: Contents search for '$query' in '$dist'.");
+    my $dccsend	= 0;
+
+    $dccsend++		if ($query =~ s/^dcc\s+//i);
+
+    $query =~ s/\\([\^\$])/$1/g;	# hrm?
+    $query =~ s/^\s+|\s+$//g;
+
+    if (!&::validExec($query)) {
+	&::msg($::who, "search string looks fuzzy.");
+	return;
+    }
+
+    my %urls = &fixDist($dist, %urlcontents);
+    # download contents file.
+    &::DEBUG("deb: download 1.") if ($debug);
+    if (!&FinkDownload($dist, %urls)) {
+      &::WARN("Fink: could not download files.");
+    }
+
+    # start of search.
+    my $start_time = &::timeget();
+
+    my $found	= 0;
+    my $front	= 0;
+    my %contents;
+    my $grepRE;
+    ### TODO: search properly if /usr/bin/blah is done.
+    if ($query =~ s/\$$//) {
+	&::DEBUG("deb: search-regex found.") if ($debug);
+	$grepRE = "$query\[ \t]";
+    } elsif ($query =~ s/^\^//) {
+	&::DEBUG("deb: front marker regex found.") if ($debug);
+	$front = 1;
+	$grepRE = $query;
+    } else {
+	$grepRE = "$query*\[ \t]";
+    }
+
+    # fix up grepRE for "*".
+    $grepRE =~ s/\*/.*/g;
+
+    my @files;
+    foreach (keys %urlcontents) {
+	s/##DIST/$dist/g;
+
+	next unless ( -f "$fink_dir/$_" );
+	push(@files, "$fink_dir/$_");
+    }
+
+    if (!scalar @files) {
+	&::ERROR("sC: no files?");
+	&::msg($::who, "failed.");
+	return;
+    }
+
+    my $files = join(' ', @files);
+
+    my $regex	= $query;
+    $regex	=~ s/\./\\./g;
+    $regex	=~ s/\*/\\S*/g;
+    $regex	=~ s/\?/./g;
+
+    open(IN,"zgrep -Eh '$grepRE' $files |");
+    # wonderful abuse of last and next and unless ;)
+    while (<IN>) {
+	last if ($found > 100);
+
+	next unless (/^\.?\/?(.*?)[\t\s]+(\S+)\n$/);
+	my ($file,$package) = ("/".$1,$2);
+
+	if ($query =~ /[\/\*\\]/) {
+	    next unless (eval { $file =~ /$regex/ });
+	    return unless &checkEval($@);
+	} else {
+	    my ($basename) = $file =~ /^.*\/(.*)$/;
+	    next unless (eval { $basename =~ /$regex/ });
+	    return unless &checkEval($@);
+	}
+	next if ($query !~ /\.\d\.gz/ and $file =~ /\/man\//);
+	next if ($front and eval { $file !~ /^\/$query/ });
+	return unless &checkEval($@);
+
+	$contents{$package}{$file} = 1;
+	$found++;
+    }
+    close IN;
+
+    my $pkg;
+
+    ### send results with dcc.
+    if ($dccsend) {
+	if (exists $::dcc{'SEND'}{$::who}) {
+	    &::msg($::who, "DCC already active!");
+	    return;
+	}
+
+	if (!scalar %contents) {
+	    &::msg($::who,"search returned no results.");
+	    return;
+	}
+
+	my $file = "$::param{tempDir}/$::who.txt";
+	if (!open OUT, ">$file") {
+	    &::ERROR("Fink: cannot write file for dcc send.");
+	    return;
+	}
+
+	foreach $pkg (keys %contents) {
+	    foreach (keys %{ $contents{$pkg} }) {
+		# TODO: correct padding.
+		print OUT "$_\t\t\t$pkg\n";
+	    }
+	}
+	close OUT;
+
+	&::shmWrite($::shm, "DCC SEND $::who $file");
+
+	return;
+    }
+
+    &::status("Fink: $found contents results found.");
+
+    my @list;
+    foreach $pkg (keys %contents) {
+	my @tmplist = &::fixFileList(keys %{ $contents{$pkg} });
+	my @sublist = sort { length $a <=> length $b } @tmplist;
+
+	pop @sublist while (scalar @sublist > 3);
+
+	$pkg =~ s/\,/\037\,\037/g;	# underline ','.
+	push(@list, "(". join(', ',@sublist) .") in $pkg");
+    }
+    # sort the total list from shortest to longest...
+    @list = sort { length $a <=> length $b } @list;
+
+    # show how long it took.
+    my $delta_time = &::timedelta($start_time);
+    &::status(sprintf("Fink: %.02f sec to complete query.", $delta_time)) if ($delta_time > 0);
+
+    my $prefix = "Fink Search of '$query' ";
+    if (scalar @list) {	# @list.
+	&::pSReply( &::formListReply(0, $prefix, @list) );
+
+    } else {		# !@list.
+	&::DEBUG("deb: ok, !\@list, searching desc for '$query'.") if ($debug);
+	my @list = &searchDesc($query);
+
+	if (!scalar @list) {
+	    my $prefix = "Fink Package/File/Desc Search of '$query' ";
+	    &::pSReply( &::formListReply(0, $prefix, ) );
+
+	} elsif (scalar @list == 1) {	# list = 1.
+	    &::DEBUG("deb: list == 1; showing package info of '$list[0]'.");
+	    &infoPackages("info", $list[0]);
+
+	} else {				# list > 1.
+	    my $prefix = "Fink Desc Search of '$query' ";
+	    &::pSReply( &::formListReply(0, $prefix, @list) );
+	}
+    }
+}
+
+####
+# Usage: &searchAuthor($query);
+sub searchAuthor {
+    my ($dist, $query)	= &getDistroFromStr($_[0]);
+    &::DEBUG("deb: searchAuthor: dist => '$dist', query => '$query'.") if ($debug);
+    $query =~ s/^\s+|\s+$//g;
+
+    # start of search.
+    my $start_time = &::timeget();
+    &::status("Fink: starting author search.");
+
+    my $files;
+    my ($bad,$good) = (0,0);
+    my %urls = %urlpackages;
+
+    foreach (keys %urlpackages) {
+	s/##DIST/$dist/g;
+
+	if (! -f "$fink_dir/$_" ) {
+	    $bad++;
+	    next;
+	}
+
+	$good++;
+	$files .= " ".$_;
+    }
+
+    &::DEBUG("deb: good = $good, bad = $bad...") if ($debug);
+
+    if ($good == 0 and $bad != 0) {
+	my %urls = &fixDist($dist, %urlpackages);
+	&::DEBUG("deb: download 2.");
+
+	if (!&FinkDownload($dist, %urls)) {
+	    &::ERROR("Fink(sA): could not download files.");
+	    return;
+	}
+    }
+
+    my (%maint, %pkg, $package);
+    open(IN,"zgrep -Eh '^Package|^Maintainer' $files |");
+    while (<IN>) {
+	if (/^Package: (\S+)$/) {
+	    $package = $1;
+
+	} elsif (/^Maintainer: (.*) \<(\S+)\>$/) {
+	    my($name,$email) = ($1,$2);
+	    if ($package eq "") {
+		&::DEBUG("deb: sA: package == NULL.");
+		next;
+	    }
+	    $maint{$name}{$email} = 1;
+	    $pkg{$name}{$package} = 1;
+	    $package = "";
+
+	} else {
+	    &::WARN("fink: invalid line: '$_' (1).");
+	}
+    }
+    close IN;
+
+    my %hash;
+    # TODO: can we use 'map' here?
+    foreach (grep /\Q$query\E/i, keys %maint) {
+	$hash{$_} = 1;
+    }
+
+    # TODO: should we only search email if '@' is used?
+    if (scalar keys %hash < 15) {
+	my $name;
+
+	foreach $name (keys %maint) {
+	    my $email;
+
+	    foreach $email (keys %{ $maint{$name} }) {
+		next unless ($email =~ /\Q$query\E/i);
+		next if (exists $hash{$name});
+		$hash{$name} = 1;
+	    }
+	}
+    }
+
+    my @list = keys %hash;
+    if (scalar @list != 1) {
+	my $prefix = "Fink Author Search of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, @list) );
+	return 1;
+    }
+
+    &::DEBUG("deb: showing all packages by '$list[0]'...") if ($debug);
+
+    my @pkg = sort keys %{ $pkg{$list[0]} };
+
+    # show how long it took.
+    my $delta_time = &::timedelta($start_time);
+    &::status(sprintf("Fink: %.02f sec to complete query.", $delta_time)) if ($delta_time > 0);
+
+    my $email	= join(', ', keys %{ $maint{$list[0]} });
+    my $prefix	= "Fink Packages by $list[0] \002<\002$email\002>\002 ";
+    &::pSReply( &::formListReply(0, $prefix, @pkg) );
+}
+
+####
+# Usage: &searchDesc($query);
+sub searchDesc {
+    my ($dist, $query)	= &getDistroFromStr($_[0]);
+    &::DEBUG("deb: searchDesc: dist => '$dist', query => '$query'.") if ($debug);
+    $query =~ s/^\s+|\s+$//g;
+
+    # start of search.
+    my $start_time = &::timeget();
+    &::status("Fink: starting desc search.");
+
+    my $files;
+    my ($bad,$good) = (0,0);
+    my %urls = %urlpackages;
+
+    foreach (keys %urlpackages) {
+	s/##DIST/$dist/g;
+
+	if (! -f "$fink_dir/$_" ) {
+	    $bad++;
+	    next;
+	}
+
+	$good++;
+	$files .= " $fink_dir/$_";
+    }
+
+    &::DEBUG("deb(2): good = $good, bad = $bad...") if ($debug);
+
+    if ($good == 0 and $bad != 0) {
+	my %urls = &fixDist($dist, %urlpackages);
+	&::DEBUG("deb: download 2c.") if ($debug);
+
+	if (!&FinkDownload($dist, %urls)) {
+	    &::ERROR("deb: sD: could not download files.");
+	    return;
+	}
+    }
+
+    my $regex	= $query;
+    $regex	=~ s/\./\\./g;
+    $regex	=~ s/\*/\\S*/g;
+    $regex	=~ s/\?/./g;
+
+    my (%desc, $package);
+    open(IN,"zgrep -Eh '^Package|^Description' $files |");
+    while (<IN>) {
+	if (/^Package: (\S+)$/) {
+	    $package = $1;
+	} elsif (/^Description: (.*)$/) {
+	    my $desc = $1;
+	    next unless (eval { $desc =~ /$regex/i });
+	    return unless &checkEval($@);
+
+	    if ($package eq "") {
+		&::WARN("sD: package == NULL?");
+		next;
+	    }
+
+	    $desc{$package} = $desc;
+	    $package = "";
+
+	} else {
+	    &::WARN("fink: invalid line: '$_'. (2)");
+	}
+    }
+    close IN;
+
+    # show how long it took.
+    my $delta_time = &::timedelta($start_time);
+    &::status(sprintf("Fink: %.02f sec to complete query.", $delta_time)) if ($delta_time > 0);
+
+    return keys %desc;
+}
+
+##############################
+# FINK PACKAGE INFO FUNCTIONS.
+#########
+
+# Usage: &getPackageInfo($query,$file);
+sub getPackageInfo {
+    my ($package, $file) = @_;
+
+    if (! -f $file) {
+	&::status("gPI: file $file does not exist?");
+	return 'NULL';
+    }
+
+    my $found = 0;
+    my (%pkg, $pkg);
+
+    open(IN, "zcat $file 2>&1 |");
+
+    my $done = 0;
+    while (!eof IN) {
+	$_ = <IN>;
+
+	next if (/^ \S+/);	# package long description.
+
+	# package line.
+	if (/^Package: (.*)\n$/) {
+	    $pkg = $1;
+	    if ($pkg =~ /^$package$/i) {
+		$found++;	# we can use pkg{'package'} instead.
+		$pkg{'package'} = $pkg;
+	    }
+
+	    next;
+	}
+
+	if ($found) {
+	    chop;
+
+	    if (/^Version: (.*)$/) {
+		$pkg{'version'}		= $1;
+	    } elsif (/^Priority: (.*)$/) {
+		$pkg{'priority'}	= $1;
+	    } elsif (/^Section: (.*)$/) {
+		$pkg{'section'}		= $1;
+	    } elsif (/^Size: (.*)$/) {
+		$pkg{'size'}		= $1;
+	    } elsif (/^Installed-Size: (.*)$/i) {
+		$pkg{'installed'}	= $1;
+	    } elsif (/^Description: (.*)$/) {
+		$pkg{'desc'}		= $1;
+	    } elsif (/^Filename: (.*)$/) {
+		$pkg{'find'}		= $1;
+	    } elsif (/^Pre-Depends: (.*)$/) {
+		$pkg{'depends'}		= "pre-depends on $1";
+	    } elsif (/^Depends: (.*)$/) {
+		if (exists $pkg{'depends'}) {
+		    $pkg{'depends'} .= "; depends on $1";
+		} else {
+		    $pkg{'depends'} = "depends on $1";
+		}
+	    } elsif (/^Maintainer: (.*)$/) {
+		$pkg{'maint'} = $1;
+	    } elsif (/^Provides: (.*)$/) {
+		$pkg{'provides'} = $1;
+	    } elsif (/^Suggests: (.*)$/) {
+		$pkg{'suggests'} = $1;
+	    } elsif (/^Conflicts: (.*)$/) {
+		$pkg{'conflicts'} = $1;
+	    }
+
+###	    &::DEBUG("=> '$_'.");
+	}
+
+	# blank line.
+	if (/^$/) {
+	    undef $pkg;
+	    last if ($found);
+	    next;
+	}
+
+	next if (defined $pkg);
+    }
+
+    close IN;
+
+    %pkg;
+}
+
+# Usage: &infoPackages($query,$package);
+sub infoPackages {
+    my ($query,$dist,$package) = ($_[0], &getDistroFromStr($_[1]));
+
+    &::status("Fink: Searching for package '$package' in '$dist'.");
+
+    # download packages file.
+    # hrm...
+    my %urls = &fixDist($dist, %urlpackages);
+
+    # check if the package is valid.
+    my @files = &validPackage($package, $dist);
+    if (!scalar @files) {
+	&::msg($::who, "Package '$package' does not exist.");
+	return 0;
+    }
+
+    if (scalar @files > 1) {
+	&::WARN("same package in more than one file; random.");
+	&::DEBUG("THIS SHOULD BE FIXED SOMEHOW!!!");
+	$files[0] = &::getRandom(@files);
+    }
+
+    if (! -f $files[0]) {
+	&::WARN("files[0] ($files[0]) doesn't exist.");
+	&::msg($::who, "WARNING: $files[0] does not exist? FIXME");
+	return 'NULL';
+    }
+
+    my $found = 0;
+    my $file = $files[0];
+    my ($pkg);
+
+    ### TODO: use fe, dump to a hash. if only one version of the package
+    ###		exists. do as normal otherwise list all versions.
+    if (! -f $file) {
+	&::ERROR("D:iP: file '$file' DOES NOT EXIST!!! should never happen.");
+	return 0;
+    }
+    my %pkg = &getPackageInfo($package, $file);
+
+    # 'fm'-like output.
+    if ($query eq "info") {
+	if (scalar keys %pkg > 5) {
+	    $pkg{'info'}  = "\002(\002". $pkg{'desc'} ."\002)\002";
+	    $pkg{'info'} .= ", section ".$pkg{'section'};
+	    $pkg{'info'} .= ", is ".$pkg{'priority'};
+#	    $pkg{'info'} .= ". Version: \002$pkg{'version'}\002";
+	    $pkg{'info'} .= ". Version: \002$pkg{'version'}\002 ($dist)";
+	    $pkg{'info'} .= ", Packaged size: \002". int($pkg{'size'}/1024) ."\002 kB";
+	    $pkg{'info'} .= ", Installed size: \002$pkg{'installed'}\002 kB";
+
+	} else {
+	    &::DEBUG("deb: running finkCheck() due to problems (".scalar(keys %pkg).").");
+	    &finkCheck();
+	    &::DEBUG("deb: end of finkCheck()");
+
+	    &::msg($::who,"Fink: Package appears to exist but I could not retrieve info about it...");
+	    return;
+	}
+    } 
+
+    if (!exists $pkg{$query}) {
+	if ($query eq "suggests") {
+	    $pkg{$query} = "has no suggestions";
+	} elsif ($query eq "conflicts") {
+	    $pkg{$query} = "does not conflict with any other package";
+	} elsif ($query eq "depends") {
+	    $pkg{$query} = "does not depend on anything";
+	} elsif ($query eq "maint") {
+	    $pkg{$query} = "has no maintainer";
+	} else {
+	    $pkg{$query} = "has nothing about $query";
+	}
+    }
+
+    &::pSReply("$package: $pkg{$query}");
+}
+
+# Usage: &infoStats($dist);
+sub infoStats {
+    my ($dist)	= @_;
+    $dist	= &getDistro($dist);
+    return unless (defined $dist);
+
+    &::DEBUG("deb: infoS: dist => '$dist'.");
+
+    # download packages file if needed.
+    my %urls = &fixDist($dist, %urlpackages);
+    &::DEBUG("deb: download 4.");
+    if (!&FinkDownload($dist, %urls)) {
+	&::WARN("Fink(iS): could not download ANY files.");
+	&::msg($::who, "Fink(iS): internal error.");
+	return;
+    }
+
+    my %stats;
+    my %total;
+    my $file;
+    foreach $file (keys %urlpackages) {
+	$file =~ s/##DIST/$dist/g;
+	&::DEBUG("deb: file => '$file'.");
+	if (exists $stats{$file}{'count'}) {
+	    &::DEBUG("deb: hrm... duplicate open with $file???");
+	    next;
+	}
+
+	open(IN, "zcat $file 2>&1 |");
+
+	if (! -e $file) {
+	    &::DEBUG("deb: iS: $file does not exist.");
+	    next;
+	}
+
+	while (!eof IN) {
+	    $_ = <IN>;
+
+	    next if (/^ \S+/);	# package long description.
+
+	    if (/^Package: (.*)\n$/) {		# counter.
+		$stats{$file}{'count'}++;
+		$total{'count'}++;
+	    } elsif (/^Maintainer: .* <(\S+)>$/) {
+		$stats{$file}{'maint'}{$1}++;
+		$total{'maint'}{$1}++;
+	    } elsif (/^Size: (.*)$/) {		# compressed size.
+		$stats{$file}{'csize'}	+= $1;
+		$total{'csize'}		+= $1;
+	    } elsif (/^i.*size: (.*)$/i) {	# installed size.
+		$stats{$file}{'isize'}	+= $1;
+		$total{'isize'}		+= $1;
+	    }
+
+###	    &::DEBUG("=> '$_'.");
+	}
+	close IN;
+    }
+
+    ### TODO: don't count ppl with multiple email addresses.
+
+    &::pSReply(
+	"Fink Distro Stats on $dist... ".
+	"\002$total{'count'}\002 packages, ".
+	"\002".scalar(keys %{ $total{'maint'} })."\002 maintainers, ".
+	"\002". int($total{'isize'}/1024)."\002 MB installed size, ".
+	"\002". int($total{'csize'}/1024/1024)."\002 MB compressed size."
+    );
+
+### TODO: do individual stats? if so, we need _another_ arg.
+#    foreach $file (keys %stats) {
+#	foreach (keys %{ $stats{$file} }) {
+#	    &::DEBUG("  '$file' '$_' '$stats{$file}{$_}'.");
+#	}
+#    }
+
+    return;
+}
+
+###
+# HELPER FUNCTIONS FOR INFOPACKAGES...
+###
+
+# Usage: &generateIndex();
+sub generateIndex {
+    my (@dists)	= @_;
+    &::DEBUG("D: generateIndex($dists[0]) called!");
+    if (!scalar @dists or $dists[0] eq '') {
+	&::ERROR("gI: no dists to generate index.");
+	return 1;
+    }
+
+    foreach (@dists) {
+	my $dist = &getDistro($_); # incase the alias is returned, possible?
+	my $idx  = $fink_dir."/Packages-$dist.idx";
+
+	# TODO: check if any of the Packages file have been updated then
+	#	regenerate it, even if it's not stale.
+	# TODO: also, regenerate the index if the packages file is newer
+	#	than the index.
+	next unless (&::isStale($idx, $refresh));
+
+	if (/^unstable$/i) {
+	    &::DEBUG("deb: Copying old index of unstable to -old");
+	    system("cp $idx $idx-old");
+	}
+
+	&::DEBUG("deb: gIndex: calling FinkDownload($dist, ...).") if ($debug);
+	&FinkDownload($dist, &fixDist($dist, %urlpackages) );
+
+	&::status("Fink: generating index for '$dist'.");
+	if (!open OUT, ">$idx") {
+	    &::ERROR("cannot write to $idx.");
+	    return 0;
+	}
+
+	my $packages;
+	foreach $packages (keys %urlpackages) {
+	    $packages =~ s/##DIST/$dist/;
+	    $packages =  "$fink_dir/$packages";
+
+	    if (! -e $packages) {
+		&::ERROR("gIndex: '$packages' does not exist?");
+		next;
+	    }
+
+	    print OUT "*$packages\n";
+	    open(IN,"zcat $packages |");
+
+	    while (<IN>) {
+		next unless (/^Package: (.*)\n$/);
+		print OUT $1."\n";
+	    }
+	    close IN;
+	}
+	close OUT;
+    }
+
+    return 1;
+}
+
+# Usage: &validPackage($package, $dist);
+sub validPackage {
+    my ($package,$dist) = @_;
+    my @files;
+    my $file;
+
+    ### this majorly sucks, we need some standard in place.
+    # why is this needed... need to investigate later.
+    my $olddist	= $dist;
+    $dist = &getDistro($dist);
+
+    &::DEBUG("deb: validPackage($package, $dist) called.") if ($debug);
+
+    my $error = 0;
+    while (!open IN, $fink_dir."/Packages-$dist.idx") {
+	if ($error) {
+	    &::ERROR("Packages-$dist.idx does not exist (#1).");
+	    return;
+	}
+
+	&generateIndex($dist);
+
+	$error++;
+    }
+
+    my $count = 0;
+    while (<IN>) {
+	if (/^\*(.*)\n$/) {
+	    $file = $1;
+	    next;
+	}
+
+	if (/^\Q$package\E\n$/) {
+	    push(@files,$file);
+	}
+	$count++;
+    }
+    close IN;
+
+    &::VERB("vP: scanned $count items in index.",2);
+
+    return @files;
+}
+
+sub searchPackage {
+    my ($dist, $query) = &getDistroFromStr($_[0]);
+    my $file = $fink_dir."/Packages-$dist.idx";
+    my @files;
+    my $error	= 0;
+    my $warn	= ($query =~ tr/A-Z/a-z/) ? 1 : 0;
+
+    &::status("Fink: Search package matching '$query' in '$dist'.");
+    unlink $file if ( -z $file );
+
+    while (!open IN, $file) {
+	if ($error) {
+	    &::ERROR("could not generate index ($file)!");
+	    return;
+	}
+
+	$error++;
+	&::DEBUG("deb: should we be doing this?");
+	&generateIndex(($dist));
+    }
+
+    while (<IN>) {
+	chop;
+
+	if (/^\*(.*)$/) {
+	    $file = $1;
+
+	    if (&::isStale($file, $refresh)) {
+		&::DEBUG("deb: STALE $file! regen.") if ($debug);
+		&generateIndex(($dist));
+###		@files = searchPackage("$query $dist");
+		&::DEBUG("deb: EVIL HACK HACK HACK.") if ($debug);
+		last;
+	    }
+
+	    next;
+	}
+
+	if (/\Q$query\E/) {
+	    push(@files,$_);
+	}
+    }
+    close IN;
+
+    if (scalar @files and $warn) {
+	&::msg($::who, "searching for package name should be fully lowercase!");
+    }
+
+    return @files;
+}
+
+sub getDistro {
+    my $dist = $_[0];
+
+    if (!defined $dist or $dist eq "") {
+	&::DEBUG("deb: gD: dist == NULL; dist = defaultdist.");
+	$dist = $defaultdist;
+    }
+
+    if ($dist =~ /^(slink|hamm|rex|bo)$/i) {
+	&::DEBUG("deb: deprecated version ($dist).");
+	&::msg($::who, "Fink: deprecated distribution version.");
+	return;
+    }
+
+    if (exists $dists{$dist}) {
+	&::VERB("gD: returning dists{$dist} ($dists{$dist})",2);
+	return $dists{$dist};
+
+    } else {
+	if (!grep /^\Q$dist\E$/i, %dists) {
+	    &::msg($::who, "invalid dist '$dist'.");
+	    return;
+	}
+
+	&::VERB("gD: returning $dist (no change or conversion)",2);
+	return $dist;
+    }
+}
+
+sub getDistroFromStr {
+    my ($str) = @_;
+    my $dists	= join '|', %dists;
+    my $dist	= $defaultdist;
+
+    if ($str =~ s/\s+($dists)$//i) {
+	$dist = &getDistro(lc $1);
+	$str =~ s/\\+$//;
+    }
+    $str =~ s/\\([\$\^])/$1/g;
+
+    return($dist,$str);
+}
+
+sub fixDist {
+    my ($dist, %urls) = @_;
+    my %new;
+    my ($key,$val);
+
+    while (($key,$val) = each %urls) {
+	$key =~ s/##DIST/$dist/;
+	$val =~	s/##DIST/$dist/;
+	### TODO: what should we do if the sar wasn't done.
+	$new{$fink_dir."/".$key} = $val;
+    }
+
+    return %new;
+}
+
+sub FinkFind {
+    # HACK! HACK! HACK!
+    my ($str) = @_;
+    my ($dist, $query) = &getDistroFromStr($str);
+    my @results = sort &searchPackage($str);
+
+    if (!scalar @results) {
+	&::Forker("fink", sub { &searchContents($str); } );
+    } elsif (scalar @results == 1) {
+	&::status("searchPackage returned one result; getting info of package instead!");
+	&::Forker("fink", sub { &infoPackages("info", "$results[0] $dist"); } );
+    } else {
+	my $prefix = "Fink Package Listing of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, @results) );
+    }
+}
+
+sub finkCheck {
+    my $error	= 0;
+
+    &::status("finkCheck() called.");
+
+    ### TODO: remove the following loop (check if dir exists before)
+    while (1) {
+	last if (opendir(FINK, $fink_dir));
+
+	if ($error) {
+	    &::ERROR("dC: cannot opendir fink.");
+	    return;
+	}
+
+	mkdir $fink_dir, 0755;
+	$error++;
+    }
+
+    my $retval = 0;
+    my $file;
+    while (defined($file = readdir FINK)) {
+	next unless ($file =~ /(gz|bz2)$/);
+
+	my $exit = system("gzip -t '$fink_dir/$file'");
+	next unless ($exit);
+	&::DEBUG("deb: hmr... => ".(time() - (stat($file))[8])."'.");
+	next unless (time() - (stat($file))[8] > 3600);
+
+	&::DEBUG("deb: dC: exit => '$exit'.");
+	&::WARN("dC: '$fink_dir/$file' corrupted? deleting!");
+	unlink $fink_dir."/".$file;
+	$retval++;
+    }
+
+    return $retval;
+}
+
+sub checkEval {
+    my($str)	= @_;
+
+    if ($str) {
+	&::WARN("cE: $str");
+	return 0;
+    } else {
+	return 1;
+    }
+}
+
+sub searchDescFE {
+#    &::DEBUG("deb: FE called for searchDesc");
+    my ($query)	= @_;
+    my @list = &searchDesc($query);
+
+    if (!scalar @list) {
+	my $prefix = "Fink Desc Search of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, ) );
+    } elsif (scalar @list == 1) {	# list = 1.
+	&::DEBUG("deb: list == 1; showing package info of '$list[0]'.");
+	&infoPackages("info", $list[0]);
+    } else {				# list > 1.
+	my $prefix = "Fink Desc Search of '$query' ";
+	&::pSReply( &::formListReply(0, $prefix, @list) );
+    }
+}
+
+1;
diff -ruN blootbot.orig/src/Modules/Units.pl blootbot/src/Modules/Units.pl
--- blootbot.orig/src/Modules/Units.pl	Tue Jan 21 18:46:22 2003
+++ blootbot/src/Modules/Units.pl	Tue Jan 21 18:46:10 2003
@@ -49,7 +49,7 @@
 ################################################################
 
 { my $defs_read = 0;
-  $defs_read += read_defs("$::bot_data_dir/unittab");
+  $defs_read += read_defs("$::bot_data_dir/blootbot.unittab");
 
   unless ($defs_read) {
     &::ERROR("Could not read any of the initialization files UNITTAB");
diff -ruN blootbot.orig/src/core.pl blootbot/src/core.pl
--- blootbot.orig/src/core.pl	Tue Jan 21 18:46:20 2003
+++ blootbot/src/core.pl	Tue Jan 21 21:45:11 2003
@@ -384,11 +384,18 @@
     &openLog();		# write, append.
     &status("--- Started logging.");
 
-    foreach ("debian") {
+    foreach ("debien") {
 	my $dir = "$bot_base_dir/$_/";
 	next if ( -d $dir);
 	&status("Making dir $_");
 	mkdir $dir, 0755;
+    }
+
+    foreach ("fink") {
+        my $dir = "$bot_base_dir/$_/";
+        next if ( -d $dir);
+        &status("Making dir $_");
+        mkdir $dir, 0755;
     }
 
     # read.
diff -ruN blootbot.orig/src/modules.pl blootbot/src/modules.pl
--- blootbot.orig/src/modules.pl	Tue Jan 21 18:46:23 2003
+++ blootbot/src/modules.pl	Tue Jan 21 21:45:55 2003
@@ -24,6 +24,7 @@
 	"countdown"	=> "Countdown.pl",
 	"debian"	=> "Debian.pl",
 	"debianExtra"	=> "DebianExtra.pl",
+	"fink"		=> "Fink.pl",
 	"dict"		=> "Dict.pl",
 	"dumpvars"	=> "DumpVars.pl",
 	"symdump"	=> "DumpVars2.pl",

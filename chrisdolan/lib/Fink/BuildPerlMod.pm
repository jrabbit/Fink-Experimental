package Fink::BuildPerlMod;

use warnings;
use strict;
use File::Slurp;

our $VERSION = "1.33";

my $disclaimer = <<"EOF";
# **AUTOGENERATED - UNTESTED**
# This package was auto-created by $0
# Please validate and then REMOVE THESE COMMENTS

EOF

# Translation from Module::Build license tags to Fink words
#   From: http://search.cpan.org/dist/Module-Build/lib/Module/Build.pm#license
#   To:   http://fink.sourceforge.net/doc/packaging/policy.php#licenses
my %licenses = (
                perl         => "Artistic/GPL",
                gpl          => "GPL",
                lgpl         => "LGPL",
                bsd          => "BSD",
                artistic     => "Artistic",
                open_source  => "OSI-Approved",
                unrestricted => "Restrictive/Distributable",
                restrictive  => "Restrictive", 
                );

my %special_cases = (
                     "libwww-perl" => "libwww",
                     "ole-storage_lite" => "ole-storagelite",
                     "parse-recdescent" => "rec-descent",
                     );

sub new
{
   my $pkg = shift;
   my %flags = (@_);

   my $self = bless({
      %flags,
   }, $pkg);

   $self->{prefix} ||= "/sw";
   if (!-d $self->{prefix})
   {
      die "No such directory $$self->{prefix} for Fink prefix\n";
   }

   if (!$self->{cpanhost} && -f $self->{prefix}."/etc/fink.conf")
   {
      my $conf = read_file("/sw/etc/fink.conf");
      if ($conf =~ /^Mirror-cpan: (.*)$/m)
      {
         $self->{cpanhost} = $1;
         #print "CPAN mirror: $$self{cpanhost}\n" if ($self->{verbose});
      }
   }

   if ($self->{perltypes} && grep({my @p=split /\./,$_; $_=~/[^\d\.]/ || @p<3 || $p[0] ne "5" || $p[1]<8 }
                                  split(/\s+/, $self->{perltypes}))>0)
   {
      die "Invalid --perltypes.  Must be a list of perlversions, each no less than 5.8.0.\n";
   }

   require Fink::CPANPLUS;
   $self->{cp} = Fink::CPANPLUS->new(
                                     verbose => $self->{verbose},
                                     prereqs => $self->{prereqs},
                                     );
   if ($self->{cpanhost})
   {
      unless ($self->{cp}->set_host($self->{cpanhost}))
      {
         die "Failed to set CPAN URL\n";
      }
   }

   return $self;
}

sub verbose
{
   my $self = shift;
   return $self->{verbose};
}

sub perlmod_dir
{
   my $self = shift;
   return $self->{prefix}."/fink/dists/".$self->{tree}."/finkinfo/libs/perlmods";
}
sub perllang_dir
{
   my $self = shift;
   return $self->{prefix}."/fink/dists/".$self->{tree}."/finkinfo/languages";
}

sub build_pkg
{
   my $self = shift;
   my $modname = shift;
   my $overwrite = shift;

   my $mod = $self->get_module($modname);
   return undef if (!$mod);

   my $pkg = lc($mod->package_name)."-pm";
   my $file = $self->perlmod_dir."/$pkg.info";
   if (-f $file && !$overwrite)
   {
      print "package already exists\n" if ($self->verbose);
      print "  $file\n" if ($self->verbose);
      return undef;
   }

   my $data = $self->get_pkg_details($mod);
   return undef if (!$data);

   write_file($file, $disclaimer . $self->to_string($data) . "\n");
   print "Wrote file $file\n" if ($self->{verbose});

   return 1;
}

sub diff_pkg
{
   my $self = shift;
   my $modname = shift;

   my ($old, $new) = $self->_get_old_new($modname);
   return undef unless ($old && $new);

   # simplify:
   if ($old->{Info2})
   {
      $old = $old->{Info2};
   }
   if ($new->[0] eq "Info2")
   {
      $new = $new->[1];
   }

   my @diffs = $self->_diff_pkg($old, $new);
   return join("\n", @diffs)."\n";
}

sub update_pkg
{
   my $self = shift;
   my $modname = shift;
   my $newversiononly = shift;

   my ($old, $new, $file) = $self->_get_old_new($modname, $newversiononly);
   return undef unless ($old && $new);

   my $result =
       $self->update_revision($new,
                              $old->{Version} || $old->{Info2}->{Version},
                              $old->{Revision} || $old->{Info2}->{Revision});

   write_file($file.".new", $disclaimer . $self->to_string($new, $old) . "\n");
   print "Wrote file $file.new\n" if ($self->{verbose});

   return 1;
}

sub update_revision
{
   # Returns a flag indicating if the Revision changed:
   # 0: couldn't process data
   # 1: just incremented revision
   # 2: new version, reset revision to 1

   my $self = shift;
   my $data = shift;
   my $oldversion = shift;
   my $oldrevision = shift;

   return 0 unless ($data && $oldversion && $oldrevision);
   my %hash = @$data;
   if ($hash{Version})
   {
      if ($hash{Version} eq $oldversion)
      {
         for (my $i=0; $i<@$data; $i+=2)
         {
            if ($data->[$i] eq "Revision")
            {
               $data->[$i+1] = $oldrevision+1;
               return 1;
            }
         }
      }
      else
      {
         # Revision should already be 1
         return 2;
      }
   }
   else
   {
      for (my $i=1; $i<@$data; $i+=2)
      {
         if (ref $data->[$i])
         {
            my $result = $self->update_revision($data->[$i],
                                                $oldversion, $oldrevision);
            return $result if ($result != 0);
         }
      }
   }
   return 0;
}

sub _get_old_new
{
   my $self = shift;
   my $modname = shift;
   my $newversiononly = shift;

   my $mod = $self->get_module($modname);
   return () if (!$mod);

   my $pkg = lc($mod->package_name);
   $pkg = ($special_cases{$pkg} || $pkg)."-pm";
   my $file = $self->perlmod_dir."/$pkg.info";
   if (!-f $file)
   {
      print "package does not exist\n" if ($self->verbose);
      print "  $file\n" if ($self->verbose);
      return ();
   }

   my $old = $self->from_string(scalar read_file($file));
   return () if (!$old);

   if ($newversiononly)
   {
      my $oldversion = $self->get_version_from_hash($old);
      my $newversion = $mod->package_version();
      return () if ($oldversion eq $newversion);
   }

   my $new = $self->get_pkg_details($mod);
   return () if (!$new);

   return ($old, $new, $file);
}

sub get_version_from_hash
{
   my $self = shift;
   my $hash = shift;

   return $hash->{Version} if ($hash->{Version});

   foreach my $h (values %$hash)
   {
      if (ref($h) && ref($h) eq "HASH")
      {
         my $v = $self->get_version_from_hash($h);
         return $v if ($v);
      }
   }
   return undef;
}

sub _diff_pkg
{
   my $self = shift;
   my $old = shift;
   my $new = shift;

   my @diffs;
   for (my $i=0; $i<@$new; $i+=2)
   {
      my $key = $new->[$i];
      my $val = $new->[$i+1];
      if (!exists $old->{$key})
      {
         unless ($val eq "")
         {
            push @diffs, "old - ";
            if (ref $val)
            {
               push @diffs, "new - ".$self->to_string([$key => $val]);
            }
            else
            {
               push @diffs, "new - $key: $val";
            }
         }
      }
      else
      {
         my $oldval = delete $old->{$key};
         if (ref $val)
         {
            my @d = $self->_diff_pkg($oldval, $val);
            s/ - / - $key./ for (@d);
            push @diffs, @d;
         }
         elsif ($val ne $oldval)
         {
            push @diffs, "old - $key: $oldval";
            push @diffs, "new - $key: $val";
         }
      }
   }
   foreach my $key (sort keys %$old)
   {
      my $val = $old->{$key};
      if (ref $val)
      {
         push @diffs, "old - ".$self->to_string([$key => $val]);
      }
      else
      {
         push @diffs, "old - $key: $val";
      }
      push @diffs, "new - ";
   }

   return @diffs;
}

sub get_module
{
   my $self = shift;
   my $modname = shift;

   # Remove path
   $modname =~ s,.*/,,;
   # Remove Fink suffixes
   $modname =~ s/-pm(5\d\d)?(-[\d\.]+-\d+)?(\.info|\.patch)?$//;

   # Fix special cases
   my %spec = reverse %special_cases;
   $modname = $spec{$modname} || $modname;

   print "*** Search for $modname ***\n" if ($self->verbose);
   my $mod = $self->{cp}->get_module($modname);

   if (!$mod)
   {
      print "Not found\n" if ($self->verbose);
      return undef;
   }
   return $mod;
}

sub get_pkg_details
{
   my $self = shift;
   my $mod = shift;

   my $pkg = lc($mod->package_name)."-pm";

   if ($self->{details})
   {
      my $details = $mod->details;
      for my $key (keys %$details)
      {
         print "$key: $$details{$key}\n";
      }
   }

   my $bin = $self->{bin} || $mod->bin();
   my $typepkg = $self->{typepkg} || $mod->has_xs();  # TODO extend based on depends, etc
   my @perlversions = sort split /\s+/, $self->{perltypes};
   my %libs = (
               depends        => $mod->depends(),
               builddepends   => $mod->builddepends(),
               recommends     => $mod->recommends(),
               conflicts      => $mod->conflicts(),
               buildconflicts => $mod->buildconflicts(),
               );
   foreach my $type (qw(recommend conflicts buildconflicts))
   {
      my %l;
      foreach my $dep (keys %{$libs{$type}})
      {
         my ($deppkg) = $self->finkify_dep_pkg($dep, @perlversions);
         if ($deppkg)
         {
            $l{$deppkg} = $libs{$type}->{$dep};
         }
      }
      $libs{$type} = \%l;
   }
   foreach my $type (qw(depends builddepends))
   {
      my %l;
      foreach my $dep (keys %{$libs{$type}})
      {
         my ($deppkg, $deptypepkg, $depvers) = $self->finkify_dep_pkg($dep, @perlversions);
         if ($deppkg)
         {
            $l{$deppkg} = $libs{$type}->{$dep};
            $typepkg ||= $deptypepkg;
            if ("@perlversions" ne "@$depvers")
            {
               print "Reducing versions to (@$depvers) because of $deppkg\n" if ($self->verbose);
               @perlversions = @$depvers;
            }
         }
      }
      $libs{$type} = \%l;
   }

   if ($typepkg)
   {
      $libs{depends}->{"perl\%type_pkg[perl]-core"} = 0;
   }

   # Do we need a patchscript for COPYRIGHT?
   my $patchscript = undef;
   my @docfiles = $mod->doc_files();
   my $licensefile = $mod->license_filename();
   if ($licensefile && grep({$_ eq $licensefile} @docfiles) == 0)
   {
      my $content = read_file($mod->extract_dir()."/".$licensefile);
      if ($content =~ /=head\d\s+(licen[cs]e|licensing|copyright)/is)
      {
         $patchscript = 'perl -0 -pe\'s/^.*=head\\d\\s+('.$1.'.*?)(=head\\d.*|=cut.*|)$/$1/is\' '.$licensefile.' > COPYRIGHT';
         push @docfiles, "COPYRIGHT";
      }
      else
      {
         $patchscript = "echo 'Please write a patchscript that extracts the copyright from $licensefile'";
      }
   }
   
   # Prepare the .info fields.  Note that we use "_" instead of "-"
   # in field names to keep perl happy.
   my @data = (
               Package    => $pkg.($typepkg ? "%type_pkg[perl]" : ""),
               Version    => $mod->package_version,
               Revision   => "1",
               Source     => ("mirror:cpan:" . $mod->path . "/" . 
                              $mod->package_name . "-%v." . 
                              $mod->package_extension),
               Source_MD5 => $mod->checksum,
               Type       => "perl" . ($typepkg ? " (@perlversions)" : ""),
               ($patchscript ? (PatchScript => $patchscript) : ()),
               UpdatePOD  => "true",
               Depends        => $self->format_libs($libs{depends}),
               BuildDepends   => $self->format_libs($libs{builddepends}),
               Conflicts      => $self->format_libs($libs{conflicts}),
               BuildConflicts => $self->format_libs($libs{buildconflicts}),
               Recommends     => $self->format_libs($libs{recommends}),
               DocFiles    => join(" ", @docfiles),
               License     => $licenses{$mod->license()||""},
               Description => $mod->description,
               Maintainer  => $self->{maintainer},
               Homepage    => "http://search.cpan.org/dist/".$mod->package_name,
               DescPackaging => join("\n",
                                     "Report bugs to the maintainer or the CPAN bug tracker:",
                                     $self->{bugurl}.$mod->package_name()),
               );

   # Clean up, build hash
   my %data;
   for (my $i=0; $i<@data; $i+=2)
   {
      my $label = $data[$i];
      my $value = $data[$i+1];
      if (!defined $value)
      {
         print "Undef field '$label'\n" if ($self->{verbose});
         $value = $data[$i+1] = "";
      }
      $data{$label} = $value;
   }

   # Work on splitoffs
   my $splitoffs = 0;
   my $manconflict = join(", ", map("%{Ni}$_-man", @perlversions));
   $manconflict =~ s/\.//g; # Remove dots from perl versions
   (my $binconflict = $manconflict) =~ s/-man/-bin/g;
   if ($bin)
   {
      my $splitnum = ++$splitoffs == 1 ? "" : $splitoffs;
      if ($typepkg)
      {
         push @data, "Splitoff$splitnum" => [
                                             Package => "%N-bin",
                                             Depends => "%N (= %v-%r)",
                                             Files => "bin",
                                             Conflicts => $binconflict,
                                             Replaces => $binconflict,
                                             DocFiles => $data{DocFiles},
                                             ];
      }
      else
      {
         push @data, "Splitoff$splitnum" => [
                                             Package => "%N-bin",
                                             Depends => "%N (= %v-%r)",
                                             Files => "bin share/man/man1",
                                             DocFiles => $data{DocFiles},
                                             ];
      }
   }
   if ($typepkg)
   {
      my $splitnum = ++$splitoffs == 1 ? "" : $splitoffs;
      push @data, "Splitoff$splitnum" => [
                                          Package => "%N-man",
                                          Depends => "%N (= %v-%r)",
                                          Files => "share/man",
                                          Conflicts => $manconflict,
                                          Replaces => $manconflict,
                                          DocFiles => $data{DocFiles},
                                          ];
      @data = ("Info2" => [@data]);
   }
   return \@data;
}

sub format_libs
{
   my $self = shift;
   my $libs = shift;

   my @libs = sort keys %$libs;
   my $perlre = qr/^(?:perl(?:\%type_pkg\[perl\]|5\d\d)-core|system-perl)/;
   my @perllibs = grep /$perlre/, @libs;
   if (@perllibs)
   {
      @libs = (@perllibs, grep(!/$perlre/, @libs));
   }

   require Text::Wrap;
   local $Text::Wrap::columns = 72;
   return Text::Wrap::wrap("", "", join(", ", @libs));
}

sub to_string
{
   my $pkg_or_self = shift;
   my $data = shift;
   my $olddata = shift || {};

   my @out;
   for (my $i=0; $i<@$data; $i+=2)
   {
      my $key = $data->[$i];
      my $val = $data->[$i+1];
      $val = "" if (!defined $val);
      (my $label = $key) =~ s/_/-/g;
      if (ref $val)
      {
         $val = $pkg_or_self->to_string($val, $olddata->{$key});
      }
      my $indent = " ";
      if ($key eq "Info2")
      {
         $indent = "";
      }
      if ($val =~ /\n/)
      {
         $val = join("\n".$indent, "<<", split(/\n[ \t]*/, $val))."\n<<";
      }
      my $oldval = $olddata->{$key};
      if ($oldval && !ref $oldval)
      {
         my $testval = $oldval;
         if ($oldval =~ /\n/)
         {
            $testval = join("\n".$indent, "<<", split(/\n[ \t]*/, $oldval))."\n<<";
            $oldval = join("\n#  ", "<<", split(/\n[ \t]*/, $oldval))."\n# <<";
         }
         push @out, "# Old$label: $oldval" if ($testval ne $val);
      }
      push @out, "$label: $val";
   }
   return join("\n", @out);
}

sub from_string
{
   my $pkg_or_self = shift;
   my $in = shift || "";

   $in =~ s/^[ \t]*#.*$//mg;
   $in =~ s/\n+/\n/gs;
   return $pkg_or_self->_from_string(\$in);
}

sub _from_string
{
   my $pkg_or_self = shift;
   my $in = shift;

   my %data;
   while ($$in =~ /\G([\w\-]+):[ \t]*/scg)
   {
      my $label = $1;
      $label =~ s/-/_/g;
      #if ($$in =~ /\G<<[ \t]*\n/scg)
      if ($$in =~ /\G<<\s*/scg)
      {
         if ($$in =~ /\G[\w\-]+:/s)
         {
            $data{$label} = $pkg_or_self->_from_string($in);
            unless ($$in =~ /\G<<\s*/scg)
            {
               last;
            }
         }
         else
         {
            if ($$in =~ /\G(.*?)<<\s*/scg)
            {
               my $val = $1;
               $val =~ s/\s+$//;
               $data{$label} = $val;
            }
         }
      }
      else
      {
         if ($$in =~ /\G([^\n]*)\s*/scg)
         {
            my $val = $1;
            $val =~ s/\s+$//;
            $data{$label} = $val;
         }
         else
         {
            last;
         }
      }
   }
   return \%data;
}

sub finkify_dep_pkg
{
   my $self = shift;
   my $pkg = lc shift;
   my @perlvers = (@_);

   # These are handled by core in all supported cases:
   # (This list is the Provides of perl580.info)
   return () if ($pkg =~ /^(podparser|attribute-handlers|cgi|digest-md5|file-spec|file-temp|filter-simple|filter-util|getopt-long|i18n-langtags|libnet|locale-maketext|memoize|mime-base64|scalar-list-utils|test-harness|test-simple|time-hires)$/);

   # Special cases:
   $pkg = $special_cases{$pkg} || $pkg;

   $pkg = lc($pkg)."-pm";
    
   my $out_typepkg = 0;
   my %out_perlvers;

   my $filename = $self->perlmod_dir."/$pkg.info";
   if (-f $filename)
   {
      my $content = read_file($filename);
      if ($content =~ /^Package:.*\%type_pkg\[perl\]/m)
      {
         $out_typepkg = 1;

         if ($content =~ /Type:\s+perl\s*\(?([\d\.\s]*)\)?/)
         {
            my @vers = split /\s+/, $1;
            my %perlvers = map {$_, 1} @perlvers;
            foreach my $v (@vers)
            {
               if ($perlvers{$v})
               {
                  $out_perlvers{$v} = 1;
               }
            }
         }
      }
      else
      {
         # Unversioned package
         %out_perlvers = map {$_, 1} @perlvers;
      }
   }
   foreach my $v (@perlvers)
   {
      (my $verabbr = $v) =~ s/\.//g;  # 5.8.1 -> 581
      my $filename = $self->perlmod_dir."/$pkg$verabbr.info";
      if (-f $filename)
      {
         $out_perlvers{$v} = 1;
         $out_typepkg = 1;
      }
      else
      {
         my @match;
         my $filename = $self->perllang_dir."/perl$verabbr.info";
         if (-f $filename)
         {
            my $content = read_file($filename);
            my $provides = join(",", 
                                ($content =~ /\n[ \t]*Provides:[ \t]*<<(.*?)<</gs),
                                ($content =~ /^[ \t]*Provides:[ \t]*([^<].*)$/gm),
                                );
            $provides =~ s/^\s+//s;
            $provides =~ s/\s+$//s;
            my @provides = split /\s*,\s*/, $provides;
            @match = grep /^\Q$pkg\E/, @provides;
         }
         if (@match > 0)
         {
            $out_perlvers{$v} = 1;
            $out_typepkg = 1;
         }
      }
   }
   if (keys(%out_perlvers) == 0)
   {
      print "$pkg is not yet packaged for Fink\n" if ($self->verbose);
      %out_perlvers = map {$_, 1} @perlvers;
   }
   if ($out_typepkg)
   {
      $pkg .= "\%type_pkg[perl]";
   }
   return ($pkg, $out_typepkg, [sort keys %out_perlvers]);
}

1;

#!/usr/bin/perl

use IPC::Open3;
use File::Basename;
use Getopt::Std;

use vars qw(
	$DEBUG
	$DIRECTORY
	$KDEMODE
	%OPTS
	@VERMAP
	@ALTMAP
);

$DEBUG = 0;
$DIRECTORY = dirname($0);
$KDEMODE = 0;
getopts('dhkv:m:', \%OPTS);

$DEBUG++ if ($OPTS{'d'});

if (not @ARGV or $OPTS{'h'}) {
	print <<END;
usage: $0 [-d] [-h] [-k] [-m /path/to/version/file] [-a /path/to/alternates/file] [-v version] <package1..packageN>

	-d          debug mode
	-h          this help
	-k          KDE mode
	-v <ver>    force version <ver> for package/alternate lookup
	-m <file>   the path to the package-version mapping
	            (defaults to $DIRECTORY/mapping.deplist)
	-a <file>   the path to the alternate-package listing
	            (defaults to $DIRECTORY/alternates.deplist)

The filenames specified in -m and -a are always searched, as well
as "<file>.<ver>".  "<file>.<ver>" always takes precedence
over "<file>", the first match wins.

END
	exit;
}

{
	my ($version, @MAPFILES, @ALTFILES);

	if ($OPTS{'m'}) {
		$MAPFILES[0] = $OPTS{'m'};
	} else {
		$MAPFILES[0] = $DIRECTORY . '/mapping.deplist';
	}
	if ($OPTS{'a'}) {
		$ALTFILES[0] = $OPTS{'a'};
	} else {
		$ALTFILES[0] = $DIRECTORY . '/alternates.deplist';
	}

	if ($OPTS{'v'}) {
		$version = $OPTS{'v'};
	} else {
		if (open(SWVERS, "sw_vers |")) {
			while (<SWVERS>) {
				if (/ProductVersion:\s+(\d+(\.\d+)?)/gsi) {
					$version = $1;
					last;
				}
			}
			close(SWVERS);
		}
	}

	if (-f $MAPFILES[0] . '.' . $version) {
		unshift(@MAPFILES, $MAPFILES[0] . '.' . $version);
	}
	if (-f $ALTFILES[0] . '.' . $version) {
		unshift(@ALTFILES, $ALTFILES[0] . '.' . $version);
	}

	for my $MAPFILE (@MAPFILES) {
		if (-f $MAPFILE) {
			if (open(FILEIN, $MAPFILE)) {
				while (<FILEIN>) {
					next if (/^\s*\#/);
					next if (/^\s*$/);
					chomp;
					my ($package, $version) = split(/\s+/, $_, 2);
					push(@VERMAP, [lc($package), $version]);
				}
				close(FILEIN);
			}
		}
	}

	for my $ALTFILE (@ALTFILES) {
		if (-f $ALTFILE) {
			if (open(FILEIN, $ALTFILE)) {
				while (<FILEIN>) {
					next if (/^\s*\#/);
					next if (/^\s*$/);
					chomp;
					my @packages = sort(split(/\s+/, $_));
					push(@ALTMAP, \@packages);
				}
				close(FILEIN);
			}
		}
	}

}

$KDEMODE++ if ($OPTS{'k'});

if (not @VERMAP or not @ALTMAP) {
	die "no mappings found\n";
}

for my $package (@ARGV) {
	print "=== ($package) ===\n";
	my (%filelist, %depfiles, %deppackages);
	if(open(DPKG, "dpkg -L $package 2>/dev/null |")) {
		while (<DPKG>) {
			chomp;
			if (-f $_) {
				$filelist{$_}++;
			}
			if (/\.omf$/) {
				# scrollkeeper .omf files
				$deppackages{'scrollkeeper'}++;
			} elsif (/lib\/perl5\/([\d\.]+)\//) {
				# /sw/lib/perl5/X.X.X/*
				my $perlver = $1;
				$perlver =~ s/\.//g;
				$deppackages{'perl'.$perlver.'-core'}++;
			}
		}
		close(DPKG);
	} else {
		print "couldn't run dpkg -L on $package: $!\n";
	}
	if (my $pid = open3(\*WRITER, \*READER, \*ERR, 'xargs otool -L')) {
		print WRITER join("\n", keys %filelist), "\n";
		close(WRITER);
		while(<READER>) {
			chomp;
			$_ =~ s/^\s*(\S+)\s+.*$/$1/;
			$depfiles{$_}++ if (-f $_);
		}
		close(READER);
		close(ERR);
	} else {
		print "couldn't open3 otool -L: $!\n";
	}
	if (my $pid = open3(\*WRITER, \*READER, \*ERR, 'xargs dpkg -S')) {
		print WRITER join("\n", keys %depfiles), "\n";
		close(WRITER);
		while(<READER>) {
			chomp;
			$_ =~ s/^([^:]+).*$/$1/;
			$deppackages{$_}++;
		}
		close(READER);
		close(ERR);
	} else {
		print "couldn't open3 dpkg -S: $!\n";
	}
	$deppackages{'%N-base'}++ if ($KDEMODE and $package ne '%N-base');
	my @pkgspecs;
	PKGLOOP: for my $deppackage (sort keys %deppackages) {
		if ($KDEMODE) {
			# stuff we skip
			next if ($deppackage =~ /^arts.*$/);
			next if ($deppackage =~ /^dlcompat.*$/);
			next if ($deppackage =~ /^esound.*$/);
			next if ($deppackage =~ /^freetype2.*$/);
			next if ($deppackage =~ /^gettext.*$/);
			next if ($deppackage =~ /^glib2.*$/);
			next if ($deppackage =~ /^kde(libs)3.*$/);
			next if ($deppackage =~ /^libart2.*$/);
			next if ($deppackage =~ /^(lib)?audiofile.*$/);
			next if ($deppackage =~ /^libiconv.*$/);
			next if ($deppackage =~ /^libjpeg.*$/);
			next if ($deppackage =~ /^libmad.*$/);
			next if ($deppackage =~ /^libogg.*$/);
			next if ($deppackage =~ /^libpng3.*$/);
			next if ($deppackage =~ /^libpoll.*$/);
			next if ($deppackage =~ /^libvorbis.*$/);
			next if ($deppackage =~ /^libx(slt|ml2).*$/);
			next if ($deppackage =~ /^openssl097.*$/);
			next if ($deppackage =~ /^pcre.*$/);
			next if ($deppackage =~ /^qt3.*$/);
			next if ($deppackage =~ /^(x11(-.*)?|.*xfree86.*)$/);
		}
		print "deppackage = $deppackage\n" if ($DEBUG);
		my $matchver;
		for (@VERMAP) {
			my ($key, $value) = @{$_};
			if ($deppackage =~ /^$key$/) {

				# RHS side check of mapping.deplist
				# SKIP
				if ($value =~ /^(skip|ignore)$/i) {
					next PKGLOOP;
				}
				# search and replace
				if ($value =~ /^s\//) {
					eval "\$deppackage =~ $value";
					push(@pkgspecs, $deppackage);
					next PKGLOOP;
				}
				# blank override
				if (not defined $value or $value eq "") {
					$matchver = undef;
					last;
				}

				$matchver = $value;
				last;
			}
		}
		my @alternates = ($deppackage);
		my $append;
		for my $entry (@ALTMAP) {
			for my $key (@{$entry}) {
				if ($deppackage =~ /^($key)(.*)$/) {
					print "'$deppackage' matched '$key' with append '$2'\n" if ($DEBUG);
					@alternates = @{$entry};
					if (defined $2 and $2 ne "") {
						$append = $2;
					}
				}
			}
		}
		my @altspecs;
		for my $alt (@alternates) {
			next PKGLOOP if ($alt . $append eq $package);
			if (defined $matchver) {
				push(@altspecs, $alt . $append . " " . $matchver);
			} else {
				push(@altspecs, $alt . $append);
			}
		}
		if (grep(/kde(libs|base)/, @altspecs) and $KDEMODE) {
			# special case, put ssl first
			push(@pkgspecs, join(' | ', reverse(@altspecs)));
		} else {
			push(@pkgspecs, join(' | ', @altspecs));
		}
	}
	print "Depends: ", join(', ', @pkgspecs), "\n\n";
}

# ripped wholesale from perl.req from RPM
# FIXME: use this sub to make automatic perl module dependencies
sub process_perl_file {

	my $file = shift;
	chomp $file;

	open(FILE, "<$file") || return;

	while (<FILE>) {

		# skip the documentation

		# we should not need to have item in this if statement (it
		# properly belongs in the over/back section) but people do not
		# read the perldoc.

		if ( (m/^=(head1|head2|pod|item)/) .. (m/^=(cut)/) ) {
			next;
		}

		if ( (m/^=(over)/) .. (m/^=(back)/) ) {
			next;
		}

		# skip the data section
		if (m/^__(DATA|END)__$/) {
			last;
		}

		if (

			# ouch could be in a eval, perhaps we do not want these since we catch
			# an exception they must not be required

			#  eval { require Term::ReadLine } or die $@;
			#  eval "require Term::Rendezvous;" or die $@;
			#  eval { require Carp } if defined $^S; # If error/warning during compilation,


			(m/^(\s*)                        # we hope the inclusion starts the line
			 (require|use)\s+(?!\{)          # do not want 'do {' loops
			 # quotes around name are always legal
			 [\'\"]?([^\;\ \'\"\t]*)[\'\"]?[\t\;\ ]
			 # the syntax for 'use' allows version requirements
			 \s*([.0-9]*)
			 /x)
		) {
			my ($whitespace, $statement, $module, $version) = ($1, $2, $3,$4);

			# we only consider require statements that are flush against
			# the left edge. any other require statements give too many
			# false positives, as they are usually inside of an if statement
			# as a fallback module or a rarely used option

			($whitespace ne "" && $statement eq "require") && next;

			# if there is some interpolation of variables just skip this
			# dependency, we do not want
			#  do "$ENV{LOGDIR}/$rcfile";

			($module =~ m/\$/) && next;

			# skip if the phrase was "use of" -- shows up in gimp-perl, et al
			next if $module eq 'of';

			# if the module ends in a comma we probaly caught some
			# documentation of the form 'check stuff,\n do stuff, clean
			# stuff.' there are several of these in the perl distribution

			($module =~ m/[,>]$/) && next;

			# if the module ends with .pm strip it to leave only basename.
			# starts with /, which means its an absolute path to a file
			if ($module =~ m(^/)) {
				print "$module\n";
				next;
			}

			# sometimes people do use POSIX qw(foo), or use POSIX(qw(foo)) etc
			# we can strip qw.*$, as well as (.*$:
			$module =~ s/qw.*$//;
			$module =~ s/\(*$//;

			$module =~ s/\.pm$//;

			# some perl programmers write 'require URI/URL;' when
			# they mean 'require URI::URL;'

			$module =~ s/\//::/;

			# trim off trailing parenthesis if any.	Sometimes people pass
			# the module an empty list.

			$module =~ s/\(\s*\)$//;

			if ( $module =~ m/^[0-9._]+$/ ) {
				# if module is a number then both require and use interpret that
				# to mean that a particular version of perl is specified

				# skip this since we do the perl560-core thing

			};

			# ph files do not use the package name inside the file.
			# perlmodlib documentation says:

			#  the .ph files made by h2ph will probably end up as
			#  extension modules made by h2xs.

			# so do not expend much effort on these.

			# there is no easy way to find out if a file named systeminfo.ph
			# will be included with the name sys/systeminfo.ph so only use the
			# basename of *.ph files

			($module =~ m/\.ph$/) && next;

			$require{$module}=$version;
			$line{$module}=$_;
		}

	}

	close(FILE) ||
		die("$0: Could not close file: '$file' : $!\n");

	return ;
}


diff -uNr apt-0.5.28.6/apt-inst/makefile apt-0.5.28.6-new/apt-inst/makefile
--- apt-0.5.28.6/apt-inst/makefile	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-inst/makefile	Mon Apr 25 16:19:12 2005
@@ -10,6 +10,7 @@
 include ../buildlib/defaults.mak
 
 # The library name
+LDFLAGS += -L../apt-pkg -lapt-pkg
 LIBRARY=apt-inst
 LIBEXT=$(GLIBC_VER)$(LIBSTDCPP_VER)
 MAJOR=1.0
diff -uNr apt-0.5.28.6/apt-pkg/contrib/mmap.cc apt-0.5.28.6-new/apt-pkg/contrib/mmap.cc
--- apt-0.5.28.6/apt-pkg/contrib/mmap.cc	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/contrib/mmap.cc	Mon Apr 25 16:19:12 2005
@@ -41,7 +41,7 @@
 // ---------------------------------------------------------------------
 /* */
 MMap::MMap(FileFd &F,unsigned long Flags) : Flags(Flags), iSize(0),
-                     Base(0)
+                     Base(0), iFd(0)
 {
    if ((Flags & NoImmMap) != NoImmMap)
       Map(F);
@@ -51,7 +51,7 @@
 // ---------------------------------------------------------------------
 /* */
 MMap::MMap(unsigned long Flags) : Flags(Flags), iSize(0),
-                     Base(0)
+                     Base(0), iFd(0)
 {
 }
 									/*}}}*/
@@ -68,6 +68,7 @@
 /* */
 bool MMap::Map(FileFd &Fd)
 {
+   iFd = &Fd;
    iSize = Fd.Size();
    
    // Set the permissions.
@@ -81,10 +82,19 @@
    if (iSize == 0)
       return _error->Error(_("Can't mmap an empty file"));
    
+#ifndef EMULATE_MMAP
    // Map it.
    Base = mmap(0,iSize,Prot,Map,Fd.Fd(),0);
    if (Base == (void *)-1)
       return _error->Errno("mmap",_("Couldn't make mmap of %lu bytes"),iSize);
+#else
+   Base = new unsigned char[iSize];
+   if (Base == NULL)
+      return _error->Errno("mmap",_("Couldn't allocate %lu bytes to emulate mmap"),iSize);
+
+   Fd.Seek(0);
+   Fd.Read(Base, iSize, true);
+#endif
 
    return true;
 }
@@ -100,8 +110,16 @@
    if (DoSync == true)
       Sync();
    
+#ifndef EMULATE_MMAP   
    if (munmap((char *)Base,iSize) != 0)
       _error->Warning("Unable to munmap");
+#else
+   if ((Flags & ReadOnly) != ReadOnly && iFd != 0) {
+      iFd->Seek(0);
+      iFd->Write(Base, iSize);
+   }
+   delete [] (unsigned char *)Base;
+#endif
    
    iSize = 0;
    Base = 0;
@@ -117,11 +135,13 @@
    if ((Flags & UnMapped) == UnMapped)
       return true;
    
+#ifndef EMULATE_MMAP
 #ifdef _POSIX_SYNCHRONIZED_IO   
    if ((Flags & ReadOnly) != ReadOnly)
       if (msync((char *)Base,iSize,MS_SYNC) != 0)
 	 return _error->Errno("msync","Unable to write mmap");
 #endif   
+#endif
    return true;
 }
 									/*}}}*/
@@ -133,11 +153,13 @@
    if ((Flags & UnMapped) == UnMapped)
       return true;
    
+#ifndef EMULATE_MMAP
 #ifdef _POSIX_SYNCHRONIZED_IO
    unsigned long PSize = sysconf(_SC_PAGESIZE);
    if ((Flags & ReadOnly) != ReadOnly)
       if (msync((char *)Base+(int)(Start/PSize)*PSize,Stop - Start,MS_SYNC) != 0)
 	 return _error->Errno("msync","Unable to write mmap");
+#endif   
 #endif   
    return true;
 }
diff -uNr apt-0.5.28.6/apt-pkg/contrib/mmap.h apt-0.5.28.6-new/apt-pkg/contrib/mmap.h
--- apt-0.5.28.6/apt-pkg/contrib/mmap.h	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/contrib/mmap.h	Mon Apr 25 16:19:12 2005
@@ -46,6 +46,7 @@
    unsigned long Flags;
    unsigned long iSize;
    void *Base;
+   FileFd *iFd;
 
    bool Map(FileFd &Fd);
    bool Close(bool DoSync = true);
diff -uNr apt-0.5.28.6/apt-pkg/deb/debindexfile.cc apt-0.5.28.6-new/apt-pkg/deb/debindexfile.cc
--- apt-0.5.28.6/apt-pkg/deb/debindexfile.cc	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/deb/debindexfile.cc	Mon Apr 25 16:19:12 2005
@@ -505,3 +505,11 @@
 }
 
 									/*}}}*/
+void init_deb2()
+{
+  (void)_apt_DebType;
+  (void)_apt_DebSrcType;
+  (void)_apt_Src;
+  (void)_apt_Pkg;
+  (void)_apt_Status;
+}
diff -uNr apt-0.5.28.6/apt-pkg/deb/debsystem.cc apt-0.5.28.6-new/apt-pkg/deb/debsystem.cc
--- apt-0.5.28.6/apt-pkg/deb/debsystem.cc	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/deb/debsystem.cc	Mon Apr 25 16:19:12 2005
@@ -27,6 +27,108 @@
 #include <dirent.h>
 #include <errno.h>
 									/*}}}*/
+/* FINK LOCAL begin */
+#include <sys/utsname.h>
+#include <CoreFoundation/CoreFoundation.h>
+#include <fstream>
+#include <sys/stat.h>
+
+extern void init_deb2();
+extern void init_deb3();
+
+#define FINKSTATUSFILE "/tmp/finkaptstatus"
+
+struct versionrevision {
+  unsigned long epoch;
+  const char *version;
+  const char *revision;
+};  
+
+struct versionrevision darwin_version = {0,NULL,NULL};
+struct versionrevision macosx_version = {0,NULL,NULL};
+
+static void finkinit()
+{
+  Boolean status;
+  SInt32 errorCode;
+  CFURLRef fileURL = NULL;
+  CFDataRef resourceData = NULL;
+  CFPropertyListRef propertyList = NULL;
+  CFStringRef string;
+  static char buffer[256];	// This is static, to ensure the buffer stays around
+
+  static struct utsname ver;	// This is static, to ensure the buffer stays around
+  
+  /* Determine system version */
+  /* TODO - should maybe check if this is really Darwin? */
+  if (!uname(&ver)) {
+    darwin_version.version = ver.release;
+  }
+
+  /* Check whether this is Mac OS X, and which version of it */
+
+  fileURL = CFURLCreateWithFileSystemPath( NULL, 	
+		CFSTR("/System/Library/CoreServices/SystemVersion.plist"),
+		kCFURLPOSIXPathStyle,				
+		false );
+  if (!fileURL)
+    goto BAIL;
+  
+  /* Read the XML */
+  status = CFURLCreateDataAndPropertiesFromResource(
+		NULL,
+		fileURL,
+		&resourceData,
+		NULL,		
+		NULL,
+		&errorCode);
+  if (!status || errorCode != 0)
+    goto BAIL;
+  
+  /* Reconstitute the dictionary using the XML data. */
+  propertyList = CFPropertyListCreateFromXMLData( NULL,
+		resourceData,
+		kCFPropertyListImmutable,
+		&string);
+  if (!propertyList)
+    goto BAIL;
+  
+  /* Try to read the system version from it. */
+  status = CFDictionaryGetValueIfPresent( propertyList,
+		CFSTR("ProductVersion"),
+		(void*)&string);
+  if (!status)
+    goto BAIL;
+  
+  /* Convert into a C string */
+  status = CFStringGetCString( string,
+		buffer,
+		sizeof(buffer),
+		kCFStringEncodingISOLatin1);
+  if (!status)
+    goto BAIL;
+  
+  /* Finally link the buffer into the macosx_version struct. */
+  macosx_version.version = buffer;
+  
+BAIL:
+  // Release all of the CF objects we're responsible for.
+  if (fileURL)
+    CFRelease(fileURL);
+  if (resourceData)
+    CFRelease(resourceData);
+  if (propertyList)
+    CFRelease(propertyList);
+}
+
+void initDebSystem()
+{
+  finkinit();
+  (void)debSys;
+  init_deb2();
+  init_deb3();
+}
+/* FINK LOCAL end */
 
 debSystem debSys;
 
@@ -49,6 +151,8 @@
 debSystem::~debSystem()
 {
    delete StatusFile;
+   delete FinkStatusFile;
+   unlink(FINKSTATUSFILE);
 }
 									/*}}}*/
 // System::Lock - Get the lock						/*{{{*/
@@ -162,8 +266,8 @@
       which is yet to be determined. The functions in pkgcachegen should
       be the only users of these */
    Cnf.CndSet("Dir::State::userstatus","status.user"); // Defunct
-   Cnf.CndSet("Dir::State::status","/var/lib/dpkg/status");
-   Cnf.CndSet("Dir::Bin::dpkg","/usr/bin/dpkg");
+   Cnf.CndSet("Dir::State::status","@PREFIX@/var/lib/dpkg/status");
+   Cnf.CndSet("Dir::Bin::dpkg","@PREFIX@/bin/dpkg");
    
    return true;
 }
@@ -186,9 +290,9 @@
 signed debSystem::Score(Configuration const &Cnf)
 {
    signed Score = 0;
-   if (FileExists(Cnf.FindFile("Dir::State::status","/var/lib/dpkg/status")) == true)
+   if (FileExists(Cnf.FindFile("Dir::State::status","@PREFIX@/var/lib/dpkg/status")) == true)
        Score += 10;
-   if (FileExists(Cnf.FindFile("Dir::Bin::dpkg","/usr/bin/dpkg")) == true)
+   if (FileExists(Cnf.FindFile("Dir::Bin::dpkg","@PREFIX@/bin/dpkg")) == true)
       Score += 10;
    if (FileExists("/etc/debian_version") == true)
       Score += 10;
@@ -203,6 +307,44 @@
    if (StatusFile == 0)
       StatusFile = new debStatusIndex(_config->FindFile("Dir::State::status"));
    List.push_back(StatusFile);
+/* FINK LOCAL begin */
+
+   if (FinkStatusFile == 0) {
+      struct stat unused_sbuf;
+      int sys_ok=0;
+      unlink(FINKSTATUSFILE);
+      if ( 0 == stat("@PREFIX@/bin/fink-virtual-pkgs",&unused_sbuf)) {
+          if ( 0 == system("@PREFIX@/bin/fink-virtual-pkgs --apt")) sys_ok=1;
+      }    
+      if (stat(FINKSTATUSFILE, &unused_sbuf) || !sys_ok) {
+	  std::ofstream finkstatus(FINKSTATUSFILE);
+      if(macosx_version.version != 0)
+      {
+        finkstatus << "Package: macosx" << endl;
+        finkstatus << "Status: install ok installed" << endl;      
+        finkstatus << "Priority: optional" << endl;
+        finkstatus << "Section: base" << endl;
+        finkstatus << "Maintainer: None" << endl;
+        finkstatus << "Source: macosx" << endl;
+        finkstatus << "Version: " << macosx_version.version << endl;
+        finkstatus << "Description: Pseudo package representing Mac OS X" << endl;
+        finkstatus << " Pseudo package representing Mac OS X" << endl << endl;
+      }
+      finkstatus << "Package: darwin" << endl;
+      finkstatus << "Status: install ok installed" << endl;
+      finkstatus << "Priority: optional" << endl;
+      finkstatus << "Section: base" << endl;
+      finkstatus << "Maintainer: None" << endl;
+      finkstatus << "Source: darwin" << endl;
+      finkstatus << "Version: " << darwin_version.version  << endl;
+      finkstatus << "Description: Pseudo package representing Darwin" << endl;
+      finkstatus << " Pseudo package representing Darwin" << endl << endl;
+      finkstatus.close();
+      }		
+      FinkStatusFile = new debStatusIndex(FINKSTATUSFILE);
+   }
+   List.push_back(FinkStatusFile);
+/* FINK LOCAL end */
    return true;
 }
 									/*}}}*/
@@ -217,6 +359,10 @@
    if (StatusFile->FindInCache(*File.Cache()) == File)
    {
       Found = StatusFile;
+      return true;
+   }  else if ((FinkStatusFile != 0) && (FinkStatusFile->FindInCache(*File.Cache()) == File))
+   {
+      Found = FinkStatusFile;
       return true;
    }
    
diff -uNr apt-0.5.28.6/apt-pkg/deb/debsystem.cc.orig apt-0.5.28.6-new/apt-pkg/deb/debsystem.cc.orig
--- apt-0.5.28.6/apt-pkg/deb/debsystem.cc.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/apt-pkg/deb/debsystem.cc.orig	Mon Jan 10 16:50:08 2005
@@ -0,0 +1,225 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+
+   System - Abstraction for running on different systems.
+
+   Basic general structure..
+   
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#ifdef __GNUG__
+#pragma implementation "apt-pkg/debsystem.h"
+#endif
+
+#include <apt-pkg/debsystem.h>
+#include <apt-pkg/debversion.h>
+#include <apt-pkg/debindexfile.h>
+#include <apt-pkg/dpkgpm.h>
+#include <apt-pkg/configuration.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/fileutl.h>
+    
+#include <sys/types.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <errno.h>
+									/*}}}*/
+
+debSystem debSys;
+
+// System::debSystem - Constructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+debSystem::debSystem()
+{
+   LockFD = -1;
+   LockCount = 0;
+   StatusFile = 0;
+   
+   Label = "Debian dpkg interface";
+   VS = &debVS;
+}
+									/*}}}*/
+// System::~debSystem - Destructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+debSystem::~debSystem()
+{
+   delete StatusFile;
+}
+									/*}}}*/
+// System::Lock - Get the lock						/*{{{*/
+// ---------------------------------------------------------------------
+/* This mirrors the operations dpkg does when it starts up. Note the
+   checking of the updates directory. */
+bool debSystem::Lock()
+{
+   // Disable file locking
+   if (_config->FindB("Debug::NoLocking",false) == true || LockCount > 1)
+   {
+      LockCount++;
+      return true;
+   }
+
+   // Create the lockfile
+   string AdminDir = flNotFile(_config->Find("Dir::State::status"));
+   LockFD = GetLock(AdminDir + "lock");
+   if (LockFD == -1)
+   {
+      if (errno == EACCES || errno == EAGAIN)
+	 return _error->Error("Unable to lock the administration directory (%s), "
+			      "is another process using it?",AdminDir.c_str());
+      else
+	 return _error->Error("Unable to lock the administration directory (%s), "
+			      "are you root?",AdminDir.c_str());
+   }
+   
+   // See if we need to abort with a dirty journal
+   if (CheckUpdates() == true)
+   {
+      close(LockFD);
+      LockFD = -1;
+      return _error->Error("dpkg was interrupted, you must manually "
+			   "run 'dpkg --configure -a' to correct the problem. ");
+   }
+
+	 LockCount++;
+      
+   return true;
+}
+									/*}}}*/
+// System::UnLock - Drop a lock						/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool debSystem::UnLock(bool NoErrors)
+{
+   if (LockCount == 0 && NoErrors == true)
+      return false;
+   
+   if (LockCount < 1)
+      return _error->Error("Not locked");
+   if (--LockCount == 0)
+   {
+      close(LockFD);
+      LockCount = 0;
+   }
+   
+   return true;
+}
+									/*}}}*/
+// System::CheckUpdates - Check if the updates dir is dirty		/*{{{*/
+// ---------------------------------------------------------------------
+/* This does a check of the updates directory (dpkg journal) to see if it has 
+   any entries in it. */
+bool debSystem::CheckUpdates()
+{
+   // Check for updates.. (dirty)
+   string File = flNotFile(_config->Find("Dir::State::status")) + "updates/";
+   DIR *DirP = opendir(File.c_str());
+   if (DirP == 0)
+      return false;
+   
+   /* We ignore any files that are not all digits, this skips .,.. and 
+      some tmp files dpkg will leave behind.. */
+   bool Damaged = false;
+   for (struct dirent *Ent = readdir(DirP); Ent != 0; Ent = readdir(DirP))
+   {
+      Damaged = true;
+      for (unsigned int I = 0; Ent->d_name[I] != 0; I++)
+      {
+	 // Check if its not a digit..
+	 if (isdigit(Ent->d_name[I]) == 0)
+	 {
+	    Damaged = false;
+	    break;
+	 }
+      }
+      if (Damaged == true)
+	 break;
+   }
+   closedir(DirP);
+
+   return Damaged;
+}
+									/*}}}*/
+// System::CreatePM - Create the underlying package manager		/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+pkgPackageManager *debSystem::CreatePM(pkgDepCache *Cache) const
+{
+   return new pkgDPkgPM(Cache);
+}
+									/*}}}*/
+// System::Initialize - Setup the configuration space..			/*{{{*/
+// ---------------------------------------------------------------------
+/* These are the Debian specific configuration variables.. */
+bool debSystem::Initialize(Configuration &Cnf)
+{
+   /* These really should be jammed into a generic 'Local Database' engine
+      which is yet to be determined. The functions in pkgcachegen should
+      be the only users of these */
+   Cnf.CndSet("Dir::State::userstatus","status.user"); // Defunct
+   Cnf.CndSet("Dir::State::status","/var/lib/dpkg/status");
+   Cnf.CndSet("Dir::Bin::dpkg","/usr/bin/dpkg");
+   
+   return true;
+}
+									/*}}}*/
+// System::ArchiveSupported - Is a file format supported		/*{{{*/
+// ---------------------------------------------------------------------
+/* The standard name for a deb is 'deb'.. There are no seperate versions
+   of .deb to worry about.. */
+bool debSystem::ArchiveSupported(const char *Type)
+{
+   if (strcmp(Type,"deb") == 0)
+      return true;
+   return false;
+}
+									/*}}}*/
+// System::Score - Determine how 'Debiany' this sys is..		/*{{{*/
+// ---------------------------------------------------------------------
+/* We check some files that are sure tell signs of this being a Debian
+   System.. */
+signed debSystem::Score(Configuration const &Cnf)
+{
+   signed Score = 0;
+   if (FileExists(Cnf.FindFile("Dir::State::status","/var/lib/dpkg/status")) == true)
+       Score += 10;
+   if (FileExists(Cnf.FindFile("Dir::Bin::dpkg","/usr/bin/dpkg")) == true)
+      Score += 10;
+   if (FileExists("/etc/debian_version") == true)
+      Score += 10;
+   return Score;
+}
+									/*}}}*/
+// System::AddStatusFiles - Register the status files			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool debSystem::AddStatusFiles(vector<pkgIndexFile *> &List)
+{
+   if (StatusFile == 0)
+      StatusFile = new debStatusIndex(_config->FindFile("Dir::State::status"));
+   List.push_back(StatusFile);
+   return true;
+}
+									/*}}}*/
+// System::FindIndex - Get an index file for status files		/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool debSystem::FindIndex(pkgCache::PkgFileIterator File,
+			  pkgIndexFile *&Found) const
+{
+   if (StatusFile == 0)
+      return false;
+   if (StatusFile->FindInCache(*File.Cache()) == File)
+   {
+      Found = StatusFile;
+      return true;
+   }
+   
+   return false;
+}
+									/*}}}*/
diff -uNr apt-0.5.28.6/apt-pkg/deb/debsystem.h apt-0.5.28.6-new/apt-pkg/deb/debsystem.h
--- apt-0.5.28.6/apt-pkg/deb/debsystem.h	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/deb/debsystem.h	Mon Apr 25 16:19:12 2005
@@ -25,6 +25,7 @@
    bool CheckUpdates();
    
    debStatusIndex *StatusFile;
+   debStatusIndex *FinkStatusFile;
    
    public:
 
diff -uNr apt-0.5.28.6/apt-pkg/deb/debversion.cc apt-0.5.28.6-new/apt-pkg/deb/debversion.cc
--- apt-0.5.28.6/apt-pkg/deb/debversion.cc	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/deb/debversion.cc	Mon Apr 25 16:19:12 2005
@@ -24,6 +24,11 @@
 
 debVersioningSystem debVS;
 
+void init_deb3()
+{
+  (void)debVS;
+}
+
 // debVS::debVersioningSystem - Constructor				/*{{{*/
 // ---------------------------------------------------------------------
 /* */
diff -uNr apt-0.5.28.6/apt-pkg/init.cc apt-0.5.28.6-new/apt-pkg/init.cc
--- apt-0.5.28.6/apt-pkg/init.cc	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/apt-pkg/init.cc	Mon Apr 25 16:19:12 2005
@@ -15,6 +15,8 @@
 #include <apti18n.h>
 #include <config.h>
 #include <sys/stat.h>
+
+extern void initDebSystem();
 									/*}}}*/
 
 #define Stringfy_(x) # x
@@ -40,7 +42,7 @@
    else
       Cnf.Set("APT::Architecture",COMMON_OS "-" COMMON_CPU);
    Cnf.Set("APT::Build-Essential::", "build-essential");
-   Cnf.Set("Dir","/");
+   Cnf.Set("Dir","@PREFIX@/");
    
    // State   
    Cnf.Set("Dir::State","var/lib/apt/");
@@ -69,7 +71,7 @@
    Cnf.Set("Dir::Etc::main","apt.conf");
    Cnf.Set("Dir::Etc::parts","apt.conf.d");
    Cnf.Set("Dir::Etc::preferences","preferences");
-   Cnf.Set("Dir::Bin::methods","/usr/lib/apt/methods");
+   Cnf.Set("Dir::Bin::methods","@PREFIX@/lib/apt/methods");
 	      
    bool Res = true;
    
@@ -110,6 +112,8 @@
 /* */
 bool pkgInitSystem(Configuration &Cnf,pkgSystem *&Sys)
 {
+   initDebSystem();
+
    Sys = 0;
    string Label = Cnf.Find("Apt::System","");
    if (Label.empty() == false)
diff -uNr apt-0.5.28.6/apt-pkg/init.cc.orig apt-0.5.28.6-new/apt-pkg/init.cc.orig
--- apt-0.5.28.6/apt-pkg/init.cc.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/apt-pkg/init.cc.orig	Mon Jan 10 16:50:08 2005
@@ -0,0 +1,140 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+
+   Init - Initialize the package library
+   
+   ##################################################################### */
+									/*}}}*/
+// Include files							/*{{{*/
+#include <apt-pkg/init.h>
+#include <apt-pkg/fileutl.h>
+#include <apt-pkg/error.h>
+
+#include <apti18n.h>
+#include <config.h>
+#include <sys/stat.h>
+									/*}}}*/
+
+#define Stringfy_(x) # x
+#define Stringfy(x)  Stringfy_(x)
+const char *pkgVersion = VERSION;
+const char *pkgLibVersion = Stringfy(APT_PKG_MAJOR) "."
+                            Stringfy(APT_PKG_MINOR) "." 
+                            Stringfy(APT_PKG_RELEASE);
+const char *pkgCPU = COMMON_CPU;
+const char *pkgOS = COMMON_OS;
+    
+// pkgInitConfig - Initialize the configuration class			/*{{{*/
+// ---------------------------------------------------------------------
+/* Directories are specified in such a way that the FindDir function will
+   understand them. That is, if they don't start with a / then their parent
+   is prepended, this allows a fair degree of flexability. */
+bool pkgInitConfig(Configuration &Cnf)
+{
+   // General APT things
+   if (strcmp(COMMON_OS,"linux") == 0 ||
+       strcmp(COMMON_OS,"unknown") == 0)
+      Cnf.Set("APT::Architecture",COMMON_CPU);
+   else
+      Cnf.Set("APT::Architecture",COMMON_OS "-" COMMON_CPU);
+   Cnf.Set("APT::Build-Essential::", "build-essential");
+   Cnf.Set("Dir","/");
+   
+   // State   
+   Cnf.Set("Dir::State","var/lib/apt/");
+   
+   /* Just in case something goes horribly wrong, we can fall back to the
+      old /var/state paths.. */
+   struct stat St;   
+   if (stat("/var/lib/apt/.",&St) != 0 &&
+       stat("/var/state/apt/.",&St) == 0)
+      Cnf.Set("Dir::State","var/state/apt/");
+       
+   Cnf.Set("Dir::State::lists","lists/");
+   Cnf.Set("Dir::State::cdroms","cdroms.list");
+   
+   // Cache
+   Cnf.Set("Dir::Cache","var/cache/apt/");
+   Cnf.Set("Dir::Cache::archives","archives/");
+   Cnf.Set("Dir::Cache::srcpkgcache","srcpkgcache.bin");
+   Cnf.Set("Dir::Cache::pkgcache","pkgcache.bin");
+   
+   // Configuration
+   Cnf.Set("Dir::Etc","etc/apt/");
+   Cnf.Set("Dir::Etc::sourcelist","sources.list");
+   Cnf.Set("Dir::Etc::vendorlist","vendors.list");
+   Cnf.Set("Dir::Etc::vendorparts","vendors.list.d");
+   Cnf.Set("Dir::Etc::main","apt.conf");
+   Cnf.Set("Dir::Etc::parts","apt.conf.d");
+   Cnf.Set("Dir::Etc::preferences","preferences");
+   Cnf.Set("Dir::Bin::methods","/usr/lib/apt/methods");
+	      
+   bool Res = true;
+   
+   // Read an alternate config file
+   const char *Cfg = getenv("APT_CONFIG");
+   if (Cfg != 0 && FileExists(Cfg) == true)
+      Res &= ReadConfigFile(Cnf,Cfg);
+   
+   // Read the configuration parts dir
+   string Parts = Cnf.FindDir("Dir::Etc::parts");
+   if (FileExists(Parts) == true)
+      Res &= ReadConfigDir(Cnf,Parts);
+      
+   // Read the main config file
+   string FName = Cnf.FindFile("Dir::Etc::main");
+   if (FileExists(FName) == true)
+      Res &= ReadConfigFile(Cnf,FName);
+   
+   if (Res == false)
+      return false;
+   
+   if (Cnf.FindB("Debug::pkgInitConfig",false) == true)
+      Cnf.Dump();
+   
+#ifdef APT_DOMAIN
+   if (Cnf.Exists("Dir::Locale"))
+   {  
+      bindtextdomain(APT_DOMAIN,Cnf.FindDir("Dir::Locale").c_str());
+      bindtextdomain(textdomain(0),Cnf.FindDir("Dir::Locale").c_str());
+   }
+#endif
+   
+   return true;
+}
+									/*}}}*/
+// pkgInitSystem - Initialize the _system calss				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool pkgInitSystem(Configuration &Cnf,pkgSystem *&Sys)
+{
+   Sys = 0;
+   string Label = Cnf.Find("Apt::System","");
+   if (Label.empty() == false)
+   {
+      Sys = pkgSystem::GetSystem(Label.c_str());
+      if (Sys == 0)
+	 return _error->Error(_("Packaging system '%s' is not supported"),Label.c_str());
+   }
+   else
+   {
+      signed MaxScore = 0;
+      for (unsigned I = 0; I != pkgSystem::GlobalListLen; I++)
+      {
+	 signed Score = pkgSystem::GlobalList[I]->Score(Cnf);
+	 if (Score > MaxScore)
+	 {
+	    MaxScore = Score;
+	    Sys = pkgSystem::GlobalList[I];
+	 }
+      }
+      
+      if (Sys == 0)
+	 return _error->Error(_("Unable to determine a suitable packaging system type"));
+   }
+   
+   return Sys->Initialize(Cnf);
+}
+									/*}}}*/
diff -uNr apt-0.5.28.6/buildlib/environment.mak.in apt-0.5.28.6-new/buildlib/environment.mak.in
--- apt-0.5.28.6/buildlib/environment.mak.in	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/buildlib/environment.mak.in	Mon Apr 25 16:30:36 2005
@@ -13,8 +13,8 @@
 LIBSTDCPP_VER = @LIBSTDCPP_VER@
 
 # Linker stuff
-PICFLAGS+= -fPIC -DPIC
-LFLAGS+= @LDFLAGS@
+PICFLAGS+= -fno-common -DPIC
+LFLAGS+= @LDFLAGS@ -framework CoreFoundation
 LEFLAGS+= 
 SOCKETLIBS:= @SOCKETLIBS@
 AR:=@AR@
@@ -59,11 +59,12 @@
 
 # Shared library things
 HOST_OS = @host_os@
-ifneq ($(words $(filter linux-gnu gnu% %gnu,$(HOST_OS))),0)
-   SONAME_MAGIC=-Wl,-soname -Wl,
-   LFLAGS_SO=
-else
-   # Do not know how to create shared libraries here.
-   ONLYSTATICLIBS = yes
-endif
-	
+#ifneq ($(words $(filter linux-gnu gnu% %gnu,$(HOST_OS))),0)
+#   SONAME_MAGIC=-Wl,-soname -Wl,
+#   LFLAGS_SO=
+#else
+#   # Do not know how to create shared libraries here.
+#   ONLYSTATICLIBS = yes
+#endif
+SONAME_MAGIC=-install_name @PREFIX@/lib/
+LFLAGS_SO=-dynamiclib
diff -uNr apt-0.5.28.6/buildlib/library.mak apt-0.5.28.6-new/buildlib/library.mak
--- apt-0.5.28.6/buildlib/library.mak	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/buildlib/library.mak	Mon Apr 25 16:33:46 2005
@@ -16,11 +16,11 @@
 # See defaults.mak for information about LOCAL
 
 # Some local definitions
-LOCAL := lib$(LIBRARY)$(LIBEXT).so.$(MAJOR).$(MINOR)
+LOCAL := lib$(LIBRARY)$(LIBEXT).$(MAJOR).$(MINOR).dylib
 $(LOCAL)-OBJS := $(addprefix $(OBJ)/,$(addsuffix .opic,$(notdir $(basename $(SOURCE)))))
 $(LOCAL)-DEP := $(addprefix $(DEP)/,$(addsuffix .opic.d,$(notdir $(basename $(SOURCE)))))
 $(LOCAL)-HEADERS := $(addprefix $(INCLUDE)/,$(HEADERS))
-$(LOCAL)-SONAME := lib$(LIBRARY)$(LIBEXT).so.$(MAJOR)
+$(LOCAL)-SONAME := lib$(LIBRARY)$(LIBEXT).$(MAJOR).dylib
 $(LOCAL)-SLIBS := $(SLIBS)
 $(LOCAL)-LIBRARY := $(LIBRARY)
 
@@ -29,7 +29,7 @@
 
 # Install the command hooks
 headers: $($(LOCAL)-HEADERS)
-library: $(LIB)/lib$(LIBRARY).so $(LIB)/lib$(LIBRARY)$(LIBEXT).so.$(MAJOR)
+library: $(LIB)/lib$(LIBRARY).dylib $(LIB)/lib$(LIBRARY)$(LIBEXT).$(MAJOR).dylib
 clean: clean/$(LOCAL)
 veryclean: veryclean/$(LOCAL)
 
@@ -41,21 +41,23 @@
 clean/$(LOCAL):
 	-rm -f $($(@F)-OBJS) $($(@F)-DEP)
 veryclean/$(LOCAL): clean/$(LOCAL)
-	-rm -f $($(@F)-HEADERS) $(LIB)/lib$($(@F)-LIBRARY)*.so*
+	-rm -f $($(@F)-HEADERS) $(LIB)/lib$($(@F)-LIBRARY)*.dylib
 
 # Build rules for the two symlinks
-.PHONY: $(LIB)/lib$(LIBRARY)$(LIBEXT).so.$(MAJOR) $(LIB)/lib$(LIBRARY).so
-$(LIB)/lib$(LIBRARY)$(LIBEXT).so.$(MAJOR): $(LIB)/lib$(LIBRARY)$(LIBEXT).so.$(MAJOR).$(MINOR)
+.PHONY: $(LIB)/lib$(LIBRARY)$(LIBEXT).$(MAJOR).dylib $(LIB)/lib$(LIBRARY).dylib
+$(LIB)/lib$(LIBRARY)$(LIBEXT).$(MAJOR).dylib: $(LIB)/lib$(LIBRARY)$(LIBEXT).$(MAJOR).$(MINOR).dylib
 	ln -sf $(<F) $@
-$(LIB)/lib$(LIBRARY).so: $(LIB)/lib$(LIBRARY)$(LIBEXT).so.$(MAJOR).$(MINOR)
+$(LIB)/lib$(LIBRARY).dylib: $(LIB)/lib$(LIBRARY)$(LIBEXT).$(MAJOR).$(MINOR).dylib
 	ln -sf $(<F) $@
 
 # The binary build rule
-$(LIB)/lib$(LIBRARY)$(LIBEXT).so.$(MAJOR).$(MINOR): $($(LOCAL)-HEADERS) $($(LOCAL)-OBJS)
-	-rm -f $(LIB)/lib$($(@F)-LIBRARY)*.so* 2> /dev/null
+$(LIB)/lib$(LIBRARY)$(LIBEXT).$(MAJOR).$(MINOR).dylib: $($(LOCAL)-HEADERS) $($(LOCAL)-OBJS)
+	-rm -f $(LIB)/lib$($(@F)-LIBRARY)*.dylib 2> /dev/null
 	echo Building shared library $@
 	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(PICFLAGS) $(LFLAGS) $(LFLAGS_SO)\
-	   -o $@ $(SONAME_MAGIC)$($(@F)-SONAME) -shared \
+	   -o $@ $(SONAME_MAGIC)$($(@F)-SONAME) \
+	   -compatibility_version $(MAJOR).$(MINOR) \
+	   -current_version $(MAJOR).$(MINOR) \
 	   $(filter %.opic,$^) \
 	   $($(@F)-SLIBS) 
 
diff -uNr apt-0.5.28.6/buildlib/ostable apt-0.5.28.6-new/buildlib/ostable
--- apt-0.5.28.6/buildlib/ostable	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/buildlib/ostable	Mon Apr 25 16:19:15 2005
@@ -16,6 +16,7 @@
 hp-hpux[^-]*	    hp-ux
 sun-solaris[^-]*    solaris
 [^-]*-openbsd[^-]*  openbsd
+[^-]*-darwin[^-]*   darwin
 
 # Catch all
 .*	unknown
diff -uNr apt-0.5.28.6/buildlib/ostable.orig apt-0.5.28.6-new/buildlib/ostable.orig
--- apt-0.5.28.6/buildlib/ostable.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/buildlib/ostable.orig	Mon Jan 10 16:50:08 2005
@@ -0,0 +1,21 @@
+# This file contains a table of known vendor-os strings, with
+# things to map them to. `configure' will take the output of the
+# autoconf cannon macros and look in here. This only deals with
+# OS names. The right should be a common name like the arch table
+# generates
+# The final bit to build the Debian Architecture is done in init.cc
+# The left side is a regex for awk, and the first match is used.
+
+# These are used by Debian
+[^-]*-linux-.*   linux
+[^-]*-kfreebsd.*-gnu   kfreebsd
+[^-]*-knetbsd.*-gnu   knetbsd
+[^-]*-gnu[^-]*   hurd
+
+# These are samples. 
+hp-hpux[^-]*	    hp-ux
+sun-solaris[^-]*    solaris
+[^-]*-openbsd[^-]*  openbsd
+
+# Catch all
+.*	unknown
diff -uNr apt-0.5.28.6/cmdline/apt-get.cc apt-0.5.28.6-new/cmdline/apt-get.cc
--- apt-0.5.28.6/cmdline/apt-get.cc	Thu Feb 10 03:52:34 2005
+++ apt-0.5.28.6-new/cmdline/apt-get.cc	Mon Apr 25 16:19:15 2005
@@ -113,6 +113,8 @@
 /* Returns true on a Yes.*/
 bool YnPrompt()
 {
+   fflush(NULL);
+   
    if (_config->FindB("APT::Get::Assume-Yes",false) == true)
    {
       c1out << _("Y") << endl;
@@ -331,7 +333,14 @@
 		  if (Cache[Targ].CandidateVerIter(Cache).end() == true)
 		  {
 		     if (Targ->ProvidesList == 0)
-			out << _("but it is not installable");
+		     {
+			out << _("but it is not installable. For Fink users, ");
+			out << _("this often means that you have attempted ");
+			out << _("to install a package from the binary distribution ");
+			out << _("which depends on a \"Restrictive\" package. ");
+			out << _("See <http://fink.sourceforge.net/faq/usage-fink.php#bindist>, ");
+			out << _("<http://fink.sourceforge.net/doc/users-guide/packages.php#bin-exceptions>");
+		     }
 		     else
 			out << _("but it is a virtual package");
 		  }		  
@@ -637,7 +646,9 @@
       return false;
    
    // Nothing is broken
-   if (DCache->BrokenCount() == 0 || AllowBroken == true)
+   // FINK LOCAL added APT::Get::Ignore-Breakage test
+   if (DCache->BrokenCount() == 0 || AllowBroken == true
+       || _config->FindB("APT::Get::Ignore-Breakage") == true)
       return true;
 
    // Attempt to fix broken things
@@ -703,7 +714,9 @@
    Stats(c1out,Cache);
    
    // Sanity check
-   if (Cache->BrokenCount() != 0)
+   // FINK LOCAL added APT::Get::Ignore-Breakage test
+   if (Cache->BrokenCount() != 0
+       && _config->FindB("APT::Get::Ignore-Breakage",false) == false)
    {
       ShowBroken(c1out,Cache,false);
       return _error->Error("Internal Error, InstallPackages was called with broken packages!");
@@ -1095,7 +1108,9 @@
       ExpectedInst++;
    
    // Install it with autoinstalling enabled.
-   if (State.InstBroken() == true && BrokenFix == false)
+   // FINK LOCAL added APT::Get::Ignore-Breakage test
+   if (State.InstBroken() == true && BrokenFix == false
+      && _config->FindB("APT::Get::Ignore-Breakage") == false)
       Cache.MarkInstall(Pkg,true);
    return true;
 }
@@ -1457,7 +1472,9 @@
    /* If we are in the Broken fixing mode we do not attempt to fix the
       problems. This is if the user invoked install without -f and gave
       packages */
-   if (BrokenFix == true && Cache->BrokenCount() != 0)
+   // FINK LOCAL added APT::Get::Ignore-Breakage test
+   if (BrokenFix == true && Cache->BrokenCount() != 0
+       && _config->FindB("APT::Get::Ignore-Breakage") == false)
    {
       c1out << _("You might want to run `apt-get -f install' to correct these:") << endl;
       ShowBroken(c1out,Cache,false);
@@ -1467,11 +1484,13 @@
    
    // Call the scored problem resolver
    Fix.InstallProtect();
-   if (Fix.Resolve(true) == false)
+   // FINK LOCAL added APT::Get::Ignore-Breakage test
+   if (_config->FindB("APT::Get::Ignore-Breakage") == false && Fix.Resolve(true) == false)
       _error->Discard();
 
    // Now we check the state of the packages,
-   if (Cache->BrokenCount() != 0)
+   // FINK LOCAL added APT::Get::Ignore-Breakage test
+   if (Cache->BrokenCount() != 0 && _config->FindB("APT::Get::Ignore-Breakage") == false)
    {
       c1out << 
        _("Some packages could not be installed. This may mean that you have\n" 
@@ -2355,6 +2374,8 @@
    _config->Set("APT::Get::Simulate",false);
    _config->Set("APT::Get::Assume-Yes",false);
    _config->Set("APT::Get::Fix-Broken",false);
+   // FINK LOCAL added APT::Get::Ignore-Breakage
+   _config->Set("APT::Get::Ignore-Breakage",false);
    _config->Set("APT::Get::Force-Yes",false);
    _config->Set("APT::Get::List-Cleanup",true);
 }
@@ -2393,6 +2414,8 @@
       {'y',"yes","APT::Get::Assume-Yes",0},
       {'y',"assume-yes","APT::Get::Assume-Yes",0},      
       {'f',"fix-broken","APT::Get::Fix-Broken",0},
+      // FINK LOCAL added APT::Get::Ignore-Breakage
+      {0,"ignore-breakage","APT::Get::Ignore-Breakage",0},
       {'u',"show-upgraded","APT::Get::Show-Upgraded",0},
       {'m',"ignore-missing","APT::Get::Fix-Missing",0},
       {'t',"target-release","APT::Default-Release",CommandLine::HasArg},
@@ -2455,6 +2478,22 @@
       ShowHelp(CmdL);
       return 0;
    }
+
+   /* FINK LOCAL begin */
+   if (_config->FindB("APT::Get::Ignore-Breakage",false) == true) {
+     if (_config->FindB("APT::Get::Print-URIs",false) == false &&
+	 _config->FindB("APT::Get::Download-Only",false) == false) {
+       _error->Error("--ignore-breakage can only be used with --print-uris or --download-only");
+       _error->DumpErrors();
+       return 100;
+     }
+     if (strcmp(CmdL.FileList[0],"install") != 0) {
+       _error->Error("--ignore-breakage can only be used with apt-get install");
+       _error->DumpErrors();
+       return 100;
+     }
+   }
+   /* FINK LOCAL end */
    
    // Deal with stdout not being a tty
    if (!isatty(STDOUT_FILENO) && _config->FindI("quiet",0) < 1)
diff -uNr apt-0.5.28.6/cmdline/apt-get.cc.orig apt-0.5.28.6-new/cmdline/apt-get.cc.orig
--- apt-0.5.28.6/cmdline/apt-get.cc.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/cmdline/apt-get.cc.orig	Thu Feb 10 03:52:34 2005
@@ -0,0 +1,2489 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+   
+   apt-get - Cover for dpkg
+   
+   This is an allout cover for dpkg implementing a safer front end. It is
+   based largely on libapt-pkg.
+
+   The syntax is different, 
+      apt-get [opt] command [things]
+   Where command is:
+      update - Resyncronize the package files from their sources
+      upgrade - Smart-Download the newest versions of all packages
+      dselect-upgrade - Follows dselect's changes to the Status: field
+                       and installes new and removes old packages
+      dist-upgrade - Powerfull upgrader designed to handle the issues with
+                    a new distribution.
+      install - Download and install a given package (by name, not by .deb)
+      check - Update the package cache and check for broken packages
+      clean - Erase the .debs downloaded to /var/cache/apt/archives and
+              the partial dir too
+
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#include <apt-pkg/error.h>
+#include <apt-pkg/cmndline.h>
+#include <apt-pkg/init.h>
+#include <apt-pkg/depcache.h>
+#include <apt-pkg/sourcelist.h>
+#include <apt-pkg/algorithms.h>
+#include <apt-pkg/acquire-item.h>
+#include <apt-pkg/strutl.h>
+#include <apt-pkg/clean.h>
+#include <apt-pkg/srcrecords.h>
+#include <apt-pkg/version.h>
+#include <apt-pkg/cachefile.h>
+#include <apt-pkg/sptr.h>
+#include <apt-pkg/versionmatch.h>
+    
+#include <config.h>
+#include <apti18n.h>
+
+#include "acqprogress.h"
+
+#include <locale.h>
+#include <langinfo.h>
+#include <fstream>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <signal.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <regex.h>
+#include <sys/wait.h>
+									/*}}}*/
+
+using namespace std;
+
+ostream c0out(0);
+ostream c1out(0);
+ostream c2out(0);
+ofstream devnull("/dev/null");
+unsigned int ScreenWidth = 80;
+
+// class CacheFile - Cover class for some dependency cache functions	/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+class CacheFile : public pkgCacheFile
+{
+   static pkgCache *SortCache;
+   static int NameComp(const void *a,const void *b);
+   
+   public:
+   pkgCache::Package **List;
+   
+   void Sort();
+   bool CheckDeps(bool AllowBroken = false);
+   bool BuildCaches(bool WithLock = true)
+   {
+      OpTextProgress Prog(*_config);
+      if (pkgCacheFile::BuildCaches(Prog,WithLock) == false)
+	 return false;
+      return true;
+   }
+   bool Open(bool WithLock = true) 
+   {
+      OpTextProgress Prog(*_config);
+      if (pkgCacheFile::Open(Prog,WithLock) == false)
+	 return false;
+      Sort();
+      
+      return true;
+   };
+   bool OpenForInstall()
+   {
+      if (_config->FindB("APT::Get::Print-URIs") == true)
+	 return Open(false);
+      else
+	 return Open(true);
+   }
+   CacheFile() : List(0) {};
+};
+									/*}}}*/
+
+// YnPrompt - Yes No Prompt.						/*{{{*/
+// ---------------------------------------------------------------------
+/* Returns true on a Yes.*/
+bool YnPrompt()
+{
+   if (_config->FindB("APT::Get::Assume-Yes",false) == true)
+   {
+      c1out << _("Y") << endl;
+      return true;
+   }
+
+   char response[1024] = "";
+   cin.getline(response, sizeof(response));
+
+   if (!cin)
+      return false;
+
+   if (strlen(response) == 0)
+      return true;
+
+   regex_t Pattern;
+   int Res;
+
+   Res = regcomp(&Pattern, nl_langinfo(YESEXPR),
+                 REG_EXTENDED|REG_ICASE|REG_NOSUB);
+
+   if (Res != 0) {
+      char Error[300];        
+      regerror(Res,&Pattern,Error,sizeof(Error));
+      return _error->Error(_("Regex compilation error - %s"),Error);
+   }
+   
+   Res = regexec(&Pattern, response, 0, NULL, 0);
+   if (Res == 0)
+      return true;
+   return false;
+}
+									/*}}}*/
+// AnalPrompt - Annoying Yes No Prompt.					/*{{{*/
+// ---------------------------------------------------------------------
+/* Returns true on a Yes.*/
+bool AnalPrompt(const char *Text)
+{
+   char Buf[1024];
+   cin.getline(Buf,sizeof(Buf));
+   if (strcmp(Buf,Text) == 0)
+      return true;
+   return false;
+}
+									/*}}}*/
+// ShowList - Show a list						/*{{{*/
+// ---------------------------------------------------------------------
+/* This prints out a string of space separated words with a title and 
+   a two space indent line wraped to the current screen width. */
+bool ShowList(ostream &out,string Title,string List,string VersionsList)
+{
+   if (List.empty() == true)
+      return true;
+   // trim trailing space
+   int NonSpace = List.find_last_not_of(' ');
+   if (NonSpace != -1)
+   {
+      List = List.erase(NonSpace + 1);
+      if (List.empty() == true)
+	 return true;
+   }
+
+   // Acount for the leading space
+   int ScreenWidth = ::ScreenWidth - 3;
+      
+   out << Title << endl;
+   string::size_type Start = 0;
+   string::size_type VersionsStart = 0;
+   while (Start < List.size())
+   {
+      if(_config->FindB("APT::Get::Show-Versions",false) == true &&
+         VersionsList.size() > 0) {
+         string::size_type End;
+         string::size_type VersionsEnd;
+         
+         End = List.find(' ',Start);
+         VersionsEnd = VersionsList.find('\n', VersionsStart);
+
+         out << "   " << string(List,Start,End - Start) << " (" << 
+            string(VersionsList,VersionsStart,VersionsEnd - VersionsStart) << 
+            ")" << endl;
+
+	 if (End == string::npos || End < Start)
+	    End = Start + ScreenWidth;
+
+         Start = End + 1;
+         VersionsStart = VersionsEnd + 1;
+      } else {
+         string::size_type End;
+
+         if (Start + ScreenWidth >= List.size())
+            End = List.size();
+         else
+            End = List.rfind(' ',Start+ScreenWidth);
+
+         if (End == string::npos || End < Start)
+            End = Start + ScreenWidth;
+         out << "  " << string(List,Start,End - Start) << endl;
+         Start = End + 1;
+      }
+   }   
+
+   return false;
+}
+									/*}}}*/
+// ShowBroken - Debugging aide						/*{{{*/
+// ---------------------------------------------------------------------
+/* This prints out the names of all the packages that are broken along
+   with the name of each each broken dependency and a quite version 
+   description.
+   
+   The output looks like:
+ The following packages have unmet dependencies:
+     exim: Depends: libc6 (>= 2.1.94) but 2.1.3-10 is to be installed
+           Depends: libldap2 (>= 2.0.2-2) but it is not going to be installed
+           Depends: libsasl7 but it is not going to be installed   
+ */
+void ShowBroken(ostream &out,CacheFile &Cache,bool Now)
+{
+   out << _("The following packages have unmet dependencies:") << endl;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      
+      if (Now == true)
+      {
+	 if (Cache[I].NowBroken() == false)
+	    continue;
+      }
+      else
+      {
+	 if (Cache[I].InstBroken() == false)
+	    continue;
+      }
+      
+      // Print out each package and the failed dependencies
+      out <<"  " <<  I.Name() << ":";
+      unsigned Indent = strlen(I.Name()) + 3;
+      bool First = true;
+      pkgCache::VerIterator Ver;
+      
+      if (Now == true)
+	 Ver = I.CurrentVer();
+      else
+	 Ver = Cache[I].InstVerIter(Cache);
+      
+      if (Ver.end() == true)
+      {
+	 out << endl;
+	 continue;
+      }
+      
+      for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
+      {
+	 // Compute a single dependency element (glob or)
+	 pkgCache::DepIterator Start;
+	 pkgCache::DepIterator End;
+	 D.GlobOr(Start,End); // advances D
+
+	 if (Cache->IsImportantDep(End) == false)
+	    continue;
+	 
+	 if (Now == true)
+	 {
+	    if ((Cache[End] & pkgDepCache::DepGNow) == pkgDepCache::DepGNow)
+	       continue;
+	 }
+	 else
+	 {
+	    if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+	       continue;
+	 }
+	 
+	 bool FirstOr = true;
+	 while (1)
+	 {
+	    if (First == false)
+	       for (unsigned J = 0; J != Indent; J++)
+		  out << ' ';
+	    First = false;
+
+	    if (FirstOr == false)
+	    {
+	       for (unsigned J = 0; J != strlen(End.DepType()) + 3; J++)
+		  out << ' ';
+	    }
+	    else
+	       out << ' ' << End.DepType() << ": ";
+	    FirstOr = false;
+	    
+	    out << Start.TargetPkg().Name();
+	 
+	    // Show a quick summary of the version requirements
+	    if (Start.TargetVer() != 0)
+	       out << " (" << Start.CompType() << " " << Start.TargetVer() << ")";
+	    
+	    /* Show a summary of the target package if possible. In the case
+	       of virtual packages we show nothing */	 
+	    pkgCache::PkgIterator Targ = Start.TargetPkg();
+	    if (Targ->ProvidesList == 0)
+	    {
+	       out << ' ';
+	       pkgCache::VerIterator Ver = Cache[Targ].InstVerIter(Cache);
+	       if (Now == true)
+		  Ver = Targ.CurrentVer();
+	       	    
+	       if (Ver.end() == false)
+	       {
+		  if (Now == true)
+		     ioprintf(out,_("but %s is installed"),Ver.VerStr());
+		  else
+		     ioprintf(out,_("but %s is to be installed"),Ver.VerStr());
+	       }	       
+	       else
+	       {
+		  if (Cache[Targ].CandidateVerIter(Cache).end() == true)
+		  {
+		     if (Targ->ProvidesList == 0)
+			out << _("but it is not installable");
+		     else
+			out << _("but it is a virtual package");
+		  }		  
+		  else
+		     out << (Now?_("but it is not installed"):_("but it is not going to be installed"));
+	       }	       
+	    }
+	    
+	    if (Start != End)
+	       out << _(" or");
+	    out << endl;
+	    
+	    if (Start == End)
+	       break;
+	    Start++;
+	 }	 
+      }	    
+   }   
+}
+									/*}}}*/
+// ShowNew - Show packages to newly install				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void ShowNew(ostream &out,CacheFile &Cache)
+{
+   /* Print out a list of packages that are going to be installed extra
+      to what the user asked */
+   string List;
+   string VersionsList;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      if (Cache[I].NewInstall() == true) {
+         List += string(I.Name()) + " ";
+         VersionsList += string(Cache[I].CandVersion) + "\n";
+      }
+   }
+   
+   ShowList(out,_("The following NEW packages will be installed:"),List,VersionsList);
+}
+									/*}}}*/
+// ShowDel - Show packages to delete					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void ShowDel(ostream &out,CacheFile &Cache)
+{
+   /* Print out a list of packages that are going to be removed extra
+      to what the user asked */
+   string List;
+   string VersionsList;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      if (Cache[I].Delete() == true)
+      {
+	 if ((Cache[I].iFlags & pkgDepCache::Purge) == pkgDepCache::Purge)
+	    List += string(I.Name()) + "* ";
+	 else
+	    List += string(I.Name()) + " ";
+     
+     VersionsList += string(Cache[I].CandVersion)+ "\n";
+      }
+   }
+   
+   ShowList(out,_("The following packages will be REMOVED:"),List,VersionsList);
+}
+									/*}}}*/
+// ShowKept - Show kept packages					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void ShowKept(ostream &out,CacheFile &Cache)
+{
+   string List;
+   string VersionsList;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {	 
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      
+      // Not interesting
+      if (Cache[I].Upgrade() == true || Cache[I].Upgradable() == false ||
+	  I->CurrentVer == 0 || Cache[I].Delete() == true)
+	 continue;
+      
+      List += string(I.Name()) + " ";
+      VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
+   }
+   ShowList(out,_("The following packages have been kept back:"),List,VersionsList);
+}
+									/*}}}*/
+// ShowUpgraded - Show upgraded packages				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void ShowUpgraded(ostream &out,CacheFile &Cache)
+{
+   string List;
+   string VersionsList;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      
+      // Not interesting
+      if (Cache[I].Upgrade() == false || Cache[I].NewInstall() == true)
+	 continue;
+      
+      List += string(I.Name()) + " ";
+      VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
+   }
+   ShowList(out,_("The following packages will be upgraded:"),List,VersionsList);
+}
+									/*}}}*/
+// ShowDowngraded - Show downgraded packages				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool ShowDowngraded(ostream &out,CacheFile &Cache)
+{
+   string List;
+   string VersionsList;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      
+      // Not interesting
+      if (Cache[I].Downgrade() == false || Cache[I].NewInstall() == true)
+	 continue;
+      
+      List += string(I.Name()) + " ";
+      VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
+   }
+   return ShowList(out,_("The following packages will be DOWNGRADED:"),List,VersionsList);
+}
+									/*}}}*/
+// ShowHold - Show held but changed packages				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool ShowHold(ostream &out,CacheFile &Cache)
+{
+   string List;
+   string VersionsList;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      if (Cache[I].InstallVer != (pkgCache::Version *)I.CurrentVer() &&
+          I->SelectedState == pkgCache::State::Hold) {
+         List += string(I.Name()) + " ";
+		 VersionsList += string(Cache[I].CurVersion) + " => " + Cache[I].CandVersion + "\n";
+      }
+   }
+
+   return ShowList(out,_("The following held packages will be changed:"),List,VersionsList);
+}
+									/*}}}*/
+// ShowEssential - Show an essential package warning			/*{{{*/
+// ---------------------------------------------------------------------
+/* This prints out a warning message that is not to be ignored. It shows
+   all essential packages and their dependents that are to be removed. 
+   It is insanely risky to remove the dependents of an essential package! */
+bool ShowEssential(ostream &out,CacheFile &Cache)
+{
+   string List;
+   string VersionsList;
+   bool *Added = new bool[Cache->Head().PackageCount];
+   for (unsigned int I = 0; I != Cache->Head().PackageCount; I++)
+      Added[I] = false;
+   
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      if ((I->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential &&
+	  (I->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important)
+	 continue;
+      
+      // The essential package is being removed
+      if (Cache[I].Delete() == true)
+      {
+	 if (Added[I->ID] == false)
+	 {
+	    Added[I->ID] = true;
+	    List += string(I.Name()) + " ";
+        //VersionsList += string(Cache[I].CurVersion) + "\n"; ???
+	 }
+      }
+      
+      if (I->CurrentVer == 0)
+	 continue;
+
+      // Print out any essential package depenendents that are to be removed
+      for (pkgCache::DepIterator D = I.CurrentVer().DependsList(); D.end() == false; D++)
+      {
+	 // Skip everything but depends
+	 if (D->Type != pkgCache::Dep::PreDepends &&
+	     D->Type != pkgCache::Dep::Depends)
+	    continue;
+	 
+	 pkgCache::PkgIterator P = D.SmartTargetPkg();
+	 if (Cache[P].Delete() == true)
+	 {
+	    if (Added[P->ID] == true)
+	       continue;
+	    Added[P->ID] = true;
+	    
+	    char S[300];
+	    snprintf(S,sizeof(S),_("%s (due to %s) "),P.Name(),I.Name());
+	    List += S;
+        //VersionsList += "\n"; ???
+	 }	 
+      }      
+   }
+   
+   delete [] Added;
+   return ShowList(out,_("WARNING: The following essential packages will be removed\n"
+			 "This should NOT be done unless you know exactly what you are doing!"),List,VersionsList);
+}
+									/*}}}*/
+// Stats - Show some statistics						/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void Stats(ostream &out,pkgDepCache &Dep)
+{
+   unsigned long Upgrade = 0;
+   unsigned long Downgrade = 0;
+   unsigned long Install = 0;
+   unsigned long ReInstall = 0;
+   for (pkgCache::PkgIterator I = Dep.PkgBegin(); I.end() == false; I++)
+   {
+      if (Dep[I].NewInstall() == true)
+	 Install++;
+      else
+      {
+	 if (Dep[I].Upgrade() == true)
+	    Upgrade++;
+	 else
+	    if (Dep[I].Downgrade() == true)
+	       Downgrade++;
+      }
+      
+      if (Dep[I].Delete() == false && (Dep[I].iFlags & pkgDepCache::ReInstall) == pkgDepCache::ReInstall)
+	 ReInstall++;
+   }   
+
+   ioprintf(out,_("%lu upgraded, %lu newly installed, "),
+	    Upgrade,Install);
+   
+   if (ReInstall != 0)
+      ioprintf(out,_("%lu reinstalled, "),ReInstall);
+   if (Downgrade != 0)
+      ioprintf(out,_("%lu downgraded, "),Downgrade);
+
+   ioprintf(out,_("%lu to remove and %lu not upgraded.\n"),
+	    Dep.DelCount(),Dep.KeepCount());
+   
+   if (Dep.BadCount() != 0)
+      ioprintf(out,_("%lu not fully installed or removed.\n"),
+	       Dep.BadCount());
+}
+									/*}}}*/
+
+// CacheFile::NameComp - QSort compare by name				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+pkgCache *CacheFile::SortCache = 0;
+int CacheFile::NameComp(const void *a,const void *b)
+{
+   if (*(pkgCache::Package **)a == 0 || *(pkgCache::Package **)b == 0)
+      return *(pkgCache::Package **)a - *(pkgCache::Package **)b;
+   
+   const pkgCache::Package &A = **(pkgCache::Package **)a;
+   const pkgCache::Package &B = **(pkgCache::Package **)b;
+
+   return strcmp(SortCache->StrP + A.Name,SortCache->StrP + B.Name);
+}
+									/*}}}*/
+// CacheFile::Sort - Sort by name					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void CacheFile::Sort()
+{
+   delete [] List;
+   List = new pkgCache::Package *[Cache->Head().PackageCount];
+   memset(List,0,sizeof(*List)*Cache->Head().PackageCount);
+   pkgCache::PkgIterator I = Cache->PkgBegin();
+   for (;I.end() != true; I++)
+      List[I->ID] = I;
+
+   SortCache = *this;
+   qsort(List,Cache->Head().PackageCount,sizeof(*List),NameComp);
+}
+									/*}}}*/
+// CacheFile::CheckDeps - Open the cache file				/*{{{*/
+// ---------------------------------------------------------------------
+/* This routine generates the caches and then opens the dependency cache
+   and verifies that the system is OK. */
+bool CacheFile::CheckDeps(bool AllowBroken)
+{
+   if (_error->PendingError() == true)
+      return false;
+
+   // Check that the system is OK
+   if (DCache->DelCount() != 0 || DCache->InstCount() != 0)
+      return _error->Error("Internal Error, non-zero counts");
+   
+   // Apply corrections for half-installed packages
+   if (pkgApplyStatus(*DCache) == false)
+      return false;
+   
+   // Nothing is broken
+   if (DCache->BrokenCount() == 0 || AllowBroken == true)
+      return true;
+
+   // Attempt to fix broken things
+   if (_config->FindB("APT::Get::Fix-Broken",false) == true)
+   {
+      c1out << _("Correcting dependencies...") << flush;
+      if (pkgFixBroken(*DCache) == false || DCache->BrokenCount() != 0)
+      {
+	 c1out << _(" failed.") << endl;
+	 ShowBroken(c1out,*this,true);
+
+	 return _error->Error(_("Unable to correct dependencies"));
+      }
+      if (pkgMinimizeUpgrade(*DCache) == false)
+	 return _error->Error(_("Unable to minimize the upgrade set"));
+      
+      c1out << _(" Done") << endl;
+   }
+   else
+   {
+      c1out << _("You might want to run `apt-get -f install' to correct these.") << endl;
+      ShowBroken(c1out,*this,true);
+
+      return _error->Error(_("Unmet dependencies. Try using -f."));
+   }
+      
+   return true;
+}
+									/*}}}*/
+
+// InstallPackages - Actually download and install the packages		/*{{{*/
+// ---------------------------------------------------------------------
+/* This displays the informative messages describing what is going to 
+   happen and then calls the download routines */
+bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
+		     bool Safety = true)
+{
+   if (_config->FindB("APT::Get::Purge",false) == true)
+   {
+      pkgCache::PkgIterator I = Cache->PkgBegin();
+      for (; I.end() == false; I++)
+      {
+	 if (I.Purge() == false && Cache[I].Mode == pkgDepCache::ModeDelete)
+	    Cache->MarkDelete(I,true);
+      }
+   }
+   
+   bool Fail = false;
+   bool Essential = false;
+   
+   // Show all the various warning indicators
+   ShowDel(c1out,Cache);
+   ShowNew(c1out,Cache);
+   if (ShwKept == true)
+      ShowKept(c1out,Cache);
+   Fail |= !ShowHold(c1out,Cache);
+   if (_config->FindB("APT::Get::Show-Upgraded",true) == true)
+      ShowUpgraded(c1out,Cache);
+   Fail |= !ShowDowngraded(c1out,Cache);
+   if (_config->FindB("APT::Get::Download-Only",false) == false)
+        Essential = !ShowEssential(c1out,Cache);
+   Fail |= Essential;
+   Stats(c1out,Cache);
+   
+   // Sanity check
+   if (Cache->BrokenCount() != 0)
+   {
+      ShowBroken(c1out,Cache,false);
+      return _error->Error("Internal Error, InstallPackages was called with broken packages!");
+   }
+
+   if (Cache->DelCount() == 0 && Cache->InstCount() == 0 &&
+       Cache->BadCount() == 0)
+      return true;
+
+   // No remove flag
+   if (Cache->DelCount() != 0 && _config->FindB("APT::Get::Remove",true) == false)
+      return _error->Error(_("Packages need to be removed but Remove is disabled."));
+       
+   // Run the simulator ..
+   if (_config->FindB("APT::Get::Simulate") == true)
+   {
+      pkgSimulate PM(Cache);
+      pkgPackageManager::OrderResult Res = PM.DoInstall();
+      if (Res == pkgPackageManager::Failed)
+	 return false;
+      if (Res != pkgPackageManager::Completed)
+	 return _error->Error("Internal Error, Ordering didn't finish");
+      return true;
+   }
+   
+   // Create the text record parser
+   pkgRecords Recs(Cache);
+   if (_error->PendingError() == true)
+      return false;
+   
+   // Lock the archive directory
+   FileFd Lock;
+   if (_config->FindB("Debug::NoLocking",false) == false &&
+       _config->FindB("APT::Get::Print-URIs") == false)
+   {
+      Lock.Fd(GetLock(_config->FindDir("Dir::Cache::Archives") + "lock"));
+      if (_error->PendingError() == true)
+	 return _error->Error(_("Unable to lock the download directory"));
+   }
+   
+   // Create the download object
+   AcqTextStatus Stat(ScreenWidth,_config->FindI("quiet",0));   
+   pkgAcquire Fetcher(&Stat);
+
+   // Read the source list
+   pkgSourceList List;
+   if (List.ReadMainList() == false)
+      return _error->Error(_("The list of sources could not be read."));
+   
+   // Create the package manager and prepare to download
+   SPtr<pkgPackageManager> PM= _system->CreatePM(Cache);
+   if (PM->GetArchives(&Fetcher,&List,&Recs) == false || 
+       _error->PendingError() == true)
+      return false;
+
+   // Display statistics
+   double FetchBytes = Fetcher.FetchNeeded();
+   double FetchPBytes = Fetcher.PartialPresent();
+   double DebBytes = Fetcher.TotalNeeded();
+   if (DebBytes != Cache->DebSize())
+   {
+      c0out << DebBytes << ',' << Cache->DebSize() << endl;
+      c0out << "How odd.. The sizes didn't match, email apt@packages.debian.org" << endl;
+   }
+   
+   // Number of bytes
+   if (DebBytes != FetchBytes)
+      ioprintf(c1out,_("Need to get %sB/%sB of archives.\n"),
+	       SizeToStr(FetchBytes).c_str(),SizeToStr(DebBytes).c_str());
+   else
+      ioprintf(c1out,_("Need to get %sB of archives.\n"),
+	       SizeToStr(DebBytes).c_str());
+
+   // Size delta
+   if (Cache->UsrSize() >= 0)
+      ioprintf(c1out,_("After unpacking %sB of additional disk space will be used.\n"),
+	       SizeToStr(Cache->UsrSize()).c_str());
+   else
+      ioprintf(c1out,_("After unpacking %sB disk space will be freed.\n"),
+	       SizeToStr(-1*Cache->UsrSize()).c_str());
+
+   if (_error->PendingError() == true)
+      return false;
+
+   /* Check for enough free space, but only if we are actually going to
+      download */
+   if (_config->FindB("APT::Get::Print-URIs") == false &&
+       _config->FindB("APT::Get::Download",true) == true)
+   {
+      struct statvfs Buf;
+      string OutputDir = _config->FindDir("Dir::Cache::Archives");
+      if (statvfs(OutputDir.c_str(),&Buf) != 0)
+	 return _error->Errno("statvfs","Couldn't determine free space in %s",
+			      OutputDir.c_str());
+      if (unsigned(Buf.f_bfree) < (FetchBytes - FetchPBytes)/Buf.f_bsize)
+	 return _error->Error(_("You don't have enough free space in %s."),
+			      OutputDir.c_str());
+   }
+   
+   // Fail safe check
+   if (_config->FindI("quiet",0) >= 2 ||
+       _config->FindB("APT::Get::Assume-Yes",false) == true)
+   {
+      if (Fail == true && _config->FindB("APT::Get::Force-Yes",false) == false)
+	 return _error->Error(_("There are problems and -y was used without --force-yes"));
+   }         
+
+   if (Essential == true && Safety == true)
+   {
+      if (_config->FindB("APT::Get::Trivial-Only",false) == true)
+	 return _error->Error(_("Trivial Only specified but this is not a trivial operation."));
+      
+      const char *Prompt = _("Yes, do as I say!");
+      ioprintf(c2out,
+	       _("You are about to do something potentially harmful\n"
+		 "To continue type in the phrase '%s'\n"
+		 " ?] "),Prompt);
+      c2out << flush;
+      if (AnalPrompt(Prompt) == false)
+      {
+	 c2out << _("Abort.") << endl;
+	 exit(1);
+      }     
+   }
+   else
+   {      
+      // Prompt to continue
+      if (Ask == true || Fail == true)
+      {            
+	 if (_config->FindB("APT::Get::Trivial-Only",false) == true)
+	    return _error->Error(_("Trivial Only specified but this is not a trivial operation."));
+	 
+	 if (_config->FindI("quiet",0) < 2 &&
+	     _config->FindB("APT::Get::Assume-Yes",false) == false)
+	 {
+	    c2out << _("Do you want to continue? [Y/n] ") << flush;
+	 
+	    if (YnPrompt() == false)
+	    {
+	       c2out << _("Abort.") << endl;
+	       exit(1);
+	    }     
+	 }	 
+      }      
+   }
+   
+   // Just print out the uris an exit if the --print-uris flag was used
+   if (_config->FindB("APT::Get::Print-URIs") == true)
+   {
+      pkgAcquire::UriIterator I = Fetcher.UriBegin();
+      for (; I != Fetcher.UriEnd(); I++)
+	 cout << '\'' << I->URI << "' " << flNotDir(I->Owner->DestFile) << ' ' << 
+	       I->Owner->FileSize << ' ' << I->Owner->MD5Sum() << endl;
+      return true;
+   }
+
+   /* Unlock the dpkg lock if we are not going to be doing an install
+      after. */
+   if (_config->FindB("APT::Get::Download-Only",false) == true)
+      _system->UnLock();
+   
+   // Run it
+   while (1)
+   {
+      bool Transient = false;
+      if (_config->FindB("APT::Get::Download",true) == false)
+      {
+	 for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I < Fetcher.ItemsEnd();)
+	 {
+	    if ((*I)->Local == true)
+	    {
+	       I++;
+	       continue;
+	    }
+
+	    // Close the item and check if it was found in cache
+	    (*I)->Finished();
+	    if ((*I)->Complete == false)
+	       Transient = true;
+	    
+	    // Clear it out of the fetch list
+	    delete *I;
+	    I = Fetcher.ItemsBegin();
+	 }	 
+      }
+      
+      if (Fetcher.Run() == pkgAcquire::Failed)
+	 return false;
+      
+      // Print out errors
+      bool Failed = false;
+      for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I != Fetcher.ItemsEnd(); I++)
+      {
+	 if ((*I)->Status == pkgAcquire::Item::StatDone &&
+	     (*I)->Complete == true)
+	    continue;
+	 
+	 if ((*I)->Status == pkgAcquire::Item::StatIdle)
+	 {
+	    Transient = true;
+	    // Failed = true;
+	    continue;
+	 }
+
+	 fprintf(stderr,_("Failed to fetch %s  %s\n"),(*I)->DescURI().c_str(),
+		 (*I)->ErrorText.c_str());
+	 Failed = true;
+      }
+
+      /* If we are in no download mode and missing files and there were
+         'failures' then the user must specify -m. Furthermore, there 
+         is no such thing as a transient error in no-download mode! */
+      if (Transient == true &&
+	  _config->FindB("APT::Get::Download",true) == false)
+      {
+	 Transient = false;
+	 Failed = true;
+      }
+      
+      if (_config->FindB("APT::Get::Download-Only",false) == true)
+      {
+	 if (Failed == true && _config->FindB("APT::Get::Fix-Missing",false) == false)
+	    return _error->Error(_("Some files failed to download"));
+	 c1out << _("Download complete and in download only mode") << endl;
+	 return true;
+      }
+      
+      if (Failed == true && _config->FindB("APT::Get::Fix-Missing",false) == false)
+      {
+	 return _error->Error(_("Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?"));
+      }
+      
+      if (Transient == true && Failed == true)
+	 return _error->Error(_("--fix-missing and media swapping is not currently supported"));
+      
+      // Try to deal with missing package files
+      if (Failed == true && PM->FixMissing() == false)
+      {
+	 cerr << _("Unable to correct missing packages.") << endl;
+	 return _error->Error(_("Aborting Install."));
+      }
+       	 
+      _system->UnLock();
+      pkgPackageManager::OrderResult Res = PM->DoInstall();
+      if (Res == pkgPackageManager::Failed || _error->PendingError() == true)
+	 return false;
+      if (Res == pkgPackageManager::Completed)
+	 return true;
+      
+      // Reload the fetcher object and loop again for media swapping
+      Fetcher.Shutdown();
+      if (PM->GetArchives(&Fetcher,&List,&Recs) == false)
+	 return false;
+      
+      _system->Lock();
+   }   
+}
+									/*}}}*/
+// TryToInstall - Try to install a single package			/*{{{*/
+// ---------------------------------------------------------------------
+/* This used to be inlined in DoInstall, but with the advent of regex package
+   name matching it was split out.. */
+bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
+		  pkgProblemResolver &Fix,bool Remove,bool BrokenFix,
+		  unsigned int &ExpectedInst,bool AllowFail = true)
+{
+   /* This is a pure virtual package and there is a single available 
+      provides */
+   if (Cache[Pkg].CandidateVer == 0 && Pkg->ProvidesList != 0 &&
+       Pkg.ProvidesList()->NextProvides == 0)
+   {
+      pkgCache::PkgIterator Tmp = Pkg.ProvidesList().OwnerPkg();
+      ioprintf(c1out,_("Note, selecting %s instead of %s\n"),
+	       Tmp.Name(),Pkg.Name());
+      Pkg = Tmp;
+   }
+   
+   // Handle the no-upgrade case
+   if (_config->FindB("APT::Get::upgrade",true) == false &&
+       Pkg->CurrentVer != 0)
+   {
+      if (AllowFail == true)
+	 ioprintf(c1out,_("Skipping %s, it is already installed and upgrade is not set.\n"),
+		  Pkg.Name());
+      return true;
+   }
+   
+   // Check if there is something at all to install
+   pkgDepCache::StateCache &State = Cache[Pkg];
+   if (Remove == true && Pkg->CurrentVer == 0)
+   {
+      Fix.Clear(Pkg);
+      Fix.Protect(Pkg);
+      Fix.Remove(Pkg);
+      
+      /* We want to continue searching for regex hits, so we return false here
+         otherwise this is not really an error. */
+      if (AllowFail == false)
+	 return false;
+      
+      ioprintf(c1out,_("Package %s is not installed, so not removed\n"),Pkg.Name());
+      return true;
+   }
+   
+   if (State.CandidateVer == 0 && Remove == false)
+   {
+      if (AllowFail == false)
+	 return false;
+      
+      if (Pkg->ProvidesList != 0)
+      {
+	 ioprintf(c1out,_("Package %s is a virtual package provided by:\n"),
+		  Pkg.Name());
+	 
+	 pkgCache::PrvIterator I = Pkg.ProvidesList();
+	 for (; I.end() == false; I++)
+	 {
+	    pkgCache::PkgIterator Pkg = I.OwnerPkg();
+	    
+	    if (Cache[Pkg].CandidateVerIter(Cache) == I.OwnerVer())
+	    {
+	       if (Cache[Pkg].Install() == true && Cache[Pkg].NewInstall() == false)
+		  c1out << "  " << Pkg.Name() << " " << I.OwnerVer().VerStr() <<
+		  _(" [Installed]") << endl;
+	       else
+		  c1out << "  " << Pkg.Name() << " " << I.OwnerVer().VerStr() << endl;
+	    }      
+	 }
+	 c1out << _("You should explicitly select one to install.") << endl;
+      }
+      else
+      {
+	 ioprintf(c1out,
+	 _("Package %s is not available, but is referred to by another package.\n"
+	   "This may mean that the package is missing, has been obsoleted, or\n"
+           "is only available from another source\n"),Pkg.Name());
+	 
+	 string List;
+	 string VersionsList;
+	 SPtrArray<bool> Seen = new bool[Cache.Head().PackageCount];
+	 memset(Seen,0,Cache.Head().PackageCount*sizeof(*Seen));
+	 pkgCache::DepIterator Dep = Pkg.RevDependsList();
+	 for (; Dep.end() == false; Dep++)
+	 {
+	    if (Dep->Type != pkgCache::Dep::Replaces)
+	       continue;
+	    if (Seen[Dep.ParentPkg()->ID] == true)
+	       continue;
+	    Seen[Dep.ParentPkg()->ID] = true;
+	    List += string(Dep.ParentPkg().Name()) + " ";
+        //VersionsList += string(Dep.ParentPkg().CurVersion) + "\n"; ???
+	 }	    
+	 ShowList(c1out,_("However the following packages replace it:"),List,VersionsList);
+      }
+      
+      _error->Error(_("Package %s has no installation candidate"),Pkg.Name());
+      return false;
+   }
+
+   Fix.Clear(Pkg);
+   Fix.Protect(Pkg);   
+   if (Remove == true)
+   {
+      Fix.Remove(Pkg);
+      Cache.MarkDelete(Pkg,_config->FindB("APT::Get::Purge",false));
+      return true;
+   }
+   
+   // Install it
+   Cache.MarkInstall(Pkg,false);
+   if (State.Install() == false)
+   {
+      if (_config->FindB("APT::Get::ReInstall",false) == true)
+      {
+	 if (Pkg->CurrentVer == 0 || Pkg.CurrentVer().Downloadable() == false)
+	    ioprintf(c1out,_("Reinstallation of %s is not possible, it cannot be downloaded.\n"),
+		     Pkg.Name());
+	 else
+	    Cache.SetReInstall(Pkg,true);
+      }      
+      else
+      {
+	 if (AllowFail == true)
+	    ioprintf(c1out,_("%s is already the newest version.\n"),
+		     Pkg.Name());
+      }      
+   }   
+   else
+      ExpectedInst++;
+   
+   // Install it with autoinstalling enabled.
+   if (State.InstBroken() == true && BrokenFix == false)
+      Cache.MarkInstall(Pkg,true);
+   return true;
+}
+									/*}}}*/
+// TryToChangeVer - Try to change a candidate version			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool TryToChangeVer(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
+		    const char *VerTag,bool IsRel)
+{
+   pkgVersionMatch Match(VerTag,(IsRel == true?pkgVersionMatch::Release : 
+				 pkgVersionMatch::Version));
+   
+   pkgCache::VerIterator Ver = Match.Find(Pkg);
+			 
+   if (Ver.end() == true)
+   {
+      if (IsRel == true)
+	 return _error->Error(_("Release '%s' for '%s' was not found"),
+			      VerTag,Pkg.Name());
+      return _error->Error(_("Version '%s' for '%s' was not found"),
+			   VerTag,Pkg.Name());
+   }
+   
+   if (strcmp(VerTag,Ver.VerStr()) != 0)
+   {
+      ioprintf(c1out,_("Selected version %s (%s) for %s\n"),
+	       Ver.VerStr(),Ver.RelStr().c_str(),Pkg.Name());
+   }
+   
+   Cache.SetCandidateVersion(Ver);
+   return true;
+}
+									/*}}}*/
+// FindSrc - Find a source record					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+pkgSrcRecords::Parser *FindSrc(const char *Name,pkgRecords &Recs,
+			       pkgSrcRecords &SrcRecs,string &Src,
+			       pkgDepCache &Cache)
+{
+   // We want to pull the version off the package specification..
+   string VerTag;
+   string TmpSrc = Name;
+   string::size_type Slash = TmpSrc.rfind('=');
+   if (Slash != string::npos)
+   {
+      VerTag = string(TmpSrc.begin() + Slash + 1,TmpSrc.end());
+      TmpSrc = string(TmpSrc.begin(),TmpSrc.begin() + Slash);
+   }
+   
+   /* Lookup the version of the package we would install if we were to
+      install a version and determine the source package name, then look
+      in the archive for a source package of the same name. In theory
+      we could stash the version string as well and match that too but
+      today there aren't multi source versions in the archive. */
+   if (_config->FindB("APT::Get::Only-Source") == false && 
+       VerTag.empty() == true)
+   {
+      pkgCache::PkgIterator Pkg = Cache.FindPkg(TmpSrc);
+      if (Pkg.end() == false)
+      {
+	 pkgCache::VerIterator Ver = Cache.GetCandidateVer(Pkg);      
+	 if (Ver.end() == false)
+	 {
+	    pkgRecords::Parser &Parse = Recs.Lookup(Ver.FileList());
+	    Src = Parse.SourcePkg();
+	 }
+      }   
+   }
+   
+   // No source package name..
+   if (Src.empty() == true)
+      Src = TmpSrc;
+   
+   // The best hit
+   pkgSrcRecords::Parser *Last = 0;
+   unsigned long Offset = 0;
+   string Version;
+   bool IsMatch = false;
+   
+   // If we are matching by version then we need exact matches to be happy
+   if (VerTag.empty() == false)
+      IsMatch = true;
+   
+   /* Iterate over all of the hits, which includes the resulting
+      binary packages in the search */
+   pkgSrcRecords::Parser *Parse;
+   SrcRecs.Restart();
+   while ((Parse = SrcRecs.Find(Src.c_str(),false)) != 0)
+   {
+      string Ver = Parse->Version();
+      
+      // Skip name mismatches
+      if (IsMatch == true && Parse->Package() != Src)
+	 continue;
+      
+      if (VerTag.empty() == false)
+      {
+	 /* Don't want to fall through because we are doing exact version 
+	    matching. */
+	 if (Cache.VS().CmpVersion(VerTag,Ver) != 0)
+	    continue;
+	 
+	 Last = Parse;
+	 Offset = Parse->Offset();
+	 break;
+      }
+				  
+      // Newer version or an exact match
+      if (Last == 0 || Cache.VS().CmpVersion(Version,Ver) < 0 || 
+	  (Parse->Package() == Src && IsMatch == false))
+      {
+	 IsMatch = Parse->Package() == Src;
+	 Last = Parse;
+	 Offset = Parse->Offset();
+	 Version = Ver;
+      }      
+   }
+   
+   if (Last == 0)
+      return 0;
+   
+   if (Last->Jump(Offset) == false)
+      return 0;
+   
+   return Last;
+}
+									/*}}}*/
+
+// DoUpdate - Update the package lists					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool DoUpdate(CommandLine &CmdL)
+{
+   if (CmdL.FileSize() != 1)
+      return _error->Error(_("The update command takes no arguments"));
+   
+   // Get the source list
+   pkgSourceList List;
+   if (List.ReadMainList() == false)
+      return false;
+
+   // Lock the list directory
+   FileFd Lock;
+   if (_config->FindB("Debug::NoLocking",false) == false)
+   {
+      Lock.Fd(GetLock(_config->FindDir("Dir::State::Lists") + "lock"));
+      if (_error->PendingError() == true)
+	 return _error->Error(_("Unable to lock the list directory"));
+   }
+   
+   // Create the download object
+   AcqTextStatus Stat(ScreenWidth,_config->FindI("quiet",0));
+   pkgAcquire Fetcher(&Stat);
+
+   // Populate it with the source selection
+   if (List.GetIndexes(&Fetcher) == false)
+	 return false;
+   
+   // Just print out the uris an exit if the --print-uris flag was used
+   if (_config->FindB("APT::Get::Print-URIs") == true)
+   {
+      pkgAcquire::UriIterator I = Fetcher.UriBegin();
+      for (; I != Fetcher.UriEnd(); I++)
+	 cout << '\'' << I->URI << "' " << flNotDir(I->Owner->DestFile) << ' ' << 
+	       I->Owner->FileSize << ' ' << I->Owner->MD5Sum() << endl;
+      return true;
+   }
+   
+   // Run it
+   if (Fetcher.Run() == pkgAcquire::Failed)
+      return false;
+
+   bool Failed = false;
+   for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I != Fetcher.ItemsEnd(); I++)
+   {
+      if ((*I)->Status == pkgAcquire::Item::StatDone)
+	 continue;
+
+      (*I)->Finished();
+      
+      fprintf(stderr,_("Failed to fetch %s  %s\n"),(*I)->DescURI().c_str(),
+	      (*I)->ErrorText.c_str());
+      Failed = true;
+   }
+   
+   // Clean out any old list files
+   if (_config->FindB("APT::Get::List-Cleanup",true) == true)
+   {
+      if (Fetcher.Clean(_config->FindDir("Dir::State::lists")) == false ||
+	  Fetcher.Clean(_config->FindDir("Dir::State::lists") + "partial/") == false)
+	 return false;
+   }
+   
+   // Prepare the cache.   
+   CacheFile Cache;
+   if (Cache.BuildCaches() == false)
+      return false;
+   
+   if (Failed == true)
+      return _error->Error(_("Some index files failed to download, they have been ignored, or old ones used instead."));
+   
+   return true;
+}
+									/*}}}*/
+// DoUpgrade - Upgrade all packages					/*{{{*/
+// ---------------------------------------------------------------------
+/* Upgrade all packages without installing new packages or erasing old
+   packages */
+bool DoUpgrade(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   if (Cache.OpenForInstall() == false || Cache.CheckDeps() == false)
+      return false;
+
+   // Do the upgrade
+   if (pkgAllUpgrade(Cache) == false)
+   {
+      ShowBroken(c1out,Cache,false);
+      return _error->Error(_("Internal Error, AllUpgrade broke stuff"));
+   }
+   
+   return InstallPackages(Cache,true);
+}
+									/*}}}*/
+// DoInstall - Install packages from the command line			/*{{{*/
+// ---------------------------------------------------------------------
+/* Install named packages */
+bool DoInstall(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   if (Cache.OpenForInstall() == false || 
+       Cache.CheckDeps(CmdL.FileSize() != 1) == false)
+      return false;
+   
+   // Enter the special broken fixing mode if the user specified arguments
+   bool BrokenFix = false;
+   if (Cache->BrokenCount() != 0)
+      BrokenFix = true;
+   
+   unsigned int ExpectedInst = 0;
+   unsigned int Packages = 0;
+   pkgProblemResolver Fix(Cache);
+   
+   bool DefRemove = false;
+   if (strcasecmp(CmdL.FileList[0],"remove") == 0)
+      DefRemove = true;
+
+   for (const char **I = CmdL.FileList + 1; *I != 0; I++)
+   {
+      // Duplicate the string
+      unsigned int Length = strlen(*I);
+      char S[300];
+      if (Length >= sizeof(S))
+	 continue;
+      strcpy(S,*I);
+      
+      // See if we are removing and special indicators..
+      bool Remove = DefRemove;
+      char *VerTag = 0;
+      bool VerIsRel = false;
+      while (Cache->FindPkg(S).end() == true)
+      {
+	 // Handle an optional end tag indicating what to do
+	 if (Length >= 1 && S[Length - 1] == '-')
+	 {
+	    Remove = true;
+	    S[--Length] = 0;
+	    continue;
+	 }
+	 
+	 if (Length >= 1 && S[Length - 1] == '+')
+	 {
+	    Remove = false;
+	    S[--Length] = 0;
+	    continue;
+	 }
+	 
+	 char *Slash = strchr(S,'=');
+	 if (Slash != 0)
+	 {
+	    VerIsRel = false;
+	    *Slash = 0;
+	    VerTag = Slash + 1;
+	 }
+	 
+	 Slash = strchr(S,'/');
+	 if (Slash != 0)
+	 {
+	    VerIsRel = true;
+	    *Slash = 0;
+	    VerTag = Slash + 1;
+	 }
+	 
+	 break;
+      }
+      
+      // Locate the package
+      pkgCache::PkgIterator Pkg = Cache->FindPkg(S);
+      Packages++;
+      if (Pkg.end() == true)
+      {
+	 // Check if the name is a regex
+	 const char *I;
+	 for (I = S; *I != 0; I++)
+	    if (*I == '?' || *I == '*' || *I == '|' ||
+	        *I == '[' || *I == '^' || *I == '$')
+	       break;
+	 if (*I == 0)
+	    return _error->Error(_("Couldn't find package %s"),S);
+
+	 // Regexs must always be confirmed
+	 ExpectedInst += 1000;
+	 
+	 // Compile the regex pattern
+	 regex_t Pattern;
+	 int Res;
+	 if ((Res = regcomp(&Pattern,S,REG_EXTENDED | REG_ICASE |
+		     REG_NOSUB)) != 0)
+	 {
+	    char Error[300];	    
+	    regerror(Res,&Pattern,Error,sizeof(Error));
+	    return _error->Error(_("Regex compilation error - %s"),Error);
+	 }
+	 
+	 // Run over the matches
+	 bool Hit = false;
+	 for (Pkg = Cache->PkgBegin(); Pkg.end() == false; Pkg++)
+	 {
+	    if (regexec(&Pattern,Pkg.Name(),0,0,0) != 0)
+	       continue;
+	    
+	    ioprintf(c1out,_("Note, selecting %s for regex '%s'\n"),
+		     Pkg.Name(),S);
+	    
+	    if (VerTag != 0)
+	       if (TryToChangeVer(Pkg,Cache,VerTag,VerIsRel) == false)
+		  return false;
+	    
+	    Hit |= TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,
+				ExpectedInst,false);
+	 }
+	 regfree(&Pattern);
+	 
+	 if (Hit == false)
+	    return _error->Error(_("Couldn't find package %s"),S);
+      }
+      else
+      {
+	 if (VerTag != 0)
+	    if (TryToChangeVer(Pkg,Cache,VerTag,VerIsRel) == false)
+	       return false;
+	 if (TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,ExpectedInst) == false)
+	    return false;
+      }      
+   }
+
+   /* If we are in the Broken fixing mode we do not attempt to fix the
+      problems. This is if the user invoked install without -f and gave
+      packages */
+   if (BrokenFix == true && Cache->BrokenCount() != 0)
+   {
+      c1out << _("You might want to run `apt-get -f install' to correct these:") << endl;
+      ShowBroken(c1out,Cache,false);
+
+      return _error->Error(_("Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution)."));
+   }
+   
+   // Call the scored problem resolver
+   Fix.InstallProtect();
+   if (Fix.Resolve(true) == false)
+      _error->Discard();
+
+   // Now we check the state of the packages,
+   if (Cache->BrokenCount() != 0)
+   {
+      c1out << 
+       _("Some packages could not be installed. This may mean that you have\n" 
+	 "requested an impossible situation or if you are using the unstable\n" 
+	 "distribution that some required packages have not yet been created\n"
+	 "or been moved out of Incoming.") << endl;
+      if (Packages == 1)
+      {
+	 c1out << endl;
+	 c1out << 
+	  _("Since you only requested a single operation it is extremely likely that\n"
+	    "the package is simply not installable and a bug report against\n" 
+	    "that package should be filed.") << endl;
+      }
+
+      c1out << _("The following information may help to resolve the situation:") << endl;
+      c1out << endl;
+      ShowBroken(c1out,Cache,false);
+      return _error->Error(_("Broken packages"));
+   }   
+   
+   /* Print out a list of packages that are going to be installed extra
+      to what the user asked */
+   if (Cache->InstCount() != ExpectedInst)
+   {
+      string List;
+      string VersionsList;
+      for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+      {
+	 pkgCache::PkgIterator I(Cache,Cache.List[J]);
+	 if ((*Cache)[I].Install() == false)
+	    continue;
+
+	 const char **J;
+	 for (J = CmdL.FileList + 1; *J != 0; J++)
+	    if (strcmp(*J,I.Name()) == 0)
+		break;
+	 
+	 if (*J == 0) {
+	    List += string(I.Name()) + " ";
+        VersionsList += string(Cache[I].CandVersion) + "\n";
+     }
+      }
+      
+      ShowList(c1out,_("The following extra packages will be installed:"),List,VersionsList);
+   }
+
+   /* Print out a list of suggested and recommended packages */
+   {
+      string SuggestsList, RecommendsList, List;
+      string SuggestsVersions, RecommendsVersions;
+      for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+      {
+	 pkgCache::PkgIterator I(Cache,Cache.List[J]);
+
+	 /* Just look at the ones we want to install */
+	 if ((*Cache)[I].Install() == false)
+	   continue;
+
+	 for (pkgCache::VerIterator V = I.VersionList(); V.end() == false; V++)
+         {
+	     for (pkgCache::DepIterator D = V.DependsList(); D.end() == false; )
+             {
+		 pkgCache::DepIterator Start;
+		 pkgCache::DepIterator End;
+		 D.GlobOr(Start,End); // advances D
+
+		 /* 
+		  * If this is a virtual package, we need to check the list of
+		  * packages that provide it and see if any of those are
+		  * installed
+		  */
+		 
+		 bool providedBySomething = false;
+		 for (pkgCache::PrvIterator Prv = Start.TargetPkg().ProvidesList();
+                      Prv.end() != true;
+                      Prv++)
+		    if ((*Cache)[Prv.OwnerPkg()].InstVerIter(*Cache).end() == false)
+                    {
+		       providedBySomething = true;
+		       break;
+		    }
+
+		 if (providedBySomething) continue;
+            
+                 for(;;)
+                 {
+                     /* Skip if package is  installed already, or is about to be */
+                     string target = string(Start.TargetPkg().Name()) + " ";
+
+                     if ((*Start.TargetPkg()).SelectedState == pkgCache::State::Install
+                         || Cache[Start.TargetPkg()].Install())
+                       break;
+
+                     /* Skip if we already saw it */
+                     if (int(SuggestsList.find(target)) != -1 || int(RecommendsList.find(target)) != -1)
+                       break; 
+
+		     if (Start->Type == pkgCache::Dep::Suggests) {
+		       SuggestsList += target;
+		       SuggestsVersions += string(Cache[Start.TargetPkg()].CandVersion) + "\n";
+		     }
+		     
+		     if (Start->Type == pkgCache::Dep::Recommends) {
+		       RecommendsList += target;
+		       RecommendsVersions += string(Cache[Start.TargetPkg()].CandVersion) + "\n";
+		     }
+
+                     if (Start >= End)
+                        break;
+                     Start++;
+                 }
+             }
+         }
+      }
+      ShowList(c1out,_("Suggested packages:"),SuggestsList,SuggestsVersions);
+      ShowList(c1out,_("Recommended packages:"),RecommendsList,RecommendsVersions);
+
+   }
+
+   // See if we need to prompt
+   if (Cache->InstCount() == ExpectedInst && Cache->DelCount() == 0)
+      return InstallPackages(Cache,false,false);
+   
+   return InstallPackages(Cache,false);   
+}
+									/*}}}*/
+// DoDistUpgrade - Automatic smart upgrader				/*{{{*/
+// ---------------------------------------------------------------------
+/* Intelligent upgrader that will install and remove packages at will */
+bool DoDistUpgrade(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   if (Cache.OpenForInstall() == false || Cache.CheckDeps() == false)
+      return false;
+
+   c0out << _("Calculating Upgrade... ") << flush;
+   if (pkgDistUpgrade(*Cache) == false)
+   {
+      c0out << _("Failed") << endl;
+      ShowBroken(c1out,Cache,false);
+      return false;
+   }
+   
+   c0out << _("Done") << endl;
+   
+   return InstallPackages(Cache,true);
+}
+									/*}}}*/
+// DoDSelectUpgrade - Do an upgrade by following dselects selections	/*{{{*/
+// ---------------------------------------------------------------------
+/* Follows dselect's selections */
+bool DoDSelectUpgrade(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   if (Cache.OpenForInstall() == false || Cache.CheckDeps() == false)
+      return false;
+   
+   // Install everything with the install flag set
+   pkgCache::PkgIterator I = Cache->PkgBegin();
+   for (;I.end() != true; I++)
+   {
+      /* Install the package only if it is a new install, the autoupgrader
+         will deal with the rest */
+      if (I->SelectedState == pkgCache::State::Install)
+	 Cache->MarkInstall(I,false);
+   }
+
+   /* Now install their deps too, if we do this above then order of
+      the status file is significant for | groups */
+   for (I = Cache->PkgBegin();I.end() != true; I++)
+   {
+      /* Install the package only if it is a new install, the autoupgrader
+         will deal with the rest */
+      if (I->SelectedState == pkgCache::State::Install)
+	 Cache->MarkInstall(I,true);
+   }
+   
+   // Apply erasures now, they override everything else.
+   for (I = Cache->PkgBegin();I.end() != true; I++)
+   {
+      // Remove packages 
+      if (I->SelectedState == pkgCache::State::DeInstall ||
+	  I->SelectedState == pkgCache::State::Purge)
+	 Cache->MarkDelete(I,I->SelectedState == pkgCache::State::Purge);
+   }
+
+   /* Resolve any problems that dselect created, allupgrade cannot handle
+      such things. We do so quite agressively too.. */
+   if (Cache->BrokenCount() != 0)
+   {      
+      pkgProblemResolver Fix(Cache);
+
+      // Hold back held packages.
+      if (_config->FindB("APT::Ignore-Hold",false) == false)
+      {
+	 for (pkgCache::PkgIterator I = Cache->PkgBegin(); I.end() == false; I++)
+	 {
+	    if (I->SelectedState == pkgCache::State::Hold)
+	    {
+	       Fix.Protect(I);
+	       Cache->MarkKeep(I);
+	    }
+	 }
+      }
+   
+      if (Fix.Resolve() == false)
+      {
+	 ShowBroken(c1out,Cache,false);
+	 return _error->Error("Internal Error, problem resolver broke stuff");
+      }
+   }
+
+   // Now upgrade everything
+   if (pkgAllUpgrade(Cache) == false)
+   {
+      ShowBroken(c1out,Cache,false);
+      return _error->Error("Internal Error, problem resolver broke stuff");
+   }
+   
+   return InstallPackages(Cache,false);
+}
+									/*}}}*/
+// DoClean - Remove download archives					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool DoClean(CommandLine &CmdL)
+{
+   if (_config->FindB("APT::Get::Simulate") == true)
+   {
+      cout << "Del " << _config->FindDir("Dir::Cache::archives") << "* " <<
+	 _config->FindDir("Dir::Cache::archives") << "partial/*" << endl;
+      return true;
+   }
+   
+   // Lock the archive directory
+   FileFd Lock;
+   if (_config->FindB("Debug::NoLocking",false) == false)
+   {
+      Lock.Fd(GetLock(_config->FindDir("Dir::Cache::Archives") + "lock"));
+      if (_error->PendingError() == true)
+	 return _error->Error(_("Unable to lock the download directory"));
+   }
+   
+   pkgAcquire Fetcher;
+   Fetcher.Clean(_config->FindDir("Dir::Cache::archives"));
+   Fetcher.Clean(_config->FindDir("Dir::Cache::archives") + "partial/");
+   return true;
+}
+									/*}}}*/
+// DoAutoClean - Smartly remove downloaded archives			/*{{{*/
+// ---------------------------------------------------------------------
+/* This is similar to clean but it only purges things that cannot be 
+   downloaded, that is old versions of cached packages. */
+class LogCleaner : public pkgArchiveCleaner
+{
+   protected:
+   virtual void Erase(const char *File,string Pkg,string Ver,struct stat &St) 
+   {
+      c1out << "Del " << Pkg << " " << Ver << " [" << SizeToStr(St.st_size) << "B]" << endl;
+      
+      if (_config->FindB("APT::Get::Simulate") == false)
+	 unlink(File);      
+   };
+};
+
+bool DoAutoClean(CommandLine &CmdL)
+{
+   // Lock the archive directory
+   FileFd Lock;
+   if (_config->FindB("Debug::NoLocking",false) == false)
+   {
+      Lock.Fd(GetLock(_config->FindDir("Dir::Cache::Archives") + "lock"));
+      if (_error->PendingError() == true)
+	 return _error->Error(_("Unable to lock the download directory"));
+   }
+   
+   CacheFile Cache;
+   if (Cache.Open() == false)
+      return false;
+   
+   LogCleaner Cleaner;
+   
+   return Cleaner.Go(_config->FindDir("Dir::Cache::archives"),*Cache) &&
+      Cleaner.Go(_config->FindDir("Dir::Cache::archives") + "partial/",*Cache);
+}
+									/*}}}*/
+// DoCheck - Perform the check operation				/*{{{*/
+// ---------------------------------------------------------------------
+/* Opening automatically checks the system, this command is mostly used
+   for debugging */
+bool DoCheck(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   Cache.Open();
+   Cache.CheckDeps();
+   
+   return true;
+}
+									/*}}}*/
+// DoSource - Fetch a source archive					/*{{{*/
+// ---------------------------------------------------------------------
+/* Fetch souce packages */
+struct DscFile
+{
+   string Package;
+   string Version;
+   string Dsc;
+};
+
+bool DoSource(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   if (Cache.Open(false) == false)
+      return false;
+
+   if (CmdL.FileSize() <= 1)
+      return _error->Error(_("Must specify at least one package to fetch source for"));
+   
+   // Read the source list
+   pkgSourceList List;
+   if (List.ReadMainList() == false)
+      return _error->Error(_("The list of sources could not be read."));
+   
+   // Create the text record parsers
+   pkgRecords Recs(Cache);
+   pkgSrcRecords SrcRecs(List);
+   if (_error->PendingError() == true)
+      return false;
+
+   // Create the download object
+   AcqTextStatus Stat(ScreenWidth,_config->FindI("quiet",0));   
+   pkgAcquire Fetcher(&Stat);
+
+   DscFile *Dsc = new DscFile[CmdL.FileSize()];
+   
+   // Load the requestd sources into the fetcher
+   unsigned J = 0;
+   for (const char **I = CmdL.FileList + 1; *I != 0; I++, J++)
+   {
+      string Src;
+      pkgSrcRecords::Parser *Last = FindSrc(*I,Recs,SrcRecs,Src,*Cache);
+      
+      if (Last == 0)
+	 return _error->Error(_("Unable to find a source package for %s"),Src.c_str());
+      
+      // Back track
+      vector<pkgSrcRecords::File> Lst;
+      if (Last->Files(Lst) == false)
+	 return false;
+
+      // Load them into the fetcher
+      for (vector<pkgSrcRecords::File>::const_iterator I = Lst.begin();
+	   I != Lst.end(); I++)
+      {
+	 // Try to guess what sort of file it is we are getting.
+	 if (I->Type == "dsc")
+	 {
+	    Dsc[J].Package = Last->Package();
+	    Dsc[J].Version = Last->Version();
+	    Dsc[J].Dsc = flNotDir(I->Path);
+	 }
+	 
+	 // Diff only mode only fetches .diff files
+	 if (_config->FindB("APT::Get::Diff-Only",false) == true &&
+	     I->Type != "diff")
+	    continue;
+	 
+	 // Tar only mode only fetches .tar files
+	 if (_config->FindB("APT::Get::Tar-Only",false) == true &&
+	     I->Type != "tar")
+	    continue;
+	 
+	 new pkgAcqFile(&Fetcher,Last->Index().ArchiveURI(I->Path),
+			I->MD5Hash,I->Size,
+			Last->Index().SourceInfo(*Last,*I),Src);
+      }
+   }
+   
+   // Display statistics
+   double FetchBytes = Fetcher.FetchNeeded();
+   double FetchPBytes = Fetcher.PartialPresent();
+   double DebBytes = Fetcher.TotalNeeded();
+
+   // Check for enough free space
+   struct statvfs Buf;
+   string OutputDir = ".";
+   if (statvfs(OutputDir.c_str(),&Buf) != 0)
+      return _error->Errno("statvfs","Couldn't determine free space in %s",
+			   OutputDir.c_str());
+   if (unsigned(Buf.f_bfree) < (FetchBytes - FetchPBytes)/Buf.f_bsize)
+      return _error->Error(_("You don't have enough free space in %s"),
+			   OutputDir.c_str());
+   
+   // Number of bytes
+   if (DebBytes != FetchBytes)
+      ioprintf(c1out,_("Need to get %sB/%sB of source archives.\n"),
+	       SizeToStr(FetchBytes).c_str(),SizeToStr(DebBytes).c_str());
+   else
+      ioprintf(c1out,_("Need to get %sB of source archives.\n"),
+	       SizeToStr(DebBytes).c_str());
+   
+   if (_config->FindB("APT::Get::Simulate",false) == true)
+   {
+      for (unsigned I = 0; I != J; I++)
+	 ioprintf(cout,_("Fetch Source %s\n"),Dsc[I].Package.c_str());
+      return true;
+   }
+   
+   // Just print out the uris an exit if the --print-uris flag was used
+   if (_config->FindB("APT::Get::Print-URIs") == true)
+   {
+      pkgAcquire::UriIterator I = Fetcher.UriBegin();
+      for (; I != Fetcher.UriEnd(); I++)
+	 cout << '\'' << I->URI << "' " << flNotDir(I->Owner->DestFile) << ' ' << 
+	       I->Owner->FileSize << ' ' << I->Owner->MD5Sum() << endl;
+      return true;
+   }
+   
+   // Run it
+   if (Fetcher.Run() == pkgAcquire::Failed)
+      return false;
+
+   // Print error messages
+   bool Failed = false;
+   for (pkgAcquire::ItemIterator I = Fetcher.ItemsBegin(); I != Fetcher.ItemsEnd(); I++)
+   {
+      if ((*I)->Status == pkgAcquire::Item::StatDone &&
+	  (*I)->Complete == true)
+	 continue;
+      
+      fprintf(stderr,_("Failed to fetch %s  %s\n"),(*I)->DescURI().c_str(),
+	      (*I)->ErrorText.c_str());
+      Failed = true;
+   }
+   if (Failed == true)
+      return _error->Error(_("Failed to fetch some archives."));
+   
+   if (_config->FindB("APT::Get::Download-only",false) == true)
+   {
+      c1out << _("Download complete and in download only mode") << endl;
+      return true;
+   }
+
+   // Unpack the sources
+   pid_t Process = ExecFork();
+   
+   if (Process == 0)
+   {
+      for (unsigned I = 0; I != J; I++)
+      {
+	 string Dir = Dsc[I].Package + '-' + Cache->VS().UpstreamVersion(Dsc[I].Version.c_str());
+	 
+	 // Diff only mode only fetches .diff files
+	 if (_config->FindB("APT::Get::Diff-Only",false) == true ||
+	     _config->FindB("APT::Get::Tar-Only",false) == true ||
+	     Dsc[I].Dsc.empty() == true)
+	    continue;
+
+	 // See if the package is already unpacked
+	 struct stat Stat;
+	 if (stat(Dir.c_str(),&Stat) == 0 &&
+	     S_ISDIR(Stat.st_mode) != 0)
+	 {
+	    ioprintf(c0out ,_("Skipping unpack of already unpacked source in %s\n"),
+			      Dir.c_str());
+	 }
+	 else
+	 {
+	    // Call dpkg-source
+	    char S[500];
+	    snprintf(S,sizeof(S),"%s -x %s",
+		     _config->Find("Dir::Bin::dpkg-source","dpkg-source").c_str(),
+		     Dsc[I].Dsc.c_str());
+	    if (system(S) != 0)
+	    {
+	       fprintf(stderr,_("Unpack command '%s' failed.\n"),S);
+	       _exit(1);
+	    }	    
+	 }
+	 
+	 // Try to compile it with dpkg-buildpackage
+	 if (_config->FindB("APT::Get::Compile",false) == true)
+	 {
+	    // Call dpkg-buildpackage
+	    char S[500];
+	    snprintf(S,sizeof(S),"cd %s && %s %s",
+		     Dir.c_str(),
+		     _config->Find("Dir::Bin::dpkg-buildpackage","dpkg-buildpackage").c_str(),
+		     _config->Find("DPkg::Build-Options","-b -uc").c_str());
+	    
+	    if (system(S) != 0)
+	    {
+	       fprintf(stderr,_("Build command '%s' failed.\n"),S);
+	       _exit(1);
+	    }	    
+	 }      
+      }
+      
+      _exit(0);
+   }
+   
+   // Wait for the subprocess
+   int Status = 0;
+   while (waitpid(Process,&Status,0) != Process)
+   {
+      if (errno == EINTR)
+	 continue;
+      return _error->Errno("waitpid","Couldn't wait for subprocess");
+   }
+
+   if (WIFEXITED(Status) == 0 || WEXITSTATUS(Status) != 0)
+      return _error->Error(_("Child process failed"));
+   
+   return true;
+}
+									/*}}}*/
+// DoBuildDep - Install/removes packages to satisfy build dependencies  /*{{{*/
+// ---------------------------------------------------------------------
+/* This function will look at the build depends list of the given source 
+   package and install the necessary packages to make it true, or fail. */
+bool DoBuildDep(CommandLine &CmdL)
+{
+   CacheFile Cache;
+   if (Cache.Open(true) == false)
+      return false;
+
+   if (CmdL.FileSize() <= 1)
+      return _error->Error(_("Must specify at least one package to check builddeps for"));
+   
+   // Read the source list
+   pkgSourceList List;
+   if (List.ReadMainList() == false)
+      return _error->Error(_("The list of sources could not be read."));
+   
+   // Create the text record parsers
+   pkgRecords Recs(Cache);
+   pkgSrcRecords SrcRecs(List);
+   if (_error->PendingError() == true)
+      return false;
+
+   // Create the download object
+   AcqTextStatus Stat(ScreenWidth,_config->FindI("quiet",0));   
+   pkgAcquire Fetcher(&Stat);
+
+   unsigned J = 0;
+   for (const char **I = CmdL.FileList + 1; *I != 0; I++, J++)
+   {
+      string Src;
+      pkgSrcRecords::Parser *Last = FindSrc(*I,Recs,SrcRecs,Src,*Cache);
+      if (Last == 0)
+	 return _error->Error(_("Unable to find a source package for %s"),Src.c_str());
+            
+      // Process the build-dependencies
+      vector<pkgSrcRecords::Parser::BuildDepRec> BuildDeps;
+      if (Last->BuildDepends(BuildDeps, _config->FindB("APT::Get::Arch-Only",false)) == false)
+      	return _error->Error(_("Unable to get build-dependency information for %s"),Src.c_str());
+   
+      // Also ensure that build-essential packages are present
+      Configuration::Item const *Opts = _config->Tree("APT::Build-Essential");
+      if (Opts) 
+	 Opts = Opts->Child;
+      for (; Opts; Opts = Opts->Next)
+      {
+	 if (Opts->Value.empty() == true)
+	    continue;
+
+         pkgSrcRecords::Parser::BuildDepRec rec;
+	 rec.Package = Opts->Value;
+	 rec.Type = pkgSrcRecords::Parser::BuildDependIndep;
+	 rec.Op = 0;
+	 BuildDeps.push_back(rec);
+      }
+
+      if (BuildDeps.size() == 0)
+      {
+	 ioprintf(c1out,_("%s has no build depends.\n"),Src.c_str());
+	 continue;
+      }
+      
+      // Install the requested packages
+      unsigned int ExpectedInst = 0;
+      vector <pkgSrcRecords::Parser::BuildDepRec>::iterator D;
+      pkgProblemResolver Fix(Cache);
+      bool skipAlternatives = false; // skip remaining alternatives in an or group
+      for (D = BuildDeps.begin(); D != BuildDeps.end(); D++)
+      {
+         bool hasAlternatives = (((*D).Op & pkgCache::Dep::Or) == pkgCache::Dep::Or);
+
+         if (skipAlternatives == true)
+         {
+            if (!hasAlternatives)
+               skipAlternatives = false; // end of or group
+            continue;
+         }
+
+         if ((*D).Type == pkgSrcRecords::Parser::BuildConflict ||
+	     (*D).Type == pkgSrcRecords::Parser::BuildConflictIndep)
+         {
+            pkgCache::PkgIterator Pkg = Cache->FindPkg((*D).Package);
+            // Build-conflicts on unknown packages are silently ignored
+            if (Pkg.end() == true)
+               continue;
+
+            pkgCache::VerIterator IV = (*Cache)[Pkg].InstVerIter(*Cache);
+
+            /* 
+             * Remove if we have an installed version that satisfies the 
+             * version criteria
+             */
+            if (IV.end() == false && 
+                Cache->VS().CheckDep(IV.VerStr(),(*D).Op,(*D).Version.c_str()) == true)
+               TryToInstall(Pkg,Cache,Fix,true,false,ExpectedInst);
+         }
+	 else // BuildDep || BuildDepIndep
+         {
+	    pkgCache::PkgIterator Pkg = Cache->FindPkg((*D).Package);
+            if (_config->FindB("Debug::BuildDeps",false) == true)
+                 cout << "Looking for " << (*D).Package << "...\n";
+
+	    if (Pkg.end() == true)
+            {
+               if (_config->FindB("Debug::BuildDeps",false) == true)
+                    cout << " (not found)" << (*D).Package << endl;
+
+               if (hasAlternatives)
+                  continue;
+
+               return _error->Error(_("%s dependency for %s cannot be satisfied "
+                                      "because the package %s cannot be found"),
+                                    Last->BuildDepType((*D).Type),Src.c_str(),
+                                    (*D).Package.c_str());
+            }
+
+            /*
+             * if there are alternatives, we've already picked one, so skip
+             * the rest
+             *
+             * TODO: this means that if there's a build-dep on A|B and B is
+             * installed, we'll still try to install A; more importantly,
+             * if A is currently broken, we cannot go back and try B. To fix 
+             * this would require we do a Resolve cycle for each package we 
+             * add to the install list. Ugh
+             */
+                       
+	    /* 
+	     * If this is a virtual package, we need to check the list of
+	     * packages that provide it and see if any of those are
+	     * installed
+	     */
+            pkgCache::PrvIterator Prv = Pkg.ProvidesList();
+            for (; Prv.end() != true; Prv++)
+	    {
+               if (_config->FindB("Debug::BuildDeps",false) == true)
+                    cout << "  Checking provider " << Prv.OwnerPkg().Name() << endl;
+
+	       if ((*Cache)[Prv.OwnerPkg()].InstVerIter(*Cache).end() == false)
+	          break;
+            }
+            
+            // Get installed version and version we are going to install
+	    pkgCache::VerIterator IV = (*Cache)[Pkg].InstVerIter(*Cache);
+
+            if ((*D).Version[0] != '\0') {
+                 // Versioned dependency
+
+                 pkgCache::VerIterator CV = (*Cache)[Pkg].CandidateVerIter(*Cache);
+
+                 for (; CV.end() != true; CV++)
+                 {
+                      if (Cache->VS().CheckDep(CV.VerStr(),(*D).Op,(*D).Version.c_str()) == true)
+                           break;
+                 }
+                 if (CV.end() == true)
+		   if (hasAlternatives)
+		   {
+		      continue;
+		   }
+		   else
+		   {
+                      return _error->Error(_("%s dependency for %s cannot be satisfied "
+                                             "because no available versions of package %s "
+                                             "can satisfy version requirements"),
+                                           Last->BuildDepType((*D).Type),Src.c_str(),
+                                           (*D).Package.c_str());
+		   }
+            }
+            else
+            {
+               // Only consider virtual packages if there is no versioned dependency
+               if (Prv.end() == false)
+               {
+                  if (_config->FindB("Debug::BuildDeps",false) == true)
+                     cout << "  Is provided by installed package " << Prv.OwnerPkg().Name() << endl;
+                  skipAlternatives = hasAlternatives;
+                  continue;
+               }
+            }
+
+            if (IV.end() == false)
+            {
+               if (_config->FindB("Debug::BuildDeps",false) == true)
+                  cout << "  Is installed\n";
+
+               if (Cache->VS().CheckDep(IV.VerStr(),(*D).Op,(*D).Version.c_str()) == true)
+               {
+                  skipAlternatives = hasAlternatives;
+                  continue;
+               }
+
+               if (_config->FindB("Debug::BuildDeps",false) == true)
+                  cout << "    ...but the installed version doesn't meet the version requirement\n";
+
+               if (((*D).Op & pkgCache::Dep::LessEq) == pkgCache::Dep::LessEq)
+               {
+                  return _error->Error(_("Failed to satisfy %s dependency for %s: Installed package %s is too new"),
+                                       Last->BuildDepType((*D).Type),
+                                       Src.c_str(),
+                                       Pkg.Name());
+               }
+            }
+
+
+            if (_config->FindB("Debug::BuildDeps",false) == true)
+               cout << "  Trying to install " << (*D).Package << endl;
+
+            if (TryToInstall(Pkg,Cache,Fix,false,false,ExpectedInst) == true)
+            {
+               // We successfully installed something; skip remaining alternatives
+               skipAlternatives = hasAlternatives;
+               continue;
+            }
+            else if (hasAlternatives)
+            {
+               if (_config->FindB("Debug::BuildDeps",false) == true)
+                  cout << "  Unsatisfiable, trying alternatives\n";
+               continue;
+            }
+            else
+            {
+               return _error->Error(_("Failed to satisfy %s dependency for %s: %s"),
+                                    Last->BuildDepType((*D).Type),
+                                    Src.c_str(),
+                                    (*D).Package.c_str());
+            }
+	 }	       
+      }
+      
+      Fix.InstallProtect();
+      if (Fix.Resolve(true) == false)
+	 _error->Discard();
+      
+      // Now we check the state of the packages,
+      if (Cache->BrokenCount() != 0)
+         return _error->Error(_("Build-dependencies for %s could not be satisfied."),*I);
+   }
+  
+   if (InstallPackages(Cache, false, true) == false)
+      return _error->Error(_("Failed to process build dependencies"));
+   return true;
+}
+									/*}}}*/
+
+// DoMoo - Never Ask, Never Tell					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool DoMoo(CommandLine &CmdL)
+{
+   cout << 
+      "         (__) \n"
+      "         (oo) \n"
+      "   /------\\/ \n"
+      "  / |    ||   \n" 
+      " *  /\\---/\\ \n"
+      "    ~~   ~~   \n"
+      "....\"Have you mooed today?\"...\n";
+			    
+   return true;
+}
+									/*}}}*/
+// ShowHelp - Show a help screen					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool ShowHelp(CommandLine &CmdL)
+{
+   ioprintf(cout,_("%s %s for %s %s compiled on %s %s\n"),PACKAGE,VERSION,
+	    COMMON_OS,COMMON_CPU,__DATE__,__TIME__);
+	    
+   if (_config->FindB("version") == true)
+   {
+      cout << _("Supported Modules:") << endl;
+      
+      for (unsigned I = 0; I != pkgVersioningSystem::GlobalListLen; I++)
+      {
+	 pkgVersioningSystem *VS = pkgVersioningSystem::GlobalList[I];
+	 if (_system != 0 && _system->VS == VS)
+	    cout << '*';
+	 else
+	    cout << ' ';
+	 cout << "Ver: " << VS->Label << endl;
+	 
+	 /* Print out all the packaging systems that will work with 
+	    this VS */
+	 for (unsigned J = 0; J != pkgSystem::GlobalListLen; J++)
+	 {
+	    pkgSystem *Sys = pkgSystem::GlobalList[J];
+	    if (_system == Sys)
+	       cout << '*';
+	    else
+	       cout << ' ';
+	    if (Sys->VS->TestCompatibility(*VS) == true)
+	       cout << "Pkg:  " << Sys->Label << " (Priority " << Sys->Score(*_config) << ")" << endl;
+	 }
+      }
+      
+      for (unsigned I = 0; I != pkgSourceList::Type::GlobalListLen; I++)
+      {
+	 pkgSourceList::Type *Type = pkgSourceList::Type::GlobalList[I];
+	 cout << " S.L: '" << Type->Name << "' " << Type->Label << endl;
+      }      
+      
+      for (unsigned I = 0; I != pkgIndexFile::Type::GlobalListLen; I++)
+      {
+	 pkgIndexFile::Type *Type = pkgIndexFile::Type::GlobalList[I];
+	 cout << " Idx: " << Type->Label << endl;
+      }      
+      
+      return true;
+   }
+   
+   cout << 
+    _("Usage: apt-get [options] command\n"
+      "       apt-get [options] install|remove pkg1 [pkg2 ...]\n"
+      "       apt-get [options] source pkg1 [pkg2 ...]\n"
+      "\n"
+      "apt-get is a simple command line interface for downloading and\n"
+      "installing packages. The most frequently used commands are update\n"
+      "and install.\n"   
+      "\n"
+      "Commands:\n"
+      "   update - Retrieve new lists of packages\n"
+      "   upgrade - Perform an upgrade\n"
+      "   install - Install new packages (pkg is libc6 not libc6.deb)\n"
+      "   remove - Remove packages\n"
+      "   source - Download source archives\n"
+      "   build-dep - Configure build-dependencies for source packages\n"
+      "   dist-upgrade - Distribution upgrade, see apt-get(8)\n"
+      "   dselect-upgrade - Follow dselect selections\n"
+      "   clean - Erase downloaded archive files\n"
+      "   autoclean - Erase old downloaded archive files\n"
+      "   check - Verify that there are no broken dependencies\n"
+      "\n"
+      "Options:\n"
+      "  -h  This help text.\n"
+      "  -q  Loggable output - no progress indicator\n"
+      "  -qq No output except for errors\n"
+      "  -d  Download only - do NOT install or unpack archives\n"
+      "  -s  No-act. Perform ordering simulation\n"
+      "  -y  Assume Yes to all queries and do not prompt\n"
+      "  -f  Attempt to continue if the integrity check fails\n"
+      "  -m  Attempt to continue if archives are unlocatable\n"
+      "  -u  Show a list of upgraded packages as well\n"
+      "  -b  Build the source package after fetching it\n"
+      "  -V  Show verbose version numbers\n"
+      "  -c=? Read this configuration file\n"
+      "  -o=? Set an arbitrary configuration option, eg -o dir::cache=/tmp\n"
+      "See the apt-get(8), sources.list(5) and apt.conf(5) manual\n"
+      "pages for more information and options.\n"
+      "                       This APT has Super Cow Powers.\n");
+   return true;
+}
+									/*}}}*/
+// GetInitialize - Initialize things for apt-get			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void GetInitialize()
+{
+   _config->Set("quiet",0);
+   _config->Set("help",false);
+   _config->Set("APT::Get::Download-Only",false);
+   _config->Set("APT::Get::Simulate",false);
+   _config->Set("APT::Get::Assume-Yes",false);
+   _config->Set("APT::Get::Fix-Broken",false);
+   _config->Set("APT::Get::Force-Yes",false);
+   _config->Set("APT::Get::List-Cleanup",true);
+}
+									/*}}}*/
+// SigWinch - Window size change signal handler				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void SigWinch(int)
+{
+   // Riped from GNU ls
+#ifdef TIOCGWINSZ
+   struct winsize ws;
+  
+   if (ioctl(1, TIOCGWINSZ, &ws) != -1 && ws.ws_col >= 5)
+      ScreenWidth = ws.ws_col - 1;
+#endif
+}
+									/*}}}*/
+
+int main(int argc,const char *argv[])
+{
+   CommandLine::Args Args[] = {
+      {'h',"help","help",0},
+      {'v',"version","version",0},
+      {'V',"verbose-versions","APT::Get::Show-Versions",0},
+      {'q',"quiet","quiet",CommandLine::IntLevel},
+      {'q',"silent","quiet",CommandLine::IntLevel},
+      {'d',"download-only","APT::Get::Download-Only",0},
+      {'b',"compile","APT::Get::Compile",0},
+      {'b',"build","APT::Get::Compile",0},
+      {'s',"simulate","APT::Get::Simulate",0},
+      {'s',"just-print","APT::Get::Simulate",0},
+      {'s',"recon","APT::Get::Simulate",0},
+      {'s',"dry-run","APT::Get::Simulate",0},
+      {'s',"no-act","APT::Get::Simulate",0},
+      {'y',"yes","APT::Get::Assume-Yes",0},
+      {'y',"assume-yes","APT::Get::Assume-Yes",0},      
+      {'f',"fix-broken","APT::Get::Fix-Broken",0},
+      {'u',"show-upgraded","APT::Get::Show-Upgraded",0},
+      {'m',"ignore-missing","APT::Get::Fix-Missing",0},
+      {'t',"target-release","APT::Default-Release",CommandLine::HasArg},
+      {'t',"default-release","APT::Default-Release",CommandLine::HasArg},
+      {0,"download","APT::Get::Download",0},
+      {0,"fix-missing","APT::Get::Fix-Missing",0},
+      {0,"ignore-hold","APT::Ignore-Hold",0},      
+      {0,"upgrade","APT::Get::upgrade",0},
+      {0,"force-yes","APT::Get::force-yes",0},
+      {0,"print-uris","APT::Get::Print-URIs",0},
+      {0,"diff-only","APT::Get::Diff-Only",0},
+      {0,"tar-only","APT::Get::tar-Only",0},
+      {0,"purge","APT::Get::Purge",0},
+      {0,"list-cleanup","APT::Get::List-Cleanup",0},
+      {0,"reinstall","APT::Get::ReInstall",0},
+      {0,"trivial-only","APT::Get::Trivial-Only",0},
+      {0,"remove","APT::Get::Remove",0},
+      {0,"only-source","APT::Get::Only-Source",0},
+      {0,"arch-only","APT::Get::Arch-Only",0},
+      {'c',"config-file",0,CommandLine::ConfigFile},
+      {'o',"option",0,CommandLine::ArbItem},
+      {0,0,0,0}};
+   CommandLine::Dispatch Cmds[] = {{"update",&DoUpdate},
+                                   {"upgrade",&DoUpgrade},
+                                   {"install",&DoInstall},
+                                   {"remove",&DoInstall},
+                                   {"dist-upgrade",&DoDistUpgrade},
+                                   {"dselect-upgrade",&DoDSelectUpgrade},
+				   {"build-dep",&DoBuildDep},
+                                   {"clean",&DoClean},
+                                   {"autoclean",&DoAutoClean},
+                                   {"check",&DoCheck},
+				   {"source",&DoSource},
+				   {"moo",&DoMoo},
+				   {"help",&ShowHelp},
+                                   {0,0}};
+
+   // Set up gettext support
+   setlocale(LC_ALL,"");
+   textdomain(PACKAGE);
+
+   // Parse the command line and initialize the package library
+   CommandLine CmdL(Args,_config);
+   if (pkgInitConfig(*_config) == false ||
+       CmdL.Parse(argc,argv) == false ||
+       pkgInitSystem(*_config,_system) == false)
+   {
+      if (_config->FindB("version") == true)
+	 ShowHelp(CmdL);
+	 
+      _error->DumpErrors();
+      return 100;
+   }
+
+   // See if the help should be shown
+   if (_config->FindB("help") == true ||
+       _config->FindB("version") == true ||
+       CmdL.FileSize() == 0)
+   {
+      ShowHelp(CmdL);
+      return 0;
+   }
+   
+   // Deal with stdout not being a tty
+   if (!isatty(STDOUT_FILENO) && _config->FindI("quiet",0) < 1)
+      _config->Set("quiet","1");
+
+   // Setup the output streams
+   c0out.rdbuf(cout.rdbuf());
+   c1out.rdbuf(cout.rdbuf());
+   c2out.rdbuf(cout.rdbuf());
+   if (_config->FindI("quiet",0) > 0)
+      c0out.rdbuf(devnull.rdbuf());
+   if (_config->FindI("quiet",0) > 1)
+      c1out.rdbuf(devnull.rdbuf());
+
+   // Setup the signals
+   signal(SIGPIPE,SIG_IGN);
+   signal(SIGWINCH,SigWinch);
+   SigWinch(0);
+
+   // Match the operation
+   CmdL.DispatchArg(Cmds);
+
+   // Print any errors or warnings found during parsing
+   if (_error->empty() == false)
+   {
+      bool Errors = _error->PendingError();
+      _error->DumpErrors();
+      return Errors == true?100:0;
+   }
+   
+   return 0;   
+}
diff -uNr apt-0.5.28.6/configure apt-0.5.28.6-new/configure
--- apt-0.5.28.6/configure	Tue Mar 22 02:06:44 2005
+++ apt-0.5.28.6-new/configure	Mon Apr 25 16:36:00 2005
@@ -8476,7 +8476,7 @@
 fi
 
 
-                    ac_config_files="$ac_config_files environment.mak:buildlib/environment.mak.in makefile:buildlib/makefile.in"
+                    ac_config_files="$ac_config_files environment.mak:buildlib/environment.mak.in makefile.wrap:buildlib/makefile.in"
           ac_config_commands="$ac_config_commands default"
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -9020,7 +9020,7 @@
   case "$ac_config_target" in
   # Handling of arguments.
   "environment.mak" ) CONFIG_FILES="$CONFIG_FILES environment.mak:buildlib/environment.mak.in" ;;
-  "makefile" ) CONFIG_FILES="$CONFIG_FILES makefile:buildlib/makefile.in" ;;
+  "makefile" ) CONFIG_FILES="$CONFIG_FILES makefile.wrap:buildlib/makefile.in" ;;
   "default-1" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
   "default" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default" ;;
   "include/config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS include/config.h:buildlib/config.h.in" ;;
@@ -9861,7 +9861,7 @@
         ;;
       esac
     done ;;
-    default ) make -s dirs ;;
+    default ) make -f makefile.wrap -s dirs ;;
   esac
 done
 _ACEOF
diff -uNr apt-0.5.28.6/doc/apt-cache.8 apt-0.5.28.6-new/doc/apt-cache.8
--- apt-0.5.28.6/doc/apt-cache.8	Tue Mar 22 02:06:56 2005
+++ apt-0.5.28.6-new/doc/apt-cache.8	Mon Apr 25 16:37:01 2005
@@ -223,15 +223,15 @@
 .SH "FILES"
 
 .TP
-\fI/etc/apt/sources\&.list\fR
+\fI@PREFIX@/etc/apt/sources\&.list\fR
 Locations to fetch packages from\&. Configuration Item: Dir::Etc::SourceList\&.
 
 .TP
-\fI/var/lib/apt/lists/\fR
+\fI@PREFIX@/var/lib/apt/lists/\fR
 Storage area for state information for each package resource specified in \fB\fIsources\&.list\fR\fR(5) Configuration Item: Dir::State::Lists\&.
 
 .TP
-\fI/var/lib/apt/lists/partial/\fR
+\fI@PREFIX@/var/lib/apt/lists/partial/\fR
 Storage area for state information in transit\&. Configuration Item: Dir::State::Lists (implicit partial)\&.
 
 .SH "SEE ALSO"
diff -uNr apt-0.5.28.6/doc/apt-cache.8.xml apt-0.5.28.6-new/doc/apt-cache.8.xml
--- apt-0.5.28.6/doc/apt-cache.8.xml	Mon Jan 10 17:02:42 2005
+++ apt-0.5.28.6-new/doc/apt-cache.8.xml	Wed Dec 31 19:00:00 1969
@@ -1,378 +0,0 @@
-<?xml version="1.0" encoding="utf-8" standalone="no"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
-  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
-
-<!ENTITY % aptent SYSTEM "apt.ent">
-%aptent;
-
-]>
-
-<refentry>
-
- <refentryinfo>
-   &apt-author.jgunthorpe;
-   &apt-author.team;
-   &apt-email;
-   &apt-product;
-   <!-- The last update date -->
-   <date>29 February 2004</date>
- </refentryinfo>
- 
- <refmeta>
-   <refentrytitle>apt-cache</refentrytitle>
-   <manvolnum>8</manvolnum>
- </refmeta>
- 
- <!-- Man page title -->
- <refnamediv>
-    <refname>apt-cache</refname>
-    <refpurpose>APT package handling utility -- cache manipulator</refpurpose>
- </refnamediv>
-
- <!-- Arguments -->
- <refsynopsisdiv>
-   <cmdsynopsis>
-      <command>apt-cache</command>
-      <arg><option>-hvsn</option></arg>
-      <arg><option>-o=<replaceable>config string</replaceable></option></arg>
-      <arg><option>-c=<replaceable>file</replaceable></option></arg>
-      <group choice="req">
-         <arg>add <arg choice="plain" rep="repeat"><replaceable>file</replaceable></arg></arg>
-         <arg>gencaches</arg>
-         <arg>showpkg <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>showsrc <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>stats</arg>
-         <arg>dump</arg>
-         <arg>dumpavail</arg>
-         <arg>unmet</arg>
-         <arg>search <arg choice="plain"><replaceable>regex</replaceable></arg></arg>
-         <arg>show <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>depends <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>rdepends <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>pkgnames <arg choice="plain"><replaceable>prefix</replaceable></arg></arg>
-         <arg>dotty <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>policy <arg choice="plain" rep="repeat"><replaceable>pkgs</replaceable></arg></arg>
-         <arg>madison <arg choice="plain" rep="repeat"><replaceable>pkgs</replaceable></arg></arg>
-      </group>   
-   </cmdsynopsis>
- </refsynopsisdiv>
- 
- <refsect1><title>Description</title>
-   <para><command>apt-cache</command> performs a variety of operations on APT's package 
-   cache. <command>apt-cache</command> does not manipulate the state of the system 
-   but does provide operations to search and generate interesting output 
-   from the package metadata.</para>
-
-   <para>Unless the <option>-h</option>, or <option>--help</option> option is given, one of the
-   commands below must be present.</para>
-
-   <variablelist>
-     <varlistentry><term>add <replaceable>file(s)</replaceable></term>
-     <listitem><para><literal>add</literal> adds the named package index files to the package cache.
-     This is for debugging only.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term>gencaches</term>
-     <listitem><para><literal>gencaches</literal> performs the same operation as 
-     <command>apt-get check</command>. It builds the source and package caches from 
-     the sources in &sources-list; and from
-     <filename>/var/lib/dpkg/status</filename>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>showpkg <replaceable>pkg(s)</replaceable></term>
-     <listitem><para><literal>showpkg</literal> displays information about the packages listed on the 
-     command line. Remaining arguments are package names. The available 
-     versions and reverse dependencies of each package listed are listed, as 
-     well as forward dependencies for each version. Forward (normal) 
-     dependencies are those packages upon which the package in question 
-     depends; reverse dependencies are those packages that depend upon the 
-     package in question. Thus, forward dependencies must be satisfied for a 
-     package, but reverse dependencies need not be.
-     For instance, <command>apt-cache showpkg libreadline2</command> would produce 
-     output similar to the following:</para>
-     
-<informalexample><programlisting>
-Package: libreadline2
-Versions: 2.1-12(/var/state/apt/lists/foo_Packages),
-Reverse Depends: 
-  libreadlineg2,libreadline2
-  libreadline2-altdev,libreadline2
-Dependencies:
-2.1-12 - libc5 (2 5.4.0-0) ncurses3.0 (0 (null))
-Provides:
-2.1-12 - 
-Reverse Provides: 
-</programlisting></informalexample>
-			    
-     <para>Thus it may be seen that libreadline2, version 2.1-12, depends on
-     libc5 and ncurses3.0 which must be installed for libreadline2 to work. 
-     In turn, libreadlineg2 and libreadline2-altdev depend on libreadline2. If
-     libreadline2 is installed, libc5 and ncurses3.0 (and ldso) must also be
-     installed; libreadlineg2 and libreadline2-altdev do not have to be
-     installed. For the specific meaning of the remainder of the output it
-     is best to consult the apt source code.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>stats</term><listitem><para><literal>stats</literal> displays some statistics about the cache.
-     No further arguments are expected. Statistics reported are:
-     <itemizedlist>
-       <listitem><para><literal>Total package names</literal> is the number of package names found 
-       in the cache.</para>
-       </listitem>
-       
-       <listitem><para><literal>Normal packages</literal> is the number of regular, ordinary package 
-       names; these are packages that bear a one-to-one correspondence between 
-       their names and the names used by other packages for them in 
-       dependencies. The majority of packages fall into this category.</para>
-       </listitem>
-
-       <listitem><para><literal>Pure virtual packages</literal> is the number of packages that exist 
-       only as a virtual package name; that is, packages only "provide" the 
-       virtual package name, and no package actually uses the name. For 
-       instance, "mail-transport-agent" in the Debian GNU/Linux system is a 
-       pure virtual package; several packages provide "mail-transport-agent", 
-       but there is no package named "mail-transport-agent".</para>
-       </listitem>
-   
-       <listitem><para><literal>Single virtual packages</literal> is the number of packages with only 
-       one package providing a particular virtual package. For example, in the
-       Debian GNU/Linux system, "X11-text-viewer" is a virtual package, but 
-       only one package, xless, provides "X11-text-viewer".</para>
-       </listitem>
-
-       <listitem><para><literal>Mixed virtual packages</literal> is the number of packages that either 
-       provide a particular virtual package or have the virtual package name 
-       as the package name. For instance, in the Debian GNU/Linux system, 
-       "debconf" is both an actual package, and provided by the debconf-tiny
-       package.</para>
-       </listitem>
-   
-       <listitem><para><literal>Missing</literal> is the number of package names that were referenced in
-       a dependency but were not provided by any package. Missing packages may 
-       be in evidence if a full distribution is not accessed, or if a package
-       (real or virtual) has been dropped from the distribution. Usually they
-       are referenced from Conflicts statements.</para>
-       </listitem>
-
-       <listitem><para><literal>Total distinct</literal> versions is the number of package versions 
-       found in the cache; this value is therefore at least equal to the 
-       number of total package names. If more than one distribution (both 
-       "stable" and "unstable", for instance), is being accessed, this value 
-       can be considerably larger than the number of total package names.</para>
-       </listitem>
-
-       <listitem><para><literal>Total dependencies</literal> is the number of dependency relationships 
-       claimed by all of the packages in the cache.</para>
-       </listitem>
-     </itemizedlist>
-     </para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term>showsrc <replaceable>pkg(s)</replaceable></term>
-     <listitem><para><literal>showsrc</literal> displays all the source package records that match
-     the given package names. All versions are shown, as well as all 
-     records that declare the name to be a Binary.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term>dump</term>
-     <listitem><para><literal>dump</literal> shows a short listing of every package in the cache. It is 
-     primarily for debugging.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>dumpavail</term>
-     <listitem><para><literal>dumpavail</literal> prints out an available list to stdout. This is 
-     suitable for use with &dpkg; and is used by the &dselect; method.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>unmet</term>
-     <listitem><para><literal>unmet</literal> displays a summary of all unmet dependencies in the 
-     package cache.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>show <replaceable>pkg(s)</replaceable></term>
-     <listitem><para><literal>show</literal> performs a function similar to 
-     <command>dpkg --print-avail</command>i; it displays the package records for the 
-     named packages.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>search <replaceable>regex [ regex ... ]</replaceable></term>
-     <listitem><para><literal>search</literal> performs a full text search on all available package
-     lists for the regex pattern given. It searches the package names and the
-     descriptions for an occurrence of the regular expression and prints out
-     the package name and the short description. If <option>--full</option> is given
-     then output identical to <literal>show</literal> is produced for each matched
-     package, and if <option>--names-only</option> is given then the long description
-     is not searched, only the package name is.</para>
-     <para>
-     Separate arguments can be used to specify multiple search patterns that 
-     are and'ed together.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>depends <replaceable>pkg(s)</replaceable></term>
-     <listitem><para><literal>depends</literal> shows a listing of each dependency a package has 
-     and all the possible other packages that can fulfill that dependency.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>rdepends <replaceable>pkg(s)</replaceable></term>
-     <listitem><para><literal>rdepends</literal>shows a listing of each reverse dependency a
-      package has.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>pkgnames <replaceable>[ prefix ]</replaceable></term>
-     <listitem><para>This command prints the name of each package in the system. The optional
-     argument is a prefix match to filter the name list. The output is suitable
-     for use in a shell tab complete function and the output is generated 
-     extremely quickly. This command is best used with the 
-     <option>--generate</option> option.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term>dotty <replaceable>pkg(s)</replaceable></term>
-     <listitem><para><literal>dotty</literal> takes a list of packages on the command line and 
-     generates output suitable for use by dotty from the 
-     <ulink url="http://www.research.att.com/sw/tools/graphviz/">GraphViz</ulink>
-     package. The result will be a set of nodes and edges representing the 
-     relationships between the packages. By default the given packages will 
-     trace out all dependent packages; this can produce a very large graph. 
-     To limit the output to only the packages listed on the command line,
-     set the <literal>APT::Cache::GivenOnly</literal> option.</para>
-
-     <para>The resulting nodes will have several shapes; normal packages are boxes,
-     pure provides are triangles, mixed provides are diamonds, 
-     missing packages are hexagons. Orange boxes mean recursion was stopped 
-     [leaf packages], blue lines are pre-depends, green lines are conflicts.</para>
-
-     <para>Caution, dotty cannot graph larger sets of packages.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term>policy <replaceable>[ pkg(s) ]</replaceable></term>
-     <listitem><para><literal>policy</literal> is meant to help debug issues relating to the 
-     preferences file. With no arguments it will print out the 
-     priorities of each source. Otherwise it prints out detailed information
-     about the priority selection of the named package.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>madison <replaceable>/[ pkg(s) ]</replaceable></term>
-     <listitem><para><literal>apt-cache</literal>'s <literal>madison</literal> command attempts to mimic
-     the output format and a subset of the functionality of the Debian
-     archive management tool, <literal>madison</literal>.  It displays
-     available versions of a package in a tabular format.  Unlike the
-     original <literal>madison</literal>, it can only display information for
-     the architecture for which APT has retrieved package lists
-     (<literal>APT::Architecture</literal>).</para></listitem>
-     </varlistentry>
-   </variablelist>
- </refsect1>
- 
- <refsect1><title>options</title>
-   &apt-cmdblurb;
-   
-   <variablelist>
-     <varlistentry><term><option>-p</option></term><term><option>--pkg-cache</option></term>
-     <listitem><para>Select the file to store the package cache. The package cache is the 
-     primary cache used by all operations.
-     Configuration Item: <literal>Dir::Cache::pkgcache</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-s</option></term><term><option>--src-cache</option></term>
-     <listitem><para>Select the file to store the source cache. The source is used only by
-     <literal>gencaches</literal> and it stores a parsed version of the package 
-     information from remote sources. When building the package cache the 
-     source cache is used to advoid reparsing all of the package files.
-     Configuration Item: <literal>Dir::Cache::srcpkgcache</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-q</option></term><term><option>--quiet</option></term>
-     <listitem><para>Quiet; produces output suitable for logging, omitting progress indicators.
-     More q's will produce more quietness up to a maximum of 2. You can also use
-     <option>-q=#</option> to set the quietness level, overriding the configuration file.
-     Configuration Item: <literal>quiet</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-i</option></term><term><option>--important</option></term>
-     <listitem><para>Print only important dependencies; for use with unmet. Causes only Depends and 
-     Pre-Depends relations to be printed.
-     Configuration Item: <literal>APT::Cache::Important</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-f</option></term><term><option>--full</option></term>
-     <listitem><para>Print full package records when searching. 
-     Configuration Item: <literal>APT::Cache::ShowFull</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-a</option></term><term><option>--all-versions</option></term>
-     <listitem><para>Print full records for all available versions. This is the
-     default; to turn it off, use <option>--no-all-versions</option>.
-     If <option>--no-all-versions</option> is specified, only the candidate version
-     will displayed (the one which would be selected for installation).
-     This option is only applicable to  the <literal>show</literal> command.
-     Configuration Item: <literal>APT::Cache::AllVersions</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-g</option></term><term><option>--generate</option></term>
-     <listitem><para>Perform automatic package cache regeneration, rather than use the cache 
-     as it is. This is the default; to turn it off, use <option>--no-generate</option>.
-     Configuration Item: <literal>APT::Cache::Generate</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--names-only</option></term><term><option>-n</option></term>
-     <listitem><para>Only search on the package names, not the long descriptions. 
-     Configuration Item: <literal>APT::Cache::NamesOnly</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--all-names</option></term>
-     <listitem><para>Make <literal>pkgnames</literal> print all names, including virtual packages 
-     and missing dependencies. 
-     Configuration Item: <literal>APT::Cache::AllNames</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--recurse</option></term>
-     <listitem><para>Make <literal>depends</literal> and <literal>rdepends</literal> recursive so
-     that all packages mentioned are printed once.
-     Configuration Item: <literal>APT::Cache::RecurseDepends</literal>.</para></listitem>
-     </varlistentry>
-
-      <varlistentry><term><option>--installed</option></term>
-      <listitem><para>
-      Limit the output of <literal>depends</literal> and <literal>rdepends</literal> to
-      packages which are currently installed.
-      Configuration Item: <literal>APT::Cache::Installed</literal>.</para></listitem>
-      </varlistentry>
-
-     &apt-commonoptions;
-     
-   </variablelist>
- </refsect1>
-
- <refsect1><title>Files</title>
-   <variablelist>
-     <varlistentry><term><filename>/etc/apt/sources.list</filename></term>
-     <listitem><para>Locations to fetch packages from.
-     Configuration Item: <literal>Dir::Etc::SourceList</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>&statedir;/lists/</filename></term>
-     <listitem><para>Storage area for state information for each package resource specified in
-     &sources-list;
-     Configuration Item: <literal>Dir::State::Lists</literal>.</para></listitem>
-     </varlistentry>
-  
-     <varlistentry><term><filename>&statedir;/lists/partial/</filename></term>
-     <listitem><para>Storage area for state information in transit.
-     Configuration Item: <literal>Dir::State::Lists</literal> (implicit partial).</para></listitem>
-     </varlistentry>     
-   </variablelist>
- </refsect1>
-
- <refsect1><title>See Also</title>
-   <para>&apt-conf;, &sources-list;, &apt-get;
-   </para>
- </refsect1>
-
- <refsect1><title>Diagnostics</title>
-   <para><command>apt-cache</command> returns zero on normal operation, decimal 100 on error.
-   </para>
- </refsect1>
-
- &manbugs;
- 
-</refentry>
diff -uNr apt-0.5.28.6/doc/apt-cdrom.8 apt-0.5.28.6-new/doc/apt-cdrom.8
--- apt-0.5.28.6/doc/apt-cdrom.8	Tue Mar 22 02:07:02 2005
+++ apt-0.5.28.6-new/doc/apt-cdrom.8	Mon Apr 25 16:40:28 2005
@@ -43,7 +43,7 @@
 add
 add is used to add a new disc to the source list\&. It will unmount the CDROM device, prompt for a disk to be inserted and then procceed to scan it and copy the index files\&. If the disc does not have a proper \fIdisk\fR directory you will be prompted for a descriptive title\&.
 
-APT uses a CDROM ID to track which disc is currently in the drive and maintains a database of these IDs in \fI/var/lib/apt/cdroms\&.list\fR 
+APT uses a CDROM ID to track which disc is currently in the drive and maintains a database of these IDs in \fI@PREFIX@/var/lib/apt/cdroms\&.list\fR 
 
 .TP
 ident
diff -uNr apt-0.5.28.6/doc/apt-cdrom.8.xml apt-0.5.28.6-new/doc/apt-cdrom.8.xml
--- apt-0.5.28.6/doc/apt-cdrom.8.xml	Mon Jan 10 17:02:42 2005
+++ apt-0.5.28.6-new/doc/apt-cdrom.8.xml	Wed Dec 31 19:00:00 1969
@@ -1,167 +0,0 @@
-<?xml version="1.0" encoding="utf-8" standalone="no"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
-  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
-
-<!ENTITY % aptent SYSTEM "apt.ent">
-%aptent;
-
-]>
-
-<refentry>
-
- <refentryinfo>
-   &apt-author.jgunthorpe;
-   &apt-author.team;
-   &apt-email;
-   &apt-product;
-   <date>14 February 2004</date>
- </refentryinfo>
-
- <refmeta>
-   <refentrytitle>apt-cdrom</refentrytitle>
-   <manvolnum>8</manvolnum>
- </refmeta>
- 
- <!-- Man page title -->
- <refnamediv>
-    <refname>apt-cdrom</refname>
-    <refpurpose>APT CDROM management utility</refpurpose>
- </refnamediv>
-
- <!-- Arguments -->
- <refsynopsisdiv>
-   <cmdsynopsis>
-      <command>apt-cdrom</command>
-      <arg><option>-hvrmfan</option></arg>
-      <arg><option>-d=<replaceable>cdrom mount point</replaceable></option></arg>
-      <arg><option>-o=<replaceable>config string</replaceable></option></arg>
-      <arg><option>-c=<replaceable>file</replaceable></option></arg>
-      <group>
-         <arg>add</arg>
-         <arg>ident</arg>
-      </group>   
-   </cmdsynopsis>
- </refsynopsisdiv>
-
- <refsect1><title>Description</title>
-   <para><command>apt-cdrom</command> is used to add a new CDROM to APTs list
-    of available sources. <command>apt-cdrom</command> takes care of
-   determining the structure of
-   the disc as well as correcting for several possible mis-burns and 
-   verifying the index files.   
-   </para>
-
-   <para>It is necessary to use <command>apt-cdrom</command> to add CDs to the
-   APT system, 
-   it cannot be done by hand. Furthermore each disk in a multi-cd set must be
-   inserted and scanned separately to account for possible mis-burns.
-   </para>
-
-   <para>Unless the <option>-h</option>, or <option>--help</option> option is
-    given one of the commands below must be present.
-   
-    <variablelist>
-     <varlistentry><term>add</term>
-     <listitem><para><literal>add</literal> is used to add a new disc to the
-     source list. It will unmount the
-     CDROM device, prompt for a disk to be inserted and then procceed to 
-     scan it and copy the index files. If the disc does not have a proper
-     <filename>disk</filename> directory you will be prompted for a descriptive 
-     title.
-     </para>
-
-     <para>APT uses a CDROM ID to track which disc is currently in the drive and
-     maintains a database of these IDs in 
-     <filename>&statedir;/cdroms.list</filename>
-     </para>
-     </listitem>
-     </varlistentry>
-     
-     <varlistentry><term>ident</term>
-     <listitem><para>A debugging tool to report the identity of the current
-      disc as well as the stored file name
-     </para>
-     </listitem>
-     </varlistentry>
-    </variablelist>
-   </para>
- </refsect1>
-
- <refsect1><title>Options</title>
-   &apt-cmdblurb;
-   
-   <variablelist>
-     <varlistentry><term><option>-d</option></term><term><option>--cdrom</option></term>
-     <listitem><para>Mount point; specify the location to mount the cdrom. This
-      mount point must be listed in <filename>/etc/fstab</filename> and
-      properly configured.
-      Configuration Item: <literal>Acquire::cdrom::mount</literal>.
-     </para>
-     </listitem>
-     </varlistentry>
-     
-     <varlistentry><term><option>-r</option></term><term><option>--rename</option></term>
-     <listitem><para>Rename a disc; change the label of a disk or override the
-      disks given label. This option will cause <command>apt-cdrom</command> to
-      prompt for a new label.
-     Configuration Item: <literal>APT::CDROM::Rename</literal>.
-     </para>
-     </listitem>
-     </varlistentry>
-     
-     <varlistentry><term><option>-m</option></term><term><option>--no-mount</option></term>
-     <listitem><para>No mounting; prevent <command>apt-cdrom</command> from
-      mounting and unmounting the mount point.
-     Configuration Item: <literal>APT::CDROM::NoMount</literal>.
-     </para>
-     </listitem>
-     </varlistentry>
-     
-     <varlistentry><term><option>-f</option></term><term><option>--fast</option></term>
-     <listitem><para>Fast Copy; Assume the package files are valid and do not
-      check every package. This option should be used only if
-     <command>apt-cdrom</command> has been run on this disc before and did not
-     detect any errors.
-     Configuration Item: <literal>APT::CDROM::Fast</literal>.
-     </para>
-     </listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-a</option></term><term><option>--thorough</option></term>
-     <listitem><para>Thorough Package Scan; This option may be needed with some
-      old Debian 1.1/1.2 discs that have Package files in strange places. It 
-      takes much longer to scan the CD but will pick them all up.
-     </para>
-     </listitem>
-     </varlistentry>
-     
-     <varlistentry><term><option>-n</option></term>
-                   <term><option>--just-print</option></term>
-                   <term><option>--recon</option></term>
-                   <term><option>--no-act</option></term>
-     <listitem><para>No Changes; Do not change the &sources-list; file and do
-     not write index files. Everything is still checked however.
-     Configuration Item: <literal>APT::CDROM::NoAct</literal>.
-     </para>
-     </listitem>
-     </varlistentry> 
-
-     &apt-commonoptions;
-
-   </variablelist>
- </refsect1>
-
- <refsect1><title>See Also</title>
-   <para>&apt-conf;, &apt-get;, &sources-list;
-   </para>
- </refsect1>
-
- <refsect1><title>Diagnostics</title>
-   <para><command>apt-cdrom</command> returns zero on normal operation, decimal 100 on error.
-   </para>
- </refsect1>
-
- &manbugs;
-
-</refentry>
-
diff -uNr apt-0.5.28.6/doc/apt-config.8 apt-0.5.28.6-new/doc/apt-config.8
--- apt-0.5.28.6/doc/apt-config.8	Tue Mar 22 02:07:10 2005
+++ apt-0.5.28.6-new/doc/apt-config.8	Mon Apr 25 16:40:58 2005
@@ -31,7 +31,7 @@
 .SH "DESCRIPTION"
 
 .PP
-\fBapt\-config\fR is an internal program used by various portions of the APT suite to provide consistent configurability\&. It accesses the main configuration file \fI/etc/apt/apt\&.conf\fR in a manner that is easy to use by scripted applications\&.
+\fBapt\-config\fR is an internal program used by various portions of the APT suite to provide consistent configurability\&. It accesses the main configuration file \fI@PREFIX@/etc/apt/apt\&.conf\fR in a manner that is easy to use by scripted applications\&.
 
 .PP
 Unless the \fB\-h\fR, or \fB\-\-help\fR option is given one of the commands below must be present\&.
diff -uNr apt-0.5.28.6/doc/apt-config.8.xml apt-0.5.28.6-new/doc/apt-config.8.xml
--- apt-0.5.28.6/doc/apt-config.8.xml	Mon Jan 10 17:02:42 2005
+++ apt-0.5.28.6-new/doc/apt-config.8.xml	Wed Dec 31 19:00:00 1969
@@ -1,115 +0,0 @@
-<?xml version="1.0" encoding="utf-8" standalone="no"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
-  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
-
-<!ENTITY % aptent SYSTEM "apt.ent">
-%aptent;
-
-]>
-
-<refentry>
-
- <refentryinfo>
-   &apt-author.jgunthorpe;
-   &apt-author.team;
-   &apt-email;
-   &apt-product;
-   <!-- The last update date -->
-   <date>29 February 2004</date>
- </refentryinfo>
- 
- <refmeta>
-   <refentrytitle>apt-config</refentrytitle>
-   <manvolnum>8</manvolnum>
- </refmeta>
- 
- <!-- Man page title -->
- <refnamediv>
-    <refname>apt-config</refname>
-    <refpurpose>APT Configuration Query program</refpurpose>
- </refnamediv>
-
- <!-- Arguments -->
- <refsynopsisdiv>
-   <cmdsynopsis>
-      <command>apt-config</command>
-      <arg><option>-hv</option></arg>
-      <arg><option>-o=<replaceable>config string</replaceable></option></arg>
-      <arg><option>-c=<replaceable>file</replaceable></option></arg>
-      <group choice="req">
-         <arg>shell</arg>
-         <arg>dump</arg>
-      </group>   
-   </cmdsynopsis>
- </refsynopsisdiv>
- 
- <refsect1><title>Description</title>
-   <para><command>apt-config</command> is an internal program used by various
-   portions of the APT suite to provide consistent configurability. It accesses
-   the main configuration file <filename>/etc/apt/apt.conf</filename> in a
-   manner that is easy to use by scripted applications.</para>
-
-   <para>Unless the <option>-h</option>, or <option>--help</option> option is
-   given one of the commands below must be present.
-   </para>
-   
-   <variablelist>
-     <varlistentry><term>shell</term>
-     <listitem><para>
-     shell is used to access the configuration information from a shell 
-     script. It is given pairs of arguments, the first being a shell 
-     variable and the second the configuration value to query. As output 
-     it lists a series of shell assignments commands for each present value. 
-     In a shell script it should be used like:
-     </para>
-     
-<informalexample><programlisting>
-OPTS="-f"
-RES=`apt-config shell OPTS MyApp::options`
-eval $RES
-</programlisting></informalexample>
-
-     <para>This will set the shell environment variable $OPTS to the value of
-     MyApp::options with a default of <option>-f</option>.</para>
-
-     
-     <para>The configuration item may be postfixed with a /[fdbi]. f returns
-     file names, d returns directories, b returns true or false and i returns
-     an integer. Each of the returns is normalized and verified
-     internally.</para>
-     </listitem>
-     </varlistentry>
-
-     <varlistentry><term>dump</term>
-     <listitem><para>
-     Just show the contents of the configuration space.</para>
-     </listitem>
-     </varlistentry>
-
-   </variablelist>
- </refsect1>
-
- <refsect1><title>options</title>
-   &apt-cmdblurb;
-   
-   <variablelist>
-   
-     &apt-commonoptions;
-     
-   </variablelist>
- </refsect1>
-
- <refsect1><title>See Also</title>
-   <para>&apt-conf;
-   </para>
- </refsect1>
-
- <refsect1><title>Diagnostics</title>
-   <para><command>apt-config</command> returns zero on normal operation, decimal 100 on error.
-   </para>
- </refsect1>
-
- &manbugs;
- 
-</refentry>
-
diff -uNr apt-0.5.28.6/doc/apt-get.8 apt-0.5.28.6-new/doc/apt-get.8
--- apt-0.5.28.6/doc/apt-get.8	Tue Mar 22 02:06:59 2005
+++ apt-0.5.28.6-new/doc/apt-get.8	Mon Apr 25 16:42:02 2005
@@ -38,11 +38,11 @@
 
 .TP
 update
-update is used to resynchronize the package index files from their sources\&. The indexes of available packages are fetched from the location(s) specified in \fI/etc/apt/sources\&.list\fR\&. For example, when using a Debian archive, this command retrieves and scans the \fIPackages\&.gz\fR files, so that information about new and updated packages is available\&. An update should always be performed before an upgrade or dist\-upgrade\&. Please be aware that the overall progress meter will be incorrect as the size of the package files cannot be known in advance\&.
+update is used to resynchronize the package index files from their sources\&. The indexes of available packages are fetched from the location(s) specified in \fI@PREFIX@/etc/apt/sources\&.list\fR\&. For example, when using a Debian archive, this command retrieves and scans the \fIPackages\&.gz\fR files, so that information about new and updated packages is available\&. An update should always be performed before an upgrade or dist\-upgrade\&. Please be aware that the overall progress meter will be incorrect as the size of the package files cannot be known in advance\&.
 
 .TP
 upgrade
-upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in \fI/etc/apt/sources\&.list\fR\&. Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed\&. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version\&. An update must be performed first so that \fBapt\-get\fR knows that new versions of packages are available\&.
+upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in \fI@PREFIX@/etc/apt/sources\&.list\fR\&. Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed\&. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version\&. An update must be performed first so that \fBapt\-get\fR knows that new versions of packages are available\&.
 
 .TP
 dselect\-upgrade
@@ -50,11 +50,11 @@
 
 .TP
 dist\-upgrade
-dist\-upgrade in addition to performing the function of upgrade, also intelligently handles changing dependencies with new versions of packages; \fBapt\-get\fR has a "smart" conflict resolution system, and it will attempt to upgrade the most important packages at the expense of less important ones if necessary\&. The \fI/etc/apt/sources\&.list\fR file contains a list of locations from which to retrieve desired package files\&. See also \fB\fBapt_preferences\fR\fR(5) for a mechanism for overriding the general settings for individual packages\&.
+dist\-upgrade in addition to performing the function of upgrade, also intelligently handles changing dependencies with new versions of packages; \fBapt\-get\fR has a "smart" conflict resolution system, and it will attempt to upgrade the most important packages at the expense of less important ones if necessary\&. The \fI@PREFIX@/etc/apt/sources\&.list\fR file contains a list of locations from which to retrieve desired package files\&. See also \fB\fBapt_preferences\fR\fR(5) for a mechanism for overriding the general settings for individual packages\&.
 
 .TP
 install
-install is followed by one or more packages desired for installation\&. Each package is a package name, not a fully qualified filename (for instance, in a Debian GNU/Linux system, libc6 would be the argument provided, not libc6_1\&.9\&.6\-2\&.deb) All packages required by the package(s) specified for installation will also be retrieved and installed\&. The \fI/etc/apt/sources\&.list\fR file is used to locate the desired packages\&. If a hyphen is appended to the package name (with no intervening space), the identified package will be removed if it is installed\&. Similarly a plus sign can be used to designate a package to install\&. These latter features may be used to override decisions made by apt\-get's conflict resolution system\&.
+install is followed by one or more packages desired for installation\&. Each package is a package name, not a fully qualified filename (for instance, in a Debian GNU/Linux system, libc6 would be the argument provided, not libc6_1\&.9\&.6\-2\&.deb) All packages required by the package(s) specified for installation will also be retrieved and installed\&. The \fI@PREFIX@/etc/apt/sources\&.list\fR file is used to locate the desired packages\&. If a hyphen is appended to the package name (with no intervening space), the identified package will be removed if it is installed\&. Similarly a plus sign can be used to designate a package to install\&. These latter features may be used to override decisions made by apt\-get's conflict resolution system\&.
 
 A specific version of a package can be selected for installation by following the package name with an equals and the version of the package to select\&. This will cause that version to be located and selected for install\&. Alternatively a specific distribution can be selected by following the package name with a slash and the version of the distribution or the Archive name (stable, testing, unstable)\&.
 
@@ -86,7 +86,7 @@
 
 .TP
 clean
-clean clears out the local repository of retrieved package files\&. It removes everything but the lock file from \fI/var/cache/apt/archives/\fR and \fI/var/cache/apt/archives/partial/\fR\&. When APT is used as a \fB\fBdselect\fR\fR(8) method, clean is run automatically\&. Those who do not use dselect will likely want to run apt\-get clean from time to time to free up disk space\&.
+clean clears out the local repository of retrieved package files\&. It removes everything but the lock file from \fI@PREFIX@/var/cache/apt/archives/\fR and \fI@PREFIX@/var/cache/apt/archives/partial/\fR\&. When APT is used as a \fB\fBdselect\fR\fR(8) method, clean is run automatically\&. Those who do not use dselect will likely want to run apt\-get clean from time to time to free up disk space\&.
 
 .TP
 autoclean
@@ -165,10 +165,21 @@
 
 .TP
 \fB\-\-list\-cleanup\fR
-This option defaults to on, use \-\-no\-list\-cleanup to turn it off\&. When on \fBapt\-get\fR will automatically manage the contents of \fI/var/lib/apt/lists\fR to ensure that obsolete files are erased\&. The only reason to turn it off is if you frequently change your source list\&. Configuration Item: APT::Get::List\-Cleanup\&.
+This option defaults to on, use \-\-no\-list\-cleanup to turn it off\&. When on \fBapt\-get\fR will automatically manage the contents of \fI@PREFIX@/var/lib/apt/lists\fR to ensure that obsolete files are erased\&. The only reason to turn it off is if you frequently change your source list\&. Configuration Item: APT::Get::List\-Cleanup\&.
 
 .TP
 \fB\-t\fR, \fB\-\-target\-release\fR, \fB\-\-default\-release\fR, 
+\fB--ignore-breakage\fR
+For mode \fBinstall\fR, ignore dependency problems. This option is
+useful if you want to perform actions on just a particular package,
+not its whole dependency tree. It must be used in conjunction with
+\fB--download-only\fR or \fB--print-uris\fR.  Configuration Item:
+APT::Get::Ignore-Breakage.
+
+Note: The \fB--ignore-breakage\fR option was added by The Fink Project
+and hence is only available in the \fBapt-get\fR provided by Fink's
+\fBapt\fR package.
+.TP
 This option controls the default input to the policy engine, it creates a default pin at priority 990 using the specified release string\&. The preferences file may further override this setting\&. In short, this option lets you have simple control over which distribution packages will be retrieved from\&. Some common examples might be \fB\-t '2\&.1*'\fR or \fB\-t unstable\fR\&. Configuration Item: APT::Default\-Release; see also the \fB\fBapt_preferences\fR\fR(5) manual page\&.
 
 .TP
@@ -210,35 +221,35 @@
 .SH "FILES"
 
 .TP
-\fI/etc/apt/sources\&.list\fR
+\fI@PREFIX@/etc/apt/sources\&.list\fR
 Locations to fetch packages from\&. Configuration Item: Dir::Etc::SourceList\&.
 
 .TP
-\fI/etc/apt/apt\&.conf\fR
+\fI@PREFIX@/etc/apt/apt\&.conf\fR
 APT configuration file\&. Configuration Item: Dir::Etc::Main\&.
 
 .TP
-\fI/etc/apt/apt\&.conf\&.d/\fR
+\fI@PREFIX@/etc/apt/apt\&.conf\&.d/\fR
 APT configuration file fragments Configuration Item: Dir::Etc::Parts\&.
 
 .TP
-\fI/etc/apt/preferences\fR
+\fI@PREFIX@/etc/apt/preferences\fR
 Version preferences file\&. This is where you would specify "pinning", i\&.e\&. a preference to get certain packages from a separate source or from a different version of a distribution\&. Configuration Item: Dir::Etc::Preferences\&.
 
 .TP
-\fI/var/cache/apt/archives/\fR
+\fI@PREFIX@/var/cache/apt/archives/\fR
 Storage area for retrieved package files\&. Configuration Item: Dir::Cache::Archives\&.
 
 .TP
-\fI/var/cache/apt/archives/partial/\fR
+\fI@PREFIX@/var/cache/apt/archives/partial/\fR
 Storage area for package files in transit\&. Configuration Item: Dir::Cache::Archives (implicit partial)\&.
 
 .TP
-\fI/var/lib/apt/lists/\fR
+\fI@PREFIX@/var/lib/apt/lists/\fR
 Storage area for state information for each package resource specified in \fB\fIsources\&.list\fR\fR(5) Configuration Item: Dir::State::Lists\&.
 
 .TP
-\fI/var/lib/apt/lists/partial/\fR
+\fI@PREFIX@/var/lib/apt/lists/partial/\fR
 Storage area for state information in transit\&. Configuration Item: Dir::State::Lists (implicit partial)\&.
 
 .SH "SEE ALSO"
diff -uNr apt-0.5.28.6/doc/apt-get.8.xml apt-0.5.28.6-new/doc/apt-get.8.xml
--- apt-0.5.28.6/doc/apt-get.8.xml	Mon Jan 10 17:02:42 2005
+++ apt-0.5.28.6-new/doc/apt-get.8.xml	Wed Dec 31 19:00:00 1969
@@ -1,473 +0,0 @@
-<?xml version="1.0" encoding="utf-8" standalone="no"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
-  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
-
-<!ENTITY % aptent SYSTEM "apt.ent">
-%aptent;
-
-]>
-
-<refentry>
-
- <refentryinfo>
-   &apt-author.jgunthorpe;
-   &apt-author.team;
-   &apt-email;
-   &apt-product;
-   <!-- The last update date -->
-   <date>29 February 2004</date>
- </refentryinfo>
- 
- <refmeta>
-   <refentrytitle>apt-get</refentrytitle>
-   <manvolnum>8</manvolnum>
- </refmeta>
- 
- <!-- Man page title -->
- <refnamediv>
-    <refname>apt-get</refname>
-    <refpurpose>APT package handling utility -- command-line interface</refpurpose>
- </refnamediv>
-
- <!-- Arguments -->
- <refsynopsisdiv>
-   <cmdsynopsis>
-      <command>apt-get</command>
-      <arg><option>-hvs</option></arg>
-      <arg><option>-o=<replaceable>config string</replaceable></option></arg>
-      <arg><option>-c=<replaceable>file</replaceable></option></arg>
-      <group choice="req">
-         <arg>update</arg>
-         <arg>upgrade</arg>
-         <arg>dselect-upgrade</arg>
-         <arg>install <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>remove <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>source <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>build-dep <arg choice="plain" rep="repeat"><replaceable>pkg</replaceable></arg></arg>
-         <arg>check</arg>
-         <arg>clean</arg>
-         <arg>autoclean</arg>
-      </group>   
-   </cmdsynopsis>
- </refsynopsisdiv>
- 
- <refsect1><title>Description</title>
-   <para><command>apt-get</command> is the command-line tool for handling packages, and may be 
-   considered the user's "back-end" to other tools using the APT
-   library.  Several "front-end" interfaces exist, such as dselect(8),
-   aptitude, synaptic, gnome-apt and wajig.</para>
-
-   <para>Unless the <option>-h</option>, or <option>--help</option> option is given, one of the
-   commands below must be present.</para>
-   
-   <variablelist>
-     <varlistentry><term>update</term>
-     <listitem><para><literal>update</literal> is used to resynchronize the package index files from
-     their sources. The indexes of available packages are fetched from the
-     location(s) specified in <filename>/etc/apt/sources.list</filename>.
-     For example, when using a Debian archive, this command retrieves and
-     scans the <filename>Packages.gz</filename> files, so that information about new 
-     and updated packages is available. An <literal>update</literal> should always be 
-     performed before an <literal>upgrade</literal> or <literal>dist-upgrade</literal>. Please 
-     be aware that the overall progress meter will be incorrect as the size 
-     of the package files cannot be known in advance.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term>upgrade</term>
-     <listitem><para><literal>upgrade</literal> is used to install the newest versions of all packages 
-     currently installed on the system from the sources enumerated in
-     <filename>/etc/apt/sources.list</filename>. Packages currently installed with 
-     new versions available are retrieved and upgraded; under no circumstances 
-     are currently installed packages removed, or packages not already installed 
-     retrieved and installed. New versions of currently installed packages that 
-     cannot be upgraded without changing the install status of another package 
-     will be left at their current version. An <literal>update</literal> must be 
-     performed first so that <command>apt-get</command> knows that new versions of packages are 
-     available.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>dselect-upgrade</term>
-     <listitem><para><literal>dselect-upgrade</literal>
-     is used in conjunction with the traditional Debian packaging
-     front-end, &dselect;. <literal>dselect-upgrade</literal>
-     follows the changes made by &dselect; to the <literal>Status</literal>
-     field of available packages, and performs the actions necessary to realize
-     that state (for instance, the removal of old and the installation of new
-     packages).</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>dist-upgrade</term>
-     <listitem><para><literal>dist-upgrade</literal> in addition to performing the function of 
-     <literal>upgrade</literal>, also intelligently handles changing dependencies 
-     with new versions of packages; <command>apt-get</command> has a "smart" conflict 
-     resolution system, and it will attempt to upgrade the most important 
-     packages at the expense of less important ones if necessary. 
-     The <filename>/etc/apt/sources.list</filename> file contains a list of locations 
-     from which to retrieve desired package files.
-     See also &apt-preferences; for a mechanism for
-     overriding the general settings for individual packages.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>install</term>
-     <listitem><para><literal>install</literal> is followed by one or more packages desired for 
-     installation. Each package is a package name, not a fully qualified 
-     filename (for instance, in a Debian GNU/Linux system, libc6 would be the 
-     argument provided, not <literal>libc6_1.9.6-2.deb</literal>) All packages required 
-     by the package(s) specified for installation will also be retrieved and 
-     installed. The <filename>/etc/apt/sources.list</filename> file is used to locate 
-     the desired packages. If a hyphen is appended to the package name (with 
-     no intervening space), the identified package will be removed if it is 
-     installed. Similarly a plus sign can be used to designate a package to 
-     install. These latter features may be used to override decisions made by 
-     apt-get's conflict resolution system.</para>
-
-     <para>A specific version of a package can be selected for installation by 
-     following the package name with an equals and the version of the package 
-     to select. This will cause that version to be located and selected for
-     install. Alternatively a specific distribution can be selected by 
-     following the package name with a slash and the version of the 
-     distribution or the Archive name (stable, testing, unstable).</para>
-
-     <para>Both of the version selection mechanisms can downgrade packages and must
-     be used with care.</para>
-
-     <para>Finally, the &apt-preferences; mechanism allows you to
-     create an alternative installation policy for
-     individual packages.</para>
-
-     <para>If no package matches the given expression and the expression contains one
-     of '.', '?' or '*' then it is assumed to be a POSIX regular expression,
-     and it is applied
-     to all package names in the database. Any matches are then installed (or
-     removed). Note that matching is done by substring so 'lo.*' matches 'how-lo'
-     and 'lowest'. If this is undesired, anchor the regular expression
-     with a '^' or '$' character, or create a more specific regular expression.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>remove</term>
-     <listitem><para><literal>remove</literal> is identical to <literal>install</literal> except that packages are 
-     removed instead of installed. If a plus sign is appended to the package 
-     name (with no intervening space), the identified package will be 
-     installed instead of removed.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>source</term>
-     <listitem><para><literal>source</literal> causes <command>apt-get</command> to fetch source packages. APT 
-     will examine the available packages to decide which source package to 
-     fetch. It will then find and download into the current directory the 
-     newest available version of that source package. Source packages are 
-     tracked separately from binary packages via <literal>deb-src</literal> type lines 
-     in the &sources-list; file. This probably will mean that you will not 
-     get the same source as the package you have installed or as you could 
-     install. If the --compile options is specified then the package will be 
-     compiled to a binary .deb using dpkg-buildpackage, if --download-only is 
-     specified then the source package will not be unpacked.</para>
-
-     <para>A specific source version can be retrieved by postfixing the source name
-     with an equals and then the version to fetch, similar to the mechanism
-     used for the package files. This enables exact matching of the source 
-     package name and version, implicitly enabling the 
-     <literal>APT::Get::Only-Source</literal> option.</para>
-     
-     <para>Note that source packages are not tracked like binary packages, they 
-     exist only in the current directory and are similar to downloading source
-     tar balls.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>build-dep</term>
-     <listitem><para><literal>build-dep</literal> causes apt-get to install/remove packages in an 
-     attempt to satisfy the build dependencies for a source package.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>check</term>
-     <listitem><para><literal>check</literal> is a diagnostic tool; it updates the package cache and checks 
-     for broken dependencies.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>clean</term>
-     <listitem><para><literal>clean</literal> clears out the local repository of retrieved package 
-     files. It removes everything but the lock file from 
-     <filename>&cachedir;/archives/</filename> and 
-     <filename>&cachedir;/archives/partial/</filename>. When APT is used as a 
-     &dselect; method, <literal>clean</literal> is run automatically.
-     Those who do not use dselect will likely want to run <literal>apt-get clean</literal>
-     from time to time to free up disk space.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term>autoclean</term>
-     <listitem><para>Like <literal>clean</literal>, <literal>autoclean</literal> clears out the local 
-     repository of retrieved package files. The difference is that it only 
-     removes package files that can no longer be downloaded, and are largely 
-     useless. This allows a cache to be maintained over a long period without 
-     it growing out of control. The configuration option 
-     <literal>APT::Clean-Installed</literal> will prevent installed packages from being
-     erased if it is set to off.</para></listitem>
-     </varlistentry>
-   </variablelist>
- </refsect1>
- 
- <refsect1><title>options</title>
-   &apt-cmdblurb;
-
-   <variablelist>
-     <varlistentry><term><option>-d</option></term><term><option>--download-only</option></term>
-     <listitem><para>Download only; package files are only retrieved, not unpacked or installed.
-     Configuration Item: <literal>APT::Get::Download-Only</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-f</option></term><term><option>--fix-broken</option></term>
-     <listitem><para>Fix; attempt to correct a system with broken dependencies in            
-     place. This option, when used with install/remove, can omit any packages
-     to permit APT to deduce a likely solution. Any Package that are specified
-     must completely correct the problem. The option is sometimes necessary when 
-     running APT for the first time; APT itself does not allow broken package 
-     dependencies to exist on a system. It is possible that a system's 
-     dependency structure can be so corrupt as to require manual intervention 
-     (which usually means using &dselect; or <command>dpkg --remove</command> to eliminate some of 
-     the offending packages). Use of this option together with <option>-m</option> may produce an
-     error in some situations. 
-     Configuration Item: <literal>APT::Get::Fix-Broken</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-m</option></term><term><option>--ignore-missing</option></term>
-     <term><option>--fix-missing</option></term>
-     <listitem><para>Ignore missing packages; If packages cannot be retrieved or fail the    
-     integrity check after retrieval (corrupted package files), hold back    
-     those packages and handle the result. Use of this option together with  
-     <option>-f</option> may produce an error in some situations. If a package is 
-     selected for installation (particularly if it is mentioned on the 
-     command line) and it could not be downloaded then it will be silently 
-     held back.
-     Configuration Item: <literal>APT::Get::Fix-Missing</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--no-download</option></term>
-     <listitem><para>Disables downloading of packages. This is best used with 
-     <option>--ignore-missing</option> to force APT to use only the .debs it has 
-     already downloaded.
-     Configuration Item: <literal>APT::Get::Download</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-q</option></term><term><option>--quiet</option></term>
-     <listitem><para>Quiet; produces output suitable for logging, omitting progress indicators.
-     More q's will produce more quiet up to a maximum of 2. You can also use
-     <option>-q=#</option> to set the quiet level, overriding the configuration file. 
-     Note that quiet level 2 implies <option>-y</option>, you should never use -qq 
-     without a no-action modifier such as -d, --print-uris or -s as APT may 
-     decided to do something you did not expect.
-     Configuration Item: <literal>quiet</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-s</option></term>
-                   <term><option>--simulate</option></term>
-		   <term><option>--just-print</option></term>
-		   <term><option>--dry-run</option></term>
-		   <term><option>--recon</option></term>
-		   <term><option>--no-act</option></term>
-     <listitem><para>No action; perform a simulation of events that would occur but do not
-     actually change the system. 
-     Configuration Item: <literal>APT::Get::Simulate</literal>.</para>
-
-     <para>Simulate prints out
-     a series of lines each one representing a dpkg operation, Configure (Conf),
-     Remove (Remv), Unpack (Inst). Square brackets indicate broken packages with
-     and empty set of square brackets meaning breaks that are of no consequence
-     (rare).</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-y</option></term><term><option>--yes</option></term>
-                   <term><option>--assume-yes</option></term>
-     <listitem><para>Automatic yes to prompts; assume "yes" as answer to all prompts and run
-     non-interactively. If an undesirable situation, such as changing a held
-     package or removing an essential package occurs then <literal>apt-get</literal> 
-     will abort. 
-     Configuration Item: <literal>APT::Get::Assume-Yes</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-u</option></term><term><option>--show-upgraded</option></term>
-     <listitem><para>Show upgraded packages; Print out a list of all packages that are to be
-     upgraded. 
-     Configuration Item: <literal>APT::Get::Show-Upgraded</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-V</option></term><term><option>--verbose-versions</option></term>
-     <listitem><para>Show full versions for upgraded and installed packages.
-     Configuration Item: <literal>APT::Get::Show-Versions</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-b</option></term><term><option>--compile</option></term>
-                   <term><option>--build</option></term>
-     <listitem><para>Compile source packages after downloading them.
-     Configuration Item: <literal>APT::Get::Compile</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--ignore-hold</option></term>
-     <listitem><para>Ignore package Holds; This causes <command>apt-get</command> to ignore a hold 
-     placed on a package. This may be useful in conjunction with 
-     <literal>dist-upgrade</literal> to override a large number of undesired holds. 
-     Configuration Item: <literal>APT::Ignore-Hold</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--no-upgrade</option></term>
-     <listitem><para>Do not upgrade packages; When used in conjunction with <literal>install</literal>,
-     <literal>no-upgrade</literal> will prevent packages on the command line
-     from being upgraded if they are already installed.
-     Configuration Item: <literal>APT::Get::Upgrade</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--force-yes</option></term>
-     <listitem><para>Force yes; This is a dangerous option that will cause apt to continue 
-     without prompting if it is doing something potentially harmful. It 
-     should not be used except in very special situations. Using 
-     <literal>force-yes</literal> can potentially destroy your system! 
-     Configuration Item: <literal>APT::Get::force-yes</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--print-uris</option></term>
-     <listitem><para>Instead of fetching the files to install their URIs are printed. Each
-     URI will have the path, the destination file name, the size and the expected
-     md5 hash. Note that the file name to write to will not always match
-     the file name on the remote site! This also works with the 
-     <literal>source</literal> and <literal>update</literal> commands. When used with the
-     <literal>update</literal> command the MD5 and size are not included, and it is
-     up to the user to decompress any compressed files.
-     Configuration Item: <literal>APT::Get::Print-URIs</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--purge</option></term>
-     <listitem><para>Use purge instead of remove for anything that would be removed.
-     An asterisk ("*") will be displayed next to packages which are
-     scheduled to be purged.
-     Configuration Item: <literal>APT::Get::Purge</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--reinstall</option></term>
-     <listitem><para>Re-Install packages that are already installed and at the newest version.
-     Configuration Item: <literal>APT::Get::ReInstall</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--list-cleanup</option></term>
-     <listitem><para>This option defaults to on, use <literal>--no-list-cleanup</literal> to turn it 
-     off. When on <command>apt-get</command> will automatically manage the contents of 
-     <filename>&statedir;/lists</filename> to ensure that obsolete files are erased. 
-     The only  reason to turn it off is if you frequently change your source 
-     list. 
-     Configuration Item: <literal>APT::Get::List-Cleanup</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>-t</option></term>
-                   <term><option>--target-release</option></term>
-                   <term><option>--default-release</option></term>
-     <listitem><para>This option controls the default input to the policy engine, it creates
-     a default pin at priority 990 using the specified release string. The
-     preferences file may further override this setting. In short, this option
-     lets you have simple control over which distribution packages will be
-     retrieved from. Some common examples might be 
-     <option>-t '2.1*'</option> or <option>-t unstable</option>.
-     Configuration Item: <literal>APT::Default-Release</literal>;
-     see also the &apt-preferences; manual page.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--trivial-only</option></term>
-     <listitem><para>
-     Only perform operations that are 'trivial'. Logically this can be considered
-     related to <option>--assume-yes</option>, where <option>--assume-yes</option> will answer 
-     yes to any prompt, <option>--trivial-only</option> will answer no. 
-     Configuration Item: <literal>APT::Get::Trivial-Only</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--no-remove</option></term>
-     <listitem><para>If any packages are to be removed apt-get immediately aborts without
-     prompting. 
-     Configuration Item: <literal>APT::Get::Remove</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--only-source</option></term>
-     <listitem><para>Only has meaning for the
-     <literal>source</literal> and <literal>build-dep</literal>
-     commands.  Indicates that the given source names are not to be
-     mapped through the binary table.  This means that if this option
-     is specified, these commands will only accept source package
-     names as arguments, rather than accepting binary package names
-     and looking up the corresponding source package.  Configuration
-     Item: <literal>APT::Get::Only-Source</literal>.</para></listitem>
-     </varlistentry>
-
-     <varlistentry><term><option>--diff-only</option></term><term><option>--tar-only</option></term>
-     <listitem><para>Download only the diff or tar file of a source archive. 
-     Configuration Item: <literal>APT::Get::Diff-Only</literal> and 
-     <literal>APT::Get::Tar-Only</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><option>--arch-only</option></term>
-     <listitem><para>Only process architecture-dependent build-dependencies.
-     Configuration Item: <literal>APT::Get::Arch-Only</literal>.</para></listitem>
-     </varlistentry>
-     
-     &apt-commonoptions;
-     
-   </variablelist>
- </refsect1>
-
- <refsect1><title>Files</title>
-   <variablelist>
-     <varlistentry><term><filename>/etc/apt/sources.list</filename></term>
-     <listitem><para>Locations to fetch packages from.
-     Configuration Item: <literal>Dir::Etc::SourceList</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>/etc/apt/apt.conf</filename></term>
-     <listitem><para>APT configuration file.
-     Configuration Item: <literal>Dir::Etc::Main</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>/etc/apt/apt.conf.d/</filename></term>
-     <listitem><para>APT configuration file fragments
-     Configuration Item: <literal>Dir::Etc::Parts</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>/etc/apt/preferences</filename></term>
-     <listitem><para>Version preferences file.
-     This is where you would specify "pinning",
-     i.e. a preference to get certain packages
-     from a separate source
-     or from a different version of a distribution.
-     Configuration Item: <literal>Dir::Etc::Preferences</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>&cachedir;/archives/</filename></term>
-     <listitem><para>Storage area for retrieved package files.
-     Configuration Item: <literal>Dir::Cache::Archives</literal>.</para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>&cachedir;/archives/partial/</filename></term>
-     <listitem><para>Storage area for package files in transit.
-     Configuration Item: <literal>Dir::Cache::Archives</literal> (implicit partial). </para></listitem>
-     </varlistentry>
-     
-     <varlistentry><term><filename>&statedir;/lists/</filename></term>
-     <listitem><para>Storage area for state information for each package resource specified in
-     &sources-list;
-     Configuration Item: <literal>Dir::State::Lists</literal>.</para></listitem>
-     </varlistentry>
-  
-     <varlistentry><term><filename>&statedir;/lists/partial/</filename></term>
-     <listitem><para> Storage area for state information in transit.
-     Configuration Item: <literal>Dir::State::Lists</literal> (implicit partial).</para></listitem>
-     </varlistentry>     
-   </variablelist>
- </refsect1>
-
- <refsect1><title>See Also</title>
-   <para>&apt-cache;, &apt-cdrom;, &dpkg;, &dselect;, &sources-list;,
-   &apt-conf;, &apt-config;,
-   The APT User's guide in &docdir;, &apt-preferences;, the APT Howto.</para>
- </refsect1>
-
- <refsect1><title>Diagnostics</title>
-   <para><command>apt-get</command> returns zero on normal operation, decimal 100 on error.</para>
- </refsect1>
-
- &manbugs;
- 
-</refentry>
diff -uNr apt-0.5.28.6/doc/apt_preferences.5 apt-0.5.28.6-new/doc/apt_preferences.5
--- apt-0.5.28.6/doc/apt_preferences.5	Tue Mar 22 02:07:13 2005
+++ apt-0.5.28.6-new/doc/apt_preferences.5	Mon Apr 25 16:42:32 2005
@@ -23,7 +23,7 @@
 .SH "DESCRIPTION"
 
 .PP
-The APT preferences file \fI/etc/apt/preferences\fR can be used to control which versions of packages will be selected for installation\&.
+The APT preferences file \fI@PREFIX@/etc/apt/preferences\fR can be used to control which versions of packages will be selected for installation\&.
 
 .PP
 Several versions of a package may be available for installation when the \fB\fIsources\&.list\fR\fR(5) file contains references to more than one distribution (for example, stable and testing)\&. APT assigns a priority to each version that is available\&. Subject to dependency constraints, \fBapt\-get\fR selects the version with the highest priority for installation\&. The APT preferences file overrides the priorities that APT assigns to package versions by default, thus giving the user control over which one is selected for installation\&.
@@ -34,7 +34,7 @@
 .SS "APT's Default Priority Assignments"
 
 .PP
-If there is no preferences file or if there is no entry in the file that applies to a particular version then the priority assigned to that version is the priority of the distribution to which that version belongs\&. It is possible to single out a distribution, "the target release", which receives a higher priority than other distributions do by default\&. The target release can be set on the \fBapt\-get\fR command line or in the APT configuration file \fI/etc/apt/apt\&.conf\fR\&. For example, 
+If there is no preferences file or if there is no entry in the file that applies to a particular version then the priority assigned to that version is the priority of the distribution to which that version belongs\&. It is possible to single out a distribution, "the target release", which receives a higher priority than other distributions do by default\&. The target release can be set on the \fBapt\-get\fR command line or in the APT configuration file \fI@PREFIX@/etc/apt/apt\&.conf\fR\&. For example, 
 
 .nf
 
@@ -291,7 +291,7 @@
  
 
 .PP
-All of the \fIPackages\fR and \fIRelease\fR files retrieved from locations listed in the \fB\fIsources\&.list\fR\fR(5) file are stored in the directory \fI/var/lib/apt/lists\fR, or in the file named by the variable Dir::State::Lists in the \fIapt\&.conf\fR file\&. For example, the file \fIdebian\&.lcs\&.mit\&.edu_debian_dists_unstable_contrib_binary\-i386_Release\fR contains the \fIRelease\fR file retrieved from the site debian\&.lcs\&.mit\&.edu for binary\-i386 architecture files from the contrib component of the unstable distribution\&.
+All of the \fIPackages\fR and \fIRelease\fR files retrieved from locations listed in the \fB\fIsources\&.list\fR\fR(5) file are stored in the directory \fI@PREFIX@/var/lib/apt/lists\fR, or in the file named by the variable Dir::State::Lists in the \fIapt\&.conf\fR file\&. For example, the file \fIdebian\&.lcs\&.mit\&.edu_debian_dists_unstable_contrib_binary\-i386_Release\fR contains the \fIRelease\fR file retrieved from the site debian\&.lcs\&.mit\&.edu for binary\-i386 architecture files from the contrib component of the unstable distribution\&.
 
 .SS "Optional Lines in an APT Preferences Record"
 
diff -uNr apt-0.5.28.6/doc/apt_preferences.5.xml apt-0.5.28.6-new/doc/apt_preferences.5.xml
--- apt-0.5.28.6/doc/apt_preferences.5.xml	Mon Jan 10 17:02:42 2005
+++ apt-0.5.28.6-new/doc/apt_preferences.5.xml	Wed Dec 31 19:00:00 1969
@@ -1,534 +0,0 @@
-<?xml version="1.0" encoding="utf-8" standalone="no"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
-  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
-
-<!ENTITY % aptent SYSTEM "apt.ent">
-%aptent;
-
-]>
-
-<refentry>
-
- <refentryinfo>
-   &apt-author.team;
-   &apt-email;
-   &apt-product;
-   <!-- The last update date -->
-   <date>29 February 2004</date>
- </refentryinfo>
-
- <refmeta>
-   <refentrytitle>apt_preferences</refentrytitle>
-   <manvolnum>5</manvolnum>
- </refmeta>
-
- <!-- Man page title -->
- <refnamediv>
-    <refname>apt_preferences</refname>
-    <refpurpose>Preference control file for APT</refpurpose>
- </refnamediv>
-
-<refsect1>
-<title>Description</title>
-<para>The APT preferences file <filename>/etc/apt/preferences</filename>
-can be used to control which versions of packages will be selected
-for installation.</para>
-
-<para>Several versions of a package may be available for installation when
-the &sources-list; file contains references to more than one distribution
-(for example, <literal>stable</literal> and <literal>testing</literal>).
-APT assigns a priority to each version that is available.
-Subject to dependency constraints, <command>apt-get</command> selects the
-version with the highest priority for installation.
-The APT preferences file overrides the priorities that APT assigns to
-package versions by default, thus giving the user control over which
-one is selected for installation.</para>
-
-<para>Several instances of the same version of a package may be available when
-the &sources-list; file contains references to more than one source.
-In this case <command>apt-get</command> downloads the instance listed
-earliest in the &sources-list; file.
-The APT preferences file does not affect the choice of instance, only
-the choice of version.</para>
-
-<refsect2><title>APT's Default Priority Assignments</title>
-
-<para>If there is no preferences file or if there is no entry in the file
-that applies to a particular version then the priority assigned to that
-version is the priority of the distribution to which that version
-belongs.  It is possible to single out a distribution, "the target release",
-which receives a higher priority than other distributions do by default.
-The target release can be set on the <command>apt-get</command> command
-line or in the APT configuration file <filename>/etc/apt/apt.conf</filename>.
-For example,
-
-<programlisting>
-<command>apt-get install -t testing <replaceable>some-package</replaceable></command>
-</programlisting>
-<programlisting>
-APT::Default-Release "stable";
-</programlisting>
-</para>
-
-<para>If the target release has been specified then APT uses the following
-algorithm to set the priorities of the versions of a package.  Assign:
-
-<variablelist>
-<varlistentry>
-<term>priority 100</term>
-<listitem><simpara>to the version that is already installed (if any).</simpara></listitem>
-</varlistentry>
-
-<varlistentry>
-<term>priority 500</term>
-<listitem><simpara>to the versions that are not installed and do not belong to the target release.</simpara></listitem>
-</varlistentry>
-
-<varlistentry>
-<term>priority 990</term>
-<listitem><simpara>to the versions that are not installed and belong to the target release.</simpara></listitem>
-</varlistentry>
-</variablelist>
-</para>
-
-<para>If the target release has not been specified then APT simply assigns
-priority 100 to all installed package versions and priority 500 to all
-uninstalled package versions.</para>
-
-<para>APT then applies the following rules, listed in order of precedence,
-to determine which version of a package to install.
-<itemizedlist>
-<listitem><simpara>Never downgrade unless the priority of an available
-version exceeds 1000.  ("Downgrading" is installing a less recent version
-of a package in place of a more recent version.  Note that none of APT's
-default priorities exceeds 1000; such high priorities can only be set in
-the preferences file.  Note also that downgrading a package
-can be risky.)</simpara></listitem>
-<listitem><simpara>Install the highest priority version.</simpara></listitem>
-<listitem><simpara>If two or more versions have the same priority,
-install the most recent one (that is, the one with the higher version
-number).</simpara></listitem>
-<listitem><simpara>If two or more versions have the same priority and
-version number but either the packages differ in some of their metadata or the
-<literal>--reinstall</literal> option is given, install the uninstalled one.</simpara></listitem>
-</itemizedlist>
-</para>
-
-<para>In a typical situation, the installed version of a package (priority 100)
-is not as recent as one of the versions available from the sources listed in
-the &sources-list; file (priority 500 or 990).  Then the package will be upgraded
-when <command>apt-get install <replaceable>some-package</replaceable></command>
-or <command>apt-get upgrade</command> is executed.
-</para>
-
-<para>More rarely, the installed version of a package is <emphasis>more</emphasis> recent
-than any of the other available versions.  The package will not be downgraded
-when <command>apt-get install <replaceable>some-package</replaceable></command>
-or <command>apt-get upgrade</command> is executed.</para>
-
-<para>Sometimes the installed version of a package is more recent than the
-version belonging to the target release, but not as recent as a version
-belonging to some other distribution.  Such a package will indeed be upgraded
-when <command>apt-get install <replaceable>some-package</replaceable></command>
-or <command>apt-get upgrade</command> is executed,
-because at least <emphasis>one</emphasis> of the available versions has a higher
-priority than the installed version.</para>
-</refsect2>
-
-<refsect2><title>The Effect of APT Preferences</title>
-
-<para>The APT preferences file allows the system administrator to control the
-assignment of priorities.  The file consists of one or more multi-line records
-separated by blank lines.  Records can have one of two forms, a specific form
-and a general form.
-<itemizedlist>
-<listitem>
-<simpara>The specific form assigns a priority (a "Pin-Priority") to a
-specified package and specified version or version range.  For example,
-the following record assigns a high priority to all versions of
-the <filename>perl</filename> package whose version number begins with "<literal>5.8</literal>".</simpara>
-
-<programlisting>
-Package: perl
-Pin: version 5.8*
-Pin-Priority: 1001
-</programlisting>
-</listitem>
-
-<listitem><simpara>The general form assigns a priority to all of the package versions in a
-given distribution (that is, to all the versions of packages that are
-listed in a certain <filename>Release</filename> file) or to all of the package
-versions coming from a particular Internet site, as identified by the
-site's fully qualified domain name.</simpara>
-
-<simpara>This general-form entry in the APT preferences file applies only
-to groups of packages.  For example, the following record assigns a high
-priority to all package versions available from the local site.</simpara>
-
-<programlisting>
-Package: *
-Pin: origin ""
-Pin-Priority: 999
-</programlisting>
-
-<simpara>A note of caution: the keyword used here is "<literal>origin</literal>".
-This should not be confused with the Origin of a distribution as
-specified in a <filename>Release</filename> file.  What follows the "Origin:" tag
-in a <filename>Release</filename> file is not an Internet address
-but an author or vendor name, such as "Debian" or "Ximian".</simpara>
-
-<simpara>The following record assigns a low priority to all package versions
-belonging to any distribution whose Archive name is "<literal>unstable</literal>".</simpara>
-
-<programlisting>
-Package: *
-Pin: release a=unstable
-Pin-Priority: 50
-</programlisting>
-
-<simpara>The following record assigns a high priority to all package versions
-belonging to any release whose Archive name is "<literal>stable</literal>"
-and whose release Version number is "<literal>3.0</literal>".</simpara>
-
-<programlisting>
-Package: *
-Pin: release a=unstable, v=3.0
-Pin-Priority: 50
-</programlisting>
-</listitem>
-</itemizedlist>
-</para>
-
-</refsect2>
-
-<refsect2>
-<title>How APT Interprets Priorities</title>
-
-<para>
-Priorities (P) assigned in the APT preferences file must be positive
-or negative integers.  They are interpreted as follows (roughly speaking):
-
-<variablelist>
-<varlistentry>
-<term>P &gt; 1000</term>
-<listitem><simpara>causes a version to be installed even if this
-constitutes a downgrade of the package</simpara></listitem>
-</varlistentry>
-<varlistentry>
-<term>990 &lt; P &lt;=1000</term>
-<listitem><simpara>causes a version to be installed
-even if it does not come from the target release,
-unless the installed version is more recent</simpara></listitem>
-</varlistentry>
-<varlistentry>
-<term>500 &lt; P &lt;=990</term>
-<listitem><simpara>causes a version to be installed
-unless there is a version available belonging to the target release
-or the installed version is more recent</simpara></listitem>
-</varlistentry>
-<varlistentry>
-<term>100 &lt; P &lt;=500</term>
-<listitem><simpara>causes a version to be installed
-unless there is a version available belonging to some other
-distribution or the installed version is more recent</simpara></listitem>
-</varlistentry>
-<varlistentry>
-<term>0 &lt; P &lt;=100</term>
-<listitem><simpara>causes a version to be installed
-only if there is no installed version of the package</simpara></listitem>
-</varlistentry>
-<varlistentry>
-<term>P &lt; 0</term>
-<listitem><simpara>prevents the version from being installed</simpara></listitem>
-</varlistentry>
-</variablelist>
-</para>
-
-<para>If any specific-form records match an available package version then the
-first such record determines the priority of the package version.  
-Failing that,
-if any general-form records match an available package version then the
-first such record determines the priority of the package version.</para>
-
-<para>For example, suppose the APT preferences file contains the three
-records presented earlier:</para>
-
-<programlisting>
-Package: perl
-Pin: version 5.8*
-Pin-Priority: 1001
-
-Package: *
-Pin: origin ""
-Pin-Priority: 999
-
-Package: *
-Pin: release unstable
-Pin-Priority: 50
-</programlisting>
-
-<para>Then:
-<itemizedlist>
-<listitem><simpara>The most recent available version of the <literal>perl</literal>
-package will be installed, so long as that version's version number begins
-with "<literal>5.8</literal>".  If <emphasis>any</emphasis> 5.8* version of <literal>perl</literal> is
-available and the installed version is 5.9*, then <literal>perl</literal> will be
-downgraded.</simpara></listitem>
-<listitem><simpara>A version of any package other than <literal>perl</literal>
-that is available from the local system has priority over other versions,
-even versions belonging to the target release.
-</simpara></listitem>
-<listitem><simpara>A version of a package whose origin is not the local
-system but some other site listed in &sources-list; and which belongs to
-an <literal>unstable</literal> distribution is only installed if it is selected
-for installation and no version of the package is already installed.
-</simpara></listitem>
-</itemizedlist>
-</para>
-</refsect2>
-
-<refsect2>
-<title>Determination of Package Version and Distribution Properties</title>
-
-<para>The locations listed in the &sources-list; file should provide
-<filename>Packages</filename> and <filename>Release</filename> files
-to describe the packages available at that location. </para>
-
-<para>The <filename>Packages</filename> file is normally found in the directory
-<filename>.../dists/<replaceable>dist-name</replaceable>/<replaceable>component</replaceable>/<replaceable>arch</replaceable></filename>:
-for example, <filename>.../dists/stable/main/binary-i386/Packages</filename>.
-It consists of a series of multi-line records, one for each package available
-in that directory.  Only two lines in each record are relevant for setting
-APT priorities:
-<variablelist>
-<varlistentry>
-<term>the <literal>Package:</literal> line</term>
-<listitem><simpara>gives the package name</simpara></listitem>
-</varlistentry>
-<varlistentry>
-<term>the <literal>Version:</literal> line</term>
-<listitem><simpara>gives the version number for the named package</simpara></listitem>
-</varlistentry>
-</variablelist>
-</para>
-
-<para>The <filename>Release</filename> file is normally found in the directory
-<filename>.../dists/<replaceable>dist-name</replaceable></filename>:
-for example, <filename>.../dists/stable/Release</filename>,
-or <filename>.../dists/woody/Release</filename>.
-It consists of a single multi-line record which applies to <emphasis>all</emphasis> of
-the packages in the directory tree below its parent.  Unlike the
-<filename>Packages</filename> file, nearly all of the lines in a <filename>Release</filename>
-file are relevant for setting APT priorities:
-
-<variablelist>
-<varlistentry>
-<term>the <literal>Archive:</literal> line</term>
-<listitem><simpara>names the archive to which all the packages
-in the directory tree belong.  For example, the line
-"Archive: stable"
-specifies that all of the packages in the directory
-tree below the parent of the <filename>Release</filename> file are in a
-<literal>stable</literal> archive.  Specifying this value in the APT preferences file
-would require the line:
-</simpara>
-<programlisting>
-Pin: release a=stable
-</programlisting>
-</listitem>
-</varlistentry>
-
-<varlistentry>
-<term>the <literal>Version:</literal> line</term>
-<listitem><simpara>names the release version.  For example, the
-packages in the tree might belong to Debian GNU/Linux release
-version 3.0.  Note that there is normally no version number for the
-<literal>testing</literal> and <literal>unstable</literal> distributions because they
-have not been released yet.  Specifying this in the APT preferences
-file would require one of the following lines.
-</simpara>
-
-<programlisting>
-Pin: release v=3.0
-Pin: release a=stable, v=3.0
-Pin: release 3.0
-</programlisting>
-
-</listitem>
-</varlistentry>
-
-<varlistentry>
-<term>the <literal>Component:</literal> line</term>
-<listitem><simpara>names the licensing component associated with the
-packages in the directory tree of the <filename>Release</filename> file.
-For example, the line "Component: main" specifies that
-all the packages in the directory tree are from the <literal>main</literal>
-component, which entails that they are licensed under terms listed
-in the Debian Free Software Guidelines.  Specifying this component
-in the APT preferences file would require the line:
-</simpara>
-<programlisting>
-Pin: release c=main
-</programlisting>
-</listitem>
-</varlistentry>
-
-<varlistentry>
-<term>the <literal>Origin:</literal> line</term>
-<listitem><simpara>names the originator of the packages in the
-directory tree of the <filename>Release</filename> file.  Most commonly, this is
-<literal>Debian</literal>.  Specifying this origin in the APT preferences file
-would require the line:
-</simpara>
-<programlisting>
-Pin: release o=Debian
-</programlisting>
-</listitem>
-</varlistentry>
-
-<varlistentry>
-<term>the <literal>Label:</literal> line</term>
-<listitem><simpara>names the label of the packages in the directory tree
-of the <filename>Release</filename> file.  Most commonly, this is
-<literal>Debian</literal>.  Specifying this label in the APT preferences file
-would require the line:
-</simpara>
-<programlisting>
-Pin: release l=Debian
-</programlisting>
-</listitem>
-</varlistentry>
-</variablelist>
-</para>
-
-<para>All of the <filename>Packages</filename> and <filename>Release</filename>
-files retrieved from locations listed in the &sources-list; file are stored
-in the directory <filename>/var/lib/apt/lists</filename>, or in the file named
-by the variable <literal>Dir::State::Lists</literal> in the <filename>apt.conf</filename> file.
-For example, the file
-<filename>debian.lcs.mit.edu_debian_dists_unstable_contrib_binary-i386_Release</filename>
-contains the <filename>Release</filename> file retrieved from the site
-<literal>debian.lcs.mit.edu</literal> for <literal>binary-i386</literal> architecture
-files from the <literal>contrib</literal> component of the <literal>unstable</literal>
-distribution.</para>
-</refsect2>
-
-<refsect2>
-<title>Optional Lines in an APT Preferences Record</title>
-
-<para>Each record in the APT preferences file can optionally begin with
-one or more lines beginning with the word <literal>Explanation:</literal>.
-This provides a place for comments.</para>
-
-<para>The <literal>Pin-Priority:</literal> line in each APT preferences record is
-optional.  If omitted, APT assigs a priority of 1 less than the last value
-specified on a line beginning with <literal>Pin-Priority: release ...</literal>.</para>
-</refsect2>
-</refsect1>
-
-<refsect1>
-<title>Examples</title>
-<refsect2>
-<title>Tracking Stable</title>
-
-<para>The following APT preferences file will cause APT to assign a
-priority higher than the default (500) to all package versions belonging
-to a <literal>stable</literal> distribution and a prohibitively low priority to
-package versions belonging to other <literal>Debian</literal> distributions.
-
-<programlisting>
-Explanation: Uninstall or do not install any Debian-originated
-Explanation: package versions other than those in the stable distro
-Package: *
-Pin: release a=stable
-Pin-Priority: 900
-
-Package: *
-Pin: release o=Debian
-Pin-Priority: -10
-</programlisting>
-</para>
-
-<para>With a suitable &sources-list; file and the above preferences file,
-any of the following commands will cause APT to upgrade to the
-latest <literal>stable</literal> version(s).
-
-<programlisting>
-apt-get install <replaceable>package-name</replaceable>
-apt-get upgrade
-apt-get dist-upgrade
-</programlisting>
-</para>
-
-<para>The following command will cause APT to upgrade the specified
-package to the latest version from the <literal>testing</literal> distribution;
-the package will not be upgraded again unless this command is given
-again.
-
-<programlisting>
-apt-get install <replaceable>package</replaceable>/testing
-</programlisting>
-</para>
-</refsect2>
-
- <refsect2>
- <title>Tracking Testing or Unstable</title>
-
-<para>The following APT preferences file will cause APT to assign
-a high priority to package versions from the <literal>testing</literal>
-distribution, a lower priority to package versions from the
-<literal>unstable</literal> distribution, and a prohibitively low priority
-to package versions from other <literal>Debian</literal> distributions.
-
-<programlisting>
-Package: *
-Pin: release a=testing
-Pin-Priority: 900
-
-Package: *
-Pin: release a=unstable
-Pin-Priority: 800
-
-Package: *
-Pin: release o=Debian
-Pin-Priority: -10
-</programlisting>
-</para>
-
-<para>With a suitable &sources-list; file and the above preferences file,
-any of the following commands will cause APT to upgrade to the latest
-<literal>testing</literal> version(s).
-
-<programlisting>
-apt-get install <replaceable>package-name</replaceable>
-apt-get upgrade
-apt-get dist-upgrade
-</programlisting>
-</para>
-
-<para>The following command will cause APT to upgrade the specified
-package to the latest version from the <literal>unstable</literal> distribution.
-Thereafter, <command>apt-get upgrade</command> will upgrade
-the package to the most recent <literal>testing</literal> version if that is
-more recent than the installed version, otherwise, to the most recent
-<literal>unstable</literal> version if that is more recent than the installed
-version.
-
-<programlisting>
-apt-get install <replaceable>package</replaceable>/unstable
-</programlisting>
-</para>
-
-</refsect2>
-</refsect1>
-
-<refsect1>
-<title>See Also</title>
-<para>&apt-get; &apt-cache; &apt-conf; &sources-list;
-</para>
-</refsect1>
-
- &manbugs;
-
-</refentry>
-
diff -uNr apt-0.5.28.6/doc/sources.list.5 apt-0.5.28.6-new/doc/sources.list.5
--- apt-0.5.28.6/doc/sources.list.5	Tue Mar 22 02:07:08 2005
+++ apt-0.5.28.6-new/doc/sources.list.5	Mon Apr 25 16:44:18 2005
@@ -23,7 +23,7 @@
 .SH "DESCRIPTION"
 
 .PP
-The package resource list is used to locate archives of the package distribution system in use on the system\&. At this time, this manual page documents only the packaging system used by the Debian GNU/Linux system\&. This control file is located in \fI/etc/apt/sources\&.list\fR
+The package resource list is used to locate archives of the package distribution system in use on the system\&. At this time, this manual page documents only the packaging system used by the Debian GNU/Linux system\&. This control file is located in \fI@PREFIX@/etc/apt/sources\&.list\fR
 
 .PP
 The source list is designed to support any number of active sources and a variety of source media\&. The file lists one source per line, with the most preferred source listed first\&. The format of each line is: type uri args The first item, type determines the format for args  uri is a Universal Resource Identifier (URI), which is a superset of the more specific and well\-known Universal Resource Locator, or URL\&. The rest of the line can be marked as a comment by using a #\&.
@@ -31,7 +31,7 @@
 .SH "THE DEB AND DEB-SRC TYPES"
 
 .PP
-The deb type describes a typical two\-level Debian archive, \fIdistribution/component\fR\&. Typically, distribution is generally one of stable  unstable or testing while component is one of main  contrib  non\-free or non\-us The deb\-src type describes a debian distribution's source code in the same form as the deb type\&. A deb\-src line is required to fetch source indexes\&.
+The deb type describes a typical two\-level Debian archive, \fIdistribution/component\fR\&. Typically, distribution is generally one of @DIST@/release or @DIST@/current, while component is one of main or crypto. The deb\-src type describes a debian distribution's source code in the same form as the deb type\&. A deb\-src line is required to fetch source indexes\&.
 
 .PP
 The format for a \fIsources\&.list\fR entry using the deb and deb\-src types are:
diff -uNr apt-0.5.28.6/doc/sources.list.5.xml apt-0.5.28.6-new/doc/sources.list.5.xml
--- apt-0.5.28.6/doc/sources.list.5.xml	Mon Jan 10 17:02:42 2005
+++ apt-0.5.28.6-new/doc/sources.list.5.xml	Wed Dec 31 19:00:00 1969
@@ -1,217 +0,0 @@
-<?xml version="1.0" encoding="utf-8" standalone="no"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
-  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
-
-<!ENTITY % aptent SYSTEM "apt.ent">
-%aptent;
-
-]>
-
-<refentry>
-
- <refentryinfo>
-   &apt-author.jgunthorpe;
-   &apt-author.team;
-   &apt-email;
-   &apt-product;
-   <!-- The last update date -->
-   <date>29 February 2004</date>
- </refentryinfo>
- 
- <refmeta>
-   <refentrytitle>sources.list</refentrytitle>
-   <manvolnum>5</manvolnum>
- </refmeta>
- 
- <!-- Man page title -->
- <refnamediv>
-    <refname>sources.list</refname>
-    <refpurpose>Package resource list for APT</refpurpose>
- </refnamediv>
- 
- <refsect1><title>Description</title>
-   <para>The package resource list is used to locate archives of the package
-   distribution system in use on the system. At this time, this manual page
-   documents only the packaging system used by the Debian GNU/Linux system.
-   This control file is located in <filename>/etc/apt/sources.list</filename></para>
-
-   <para>The source list is designed to support any number of active sources and a
-   variety of source media. The file lists one source per line, with the
-   most preferred source listed first. The format of each line is:
-   <literal>type uri args</literal> The first item, <literal>type</literal>
-   determines the format for <literal>args</literal> <literal>uri</literal> is
-   a Universal Resource Identifier 
-   (URI), which is a superset of the more specific and well-known Universal
-   Resource Locator, or URL. The rest of the line can be marked as a comment 
-   by using a #.</para>
- </refsect1>
- 
- <refsect1><title>The deb and deb-src types</title>
-   <para>The <literal>deb</literal> type describes a typical two-level Debian
-   archive, <filename>distribution/component</filename>. Typically,
-   <literal>distribution</literal> is generally one of
-   <literal>stable</literal> <literal>unstable</literal> or 
-   <literal>testing</literal> while component is one of <literal>main</literal> 
-   <literal>contrib</literal> <literal>non-free</literal> or
-   <literal>non-us</literal> The 
-   <literal>deb-src</literal> type describes a debian distribution's source
-   code in the same form as the <literal>deb</literal> type.
-   A <literal>deb-src</literal> line is required to fetch source indexes.</para>
-
-
-   <para>The format for a <filename>sources.list</filename> entry using the
-   <literal>deb</literal> and <literal>deb-src</literal> types are:</para>
-
-   <literallayout>deb uri distribution [component1] [component2] [...]</literallayout>
-
-   <para>The URI for the <literal>deb</literal> type must specify the base of the
-   Debian distribution, from which APT will find the information it needs. 
-   <literal>distribution</literal> can specify an exact path, in which case the 
-   components must be omitted and <literal>distribution</literal> must end with
-   a slash (/). This is useful for when only a particular sub-section of the 
-   archive denoted by the URI is of interest.
-   If <literal>distribution</literal> does not specify an exact path, at least
-   one <literal>component</literal> must be present.</para>
-
-   <para><literal>distribution</literal> may also contain a variable, 
-   <literal>$(ARCH)</literal>
-   which expands to the Debian architecture (i386, m68k, powerpc, ...)
-   used on the system. This permits architecture-independent
-   <filename>sources.list</filename> files to be used. In general this is only
-   of interest when specifying an exact path, <literal>APT</literal> will
-   automatically generate a URI with the current architecture otherwise.</para>
-
-   <para>Since only one distribution can be specified per line it may be necessary
-   to have multiple lines for the same URI, if a subset of all available
-   distributions or components at that location is desired.
-   APT will sort the URI list after it has generated a complete set 
-   internally, and will collapse multiple references to the same Internet 
-   host, for instance, into a single connection, so that it does not 
-   inefficiently establish an FTP connection, close it, do something else, 
-   and then re-establish a connection to that same host. This feature is 
-   useful for accessing busy FTP sites with limits on the number of 
-   simultaneous anonymous users. APT also parallelizes connections to 
-   different hosts to more effectively deal with sites with low bandwidth.</para>
-
-   <para>It is important to list sources in order of preference, with the most
-   preferred source listed first. Typically this will result in sorting
-   by speed from fastest to slowest (CD-ROM followed by hosts on a local
-   network, followed by distant Internet hosts, for example).</para>
-
-   <para>Some examples:</para>
-   <literallayout>
-deb http://http.us.debian.org/debian stable main contrib non-free
-deb http://http.us.debian.org/debian dists/stable-updates/
-   </literallayout>
-
- </refsect1>
-
- <refsect1><title>URI specification</title>
-
-   <para>The currently recognized URI types are cdrom, file, http, and ftp.
-   <variablelist>
-    <varlistentry><term>file</term>
-    <listitem><para>
-    The file scheme allows an arbitrary directory in the file system to be
-    considered an archive. This is useful for NFS mounts and local mirrors or
-    archives.</para></listitem>
-    </varlistentry>
-    
-    <varlistentry><term>cdrom</term>
-    <listitem><para>
-    The cdrom scheme allows APT to use a local CDROM drive with media
-    swapping. Use the &apt-cdrom; program to create cdrom entries in the
-    source list.</para></listitem>
-    </varlistentry>
-
-    <varlistentry><term>http</term>
-    <listitem><para>
-    The http scheme specifies an HTTP server for the archive. If an environment
-    variable <envar>http_proxy</envar> is set with the format 
-    http://server:port/, the proxy server specified in
-    <envar>http_proxy</envar> will be used. Users of authenticated
-    HTTP/1.1 proxies may use a string of the format
-    http://user:pass@server:port/
-    Note that this is an insecure method of authentication.</para></listitem>
-    </varlistentry>
-
-    <varlistentry><term>ftp</term>
-    <listitem><para>
-    The ftp scheme specifies an FTP server for the archive. APT's FTP behavior
-    is highly configurable; for more information see the
-    &apt-conf; manual page. Please note that a ftp proxy can be specified
-    by using the <envar>ftp_proxy</envar> environment variable. It is possible
-    to specify a http proxy (http proxy servers often understand ftp urls)
-    using this method and ONLY this method. ftp proxies using http specified in
-    the configuration file will be ignored.</para></listitem>
-    </varlistentry>
-
-    <varlistentry><term>copy</term>
-    <listitem><para>
-    The copy scheme is identical to the file scheme except that packages are
-    copied into the cache directory instead of used directly at their location.
-    This is useful for people using a zip disk to copy files around with APT.</para></listitem>
-    </varlistentry>
-    
-    <varlistentry><term>rsh</term><term>ssh</term>
-    <listitem><para>
-    The rsh/ssh method invokes rsh/ssh to connect to a remote host
-    as a given user and access the files. No password authentication is 
-    possible, prior arrangements with RSA keys or rhosts must have been made.
-    Access to files on the remote uses standard <command>find</command> and
-    <command>dd</command> 
-    commands to perform the file transfers from the remote.</para></listitem>
-    </varlistentry>
-  </variablelist>
- </para>
- </refsect1>
- 
- <refsect1><title>Examples</title>
-   <para>Uses the archive stored locally (or NFS mounted) at /home/jason/debian
-   for stable/main, stable/contrib, and stable/non-free.</para>
-   <literallayout>deb file:/home/jason/debian stable main contrib non-free</literallayout>
-
-   <para>As above, except this uses the unstable (development) distribution.</para>
-   <literallayout>deb file:/home/jason/debian unstable main contrib non-free</literallayout>
-
-   <para>Source line for the above</para>
-   <literallayout>deb-src file:/home/jason/debian unstable main contrib non-free</literallayout>
-
-   <para>Uses HTTP to access the archive at archive.debian.org, and uses only
-   the hamm/main area.</para>
-   <literallayout>deb http://archive.debian.org/debian-archive hamm main</literallayout>
-
-   <para>Uses FTP to access the archive at ftp.debian.org, under the debian
-   directory, and uses only the stable/contrib area.</para>
-   <literallayout>deb ftp://ftp.debian.org/debian stable contrib</literallayout>
-
-   <para>Uses FTP to access the archive at ftp.debian.org, under the debian
-   directory, and uses only the unstable/contrib area. If this line appears as
-   well as the one in the previous example in <filename>sources.list</filename>.
-   a single FTP session will be used for both resource lines.</para>
-   <literallayout>deb ftp://ftp.debian.org/debian unstable contrib</literallayout>
-
-   <para>Uses HTTP to access the archive at nonus.debian.org, under the
-    debian-non-US directory.</para>
-   <literallayout>deb http://nonus.debian.org/debian-non-US stable/non-US main contrib non-free</literallayout>
-
-   <para>Uses HTTP to access the archive at nonus.debian.org, under the
-   debian-non-US directory, and uses only files found under
-   <filename>unstable/binary-i3866</filename> on i386 machines, 
-   <filename>unstable/binary-m68k</filename> on m68k, and so
-   forth for other supported architectures. [Note this example only 
-   illustrates how to use the substitution variable; non-us is no longer 
-   structured like this] 
-   <literallayout>deb http://ftp.de.debian.org/debian-non-US unstable/binary-$(ARCH)/</literallayout>
-   </para>
- </refsect1>
- 
- <refsect1><title>See Also</title>
-   <para>&apt-cache; &apt-conf;
-   </para>
- </refsect1>
-
- &manbugs;
- 
-</refentry>
-
diff -uNr apt-0.5.28.6/dselect/install apt-0.5.28.6-new/dselect/install
--- apt-0.5.28.6/dselect/install	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/dselect/install	Mon Apr 25 16:19:16 2005
@@ -6,8 +6,8 @@
 # Get the configuration from /etc/apt/apt.conf
 CLEAN="prompt"
 OPTS="-f"
-APTGET="/usr/bin/apt-get"
-DPKG="/usr/bin/dpkg"
+APTGET="@PREFIX@/bin/apt-get"
+DPKG="@PREFIX@/bin/dpkg"
 DPKG_OPTS="--admindir=$1"
 APT_OPT0="-oDir::State::status=$1/status"
 APT_OPT1="-oDPkg::Options::=$DPKG_OPTS"
diff -uNr apt-0.5.28.6/dselect/install.orig apt-0.5.28.6-new/dselect/install.orig
--- apt-0.5.28.6/dselect/install.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/dselect/install.orig	Mon Jan 10 16:50:08 2005
@@ -0,0 +1,109 @@
+#!/bin/bash
+
+# Set the textdomain for the translations using $"..."
+TEXTDOMAIN="apt"
+
+# Get the configuration from /etc/apt/apt.conf
+CLEAN="prompt"
+OPTS="-f"
+APTGET="/usr/bin/apt-get"
+DPKG="/usr/bin/dpkg"
+DPKG_OPTS="--admindir=$1"
+APT_OPT0="-oDir::State::status=$1/status"
+APT_OPT1="-oDPkg::Options::=$DPKG_OPTS"
+set -e
+RES=`apt-config shell CLEAN DSelect::Clean OPTS DSelect::Options \
+                      DPKG Dir::Bin::dpkg/f APTGET Dir::Bin::apt-get/f \
+		      ARCHIVES Dir::Cache::Archives/d \
+		      WAIT DSelect::WaitAfterDownload/b \
+		      CHECKDIR DSelect::CheckDir/b`
+eval $RES
+set +e
+
+# Yes/No Prompter
+yesno() {
+# $1 = prompt
+# $2 = default(y)
+	local ans def defp
+	if [ "$2" ];then
+		case $2 in
+			Y|y)	defp="[Y/n]" def=y;;
+			N|n)	defp="[y/N]" def=n;;
+			*)	echo $"Bad default setting!" 1>&2; exit 1;;
+		esac
+	else
+		defp="[y/N]" def=n
+	fi
+	while :;do
+		echo -n "$1 $defp " 1>&3
+		read ans
+		case $ans in
+			Y|y|N|n)	break;;
+			"")		ans=$def;break;;
+		esac
+		echo
+	done
+	echo $ans | tr YN yn
+}
+
+if [ x$WAIT = "xtrue" ]; then
+   $APTGET $OPTS "$APT_OPT0" "$APT_OPT1" -d dselect-upgrade
+   echo $"Press enter to continue." && read RES
+   $APTGET $OPTS "$APT_OPT0" "$APT_OPT1" dselect-upgrade
+   RES=$?
+else
+   $APTGET $OPTS "$APT_OPT0" "$APT_OPT1" dselect-upgrade
+   RES=$?
+fi
+
+# 1 means the user choose no at the prompt
+if [ $RES -eq 1 ]; then
+  exit 0
+fi
+
+# Finished OK
+if [ $RES -eq 0 ]; then
+
+   if [ `ls $ARCHIVES $ARCHIVES/partial | egrep -v "^lock$|^partial$" | wc -l` \
+        -eq 0 ]; then
+      exit 0
+   fi
+
+   NEWLS=`ls -ld $ARCHIVES`
+   if [ x$CHECKDIR = "xtrue" ]; then
+      if [ "x$OLDLS" = "x$NEWLS" ]; then
+         exit 0
+      fi
+   fi
+   
+   # Check the cleaning mode
+   case `echo $CLEAN | tr '[:upper:]' '[:lower:]'` in
+     auto)
+       $APTGET "$APT_OPT0" "$APT_OPT1" autoclean &&
+	   echo $"Press enter to continue." && read RES && exit 0;
+       ;;
+     always)
+       $APTGET "$APT_OPT0" "$APT_OPT1" clean &&
+	   echo $"Press enter to continue." && read RES && exit 0;
+       ;;
+     prompt)
+       exec 3>&1
+       if [ `yesno $"Do you want to erase any previously downloaded .deb files?" y` = y ]; then
+          $APTGET "$APT_OPT0" "$APT_OPT1" clean &&
+	    echo $"Press enter to continue." && read RES && exit 0;
+       fi
+       ;;
+     *) 
+       ;;
+   esac   
+else
+   echo $"Some errors occurred while unpacking. I'm going to configure the"
+   echo $"packages that were installed. This may result in duplicate errors"
+   echo $"or errors caused by missing dependencies. This is OK, only the errors"
+   echo $"above this message are important. Please fix them and run [I]nstall again"
+   echo $"Press enter to continue."
+   read RES && $DPKG "$DPKG_OPTS" --configure -a
+   exit 100
+fi
+
+exit $?
diff -uNr apt-0.5.28.6/dselect/setup apt-0.5.28.6-new/dselect/setup
--- apt-0.5.28.6/dselect/setup	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/dselect/setup	Mon Apr 25 16:46:05 2005
@@ -23,15 +23,15 @@
 my $vardir=$ARGV[0];
 my $method=$ARGV[1];
 my $option=$ARGV[2];
-my $config_file = '/etc/apt/sources.list';
+my $config_file = '@PREFIX@/etc/apt/sources.list';
 
-my $boldon=`setterm -bold on`;
-my $boldoff=`setterm -bold off`;
+my $boldon=`setterm -bold on 2>/dev/null`;
+my $boldoff=`setterm -bold off 2>/dev/null`;
 
 my @known_types           = ('deb');
 my @known_access         = ('http', 'ftp', 'file');
-my @typical_distributions = ('stable', 'unstable', 'testing', 'non-US');
-my @typical_components    = ('main', 'contrib', 'non-free');
+my @typical_distributions = ('@DIST@/release', '@DIST@/current');
+my @typical_components    = ('main', 'crypto');
 
 my %known_access           = map {($_,$_)} @known_access;
 my %typical_distributions  = map {($_,$_)} @typical_distributions;
@@ -118,9 +118,9 @@
   }
 
   $type         = 'deb';
-  $urn          = "http://http.us.debian.org/debian" unless $urn;
-  $distribution = "stable" unless $distribution;
-  $components   = "main contrib non-free" unless $components;
+  $urn          = "http://us.dl.sourceforge.net/fink/direct_download" unless $urn;
+  $distribution = "@DIST@/release" unless $distribution;
+  $components   = "main" unless $components;
 
     
   $rec->{'Type'} = 'deb';
@@ -222,19 +222,13 @@
   print "\t$boldon Set up a list of distribution source locations $boldoff \n";
   print "\n";
 
-  print " Please give the base URL of the debian distribution.\n";
+  print " Please give the base URL of the Fink distribution.\n";
   print " The access schemes I know about are:$boldon ";
   print join (' ', @known_access), "$boldoff\n";
-#  print " The mirror scheme is special  that it does not specify the\n";
-#  print " location of a debian archive but specifies the location\n";
-#  print " of a list of mirrors to use to access the archive.\n";
   print "\n";
   print " For example:\n";
-  print "              file:/mnt/debian,\n";
-  print "              ftp://ftp.debian.org/debian,\n";
-  print "              http://ftp.de.debian.org/debian,\n";
-#  print " and the special mirror scheme,\n";
-#  print "              mirror:http://www.debian.org/archivemirrors \n";
+  print "              file:@PREFIX@/fink,\n";
+  print "              http://us.dl.sourceforge.net/fink/direct_download\n";
   print "\n";
 
   my $index = 0;
@@ -269,7 +263,10 @@
     print "-" x 72, "\n";
     &print_config('Config' => \@Oldconfig);
     print "-" x 72, "\n";
-    print "$boldon Do you wish to overwrite it? [y/N]$boldoff ";
+    print "$boldon In most cases, this file was installed by Fink or by apt,"
+      ." and$boldoff\n";
+        print "$boldon should NOT be changed.  " .
+        "Do you wish to change (overwrite) it?[y/N]$boldoff ";
     my $answer = <STDIN>;
     chomp ($answer);
     $answer =~ s/\s+/ /og;
diff -uNr apt-0.5.28.6/dselect/update apt-0.5.28.6-new/dselect/update
--- apt-0.5.28.6/dselect/update	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/dselect/update	Mon Apr 25 16:19:16 2005
@@ -7,13 +7,13 @@
 # Get the configuration from /etc/apt/apt.conf
 CLEAN="prompt"
 OPTS="-f"
-APTGET="/usr/bin/apt-get"
-APTCACHE="/usr/bin/apt-cache"
-DPKG="/usr/bin/dpkg"
+APTGET="@PREFIX@/bin/apt-get"
+APTCACHE="@PREFIX@/bin/apt-cache"
+DPKG="@PREFIX@/bin/dpkg"
 DPKG_OPTS="--admindir=$1"
 APT_OPT0="-oDir::State::status=$1/status"
 APT_OPT1="-oDPkg::Options::=$DPKG_OPTS"
-CACHEDIR="/var/cache/apt"
+CACHEDIR="@PREFIX@/var/cache/apt"
 PROMPT="false"
 RES=`apt-config shell CLEAN DSelect::Clean OPTS DSelect::UpdateOptions \
 		      DPKG Dir::Bin::dpkg/f APTGET Dir::Bin::apt-get/f \
diff -uNr apt-0.5.28.6/dselect/update.orig apt-0.5.28.6-new/dselect/update.orig
--- apt-0.5.28.6/dselect/update.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/dselect/update.orig	Mon Jan 10 16:50:08 2005
@@ -0,0 +1,48 @@
+#!/bin/bash
+set -e
+
+# Set the textdomain for the translations using $"..."
+TEXTDOMAIN="apt"
+
+# Get the configuration from /etc/apt/apt.conf
+CLEAN="prompt"
+OPTS="-f"
+APTGET="/usr/bin/apt-get"
+APTCACHE="/usr/bin/apt-cache"
+DPKG="/usr/bin/dpkg"
+DPKG_OPTS="--admindir=$1"
+APT_OPT0="-oDir::State::status=$1/status"
+APT_OPT1="-oDPkg::Options::=$DPKG_OPTS"
+CACHEDIR="/var/cache/apt"
+PROMPT="false"
+RES=`apt-config shell CLEAN DSelect::Clean OPTS DSelect::UpdateOptions \
+		      DPKG Dir::Bin::dpkg/f APTGET Dir::Bin::apt-get/f \
+		      APTCACHE Dir::Bin::apt-cache/f CACHEDIR Dir::Cache/d \
+		      PROMPT DSelect::PromptAfterUpdate/b`
+eval $RES
+
+# It looks slightly ugly to have a double / in the dpkg output
+CACHEDIR=`echo $CACHEDIR | sed -e "s|/$||"`
+
+STATUS=1
+if $APTGET $OPTS "$APT_OPT0" "$APT_OPT1" update
+then
+    echo $"Merging Available information"
+    rm -f $CACHEDIR/available
+    $APTCACHE dumpavail > $CACHEDIR/available
+    $DPKG "$DPKG_OPTS" --update-avail $CACHEDIR/available
+    rm -f $CACHEDIR/available
+
+    case "$CLEAN" in
+	Pre-Auto|PreAuto|pre-auto)
+	    $APTGET "$APT_OPT0" "$APT_OPT1" autoclean;;
+    esac
+
+    STATUS=0
+fi
+
+if [ x$PROMPT = "xtrue" ]; then
+   echo $"Press enter to continue." && read RES;
+fi
+
+exit $STATUS
diff -uNr apt-0.5.28.6/methods/connect.cc apt-0.5.28.6-new/methods/connect.cc
--- apt-0.5.28.6/methods/connect.cc	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/methods/connect.cc	Mon Apr 25 16:19:16 2005
@@ -94,7 +94,7 @@
 
    // Check the socket for an error condition
    unsigned int Err;
-   unsigned int Len = sizeof(Err);
+   int Len = sizeof(Err);
    if (getsockopt(Fd,SOL_SOCKET,SO_ERROR,&Err,&Len) != 0)
       return _error->Errno("getsockopt",_("Failed"));
    
diff -uNr apt-0.5.28.6/methods/connect.cc.orig apt-0.5.28.6-new/methods/connect.cc.orig
--- apt-0.5.28.6/methods/connect.cc.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/methods/connect.cc.orig	Mon Jan 10 16:50:08 2005
@@ -0,0 +1,218 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+
+   Connect - Replacement connect call
+
+   This was originally authored by Jason Gunthorpe <jgg@debian.org>
+   and is placed in the Public Domain, do with it what you will.
+      
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#include "connect.h"
+#include <apt-pkg/error.h>
+#include <apt-pkg/fileutl.h>
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+
+// Internet stuff
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include "rfc2553emu.h"
+#include <apti18n.h>
+									/*}}}*/
+
+static string LastHost;
+static int LastPort = 0;
+static struct addrinfo *LastHostAddr = 0;
+static struct addrinfo *LastUsed = 0;
+
+// RotateDNS - Select a new server from a DNS rotation			/*{{{*/
+// ---------------------------------------------------------------------
+/* This is called during certain errors in order to recover by selecting a 
+   new server */
+void RotateDNS()
+{
+   if (LastUsed != 0 && LastUsed->ai_next != 0)
+      LastUsed = LastUsed->ai_next;
+   else
+      LastUsed = LastHostAddr;
+}
+									/*}}}*/
+// DoConnect - Attempt a connect operation				/*{{{*/
+// ---------------------------------------------------------------------
+/* This helper function attempts a connection to a single address. */
+static bool DoConnect(struct addrinfo *Addr,string Host,
+		      unsigned long TimeOut,int &Fd,pkgAcqMethod *Owner)
+{
+   // Show a status indicator
+   char Name[NI_MAXHOST];
+   char Service[NI_MAXSERV];
+   
+   Name[0] = 0;   
+   Service[0] = 0;
+   getnameinfo(Addr->ai_addr,Addr->ai_addrlen,
+	       Name,sizeof(Name),Service,sizeof(Service),
+	       NI_NUMERICHOST|NI_NUMERICSERV);
+   Owner->Status(_("Connecting to %s (%s)"),Host.c_str(),Name);
+
+   /* If this is an IP rotation store the IP we are using.. If something goes
+      wrong this will get tacked onto the end of the error message */
+   if (LastHostAddr->ai_next != 0)
+   {
+      char Name2[NI_MAXHOST + NI_MAXSERV + 10];
+      snprintf(Name2,sizeof(Name2),_("[IP: %s %s]"),Name,Service);
+      Owner->SetFailExtraMsg(string(Name2));
+   }   
+   else
+      Owner->SetFailExtraMsg("");
+      
+   // Get a socket
+   if ((Fd = socket(Addr->ai_family,Addr->ai_socktype,
+		    Addr->ai_protocol)) < 0)
+      return _error->Errno("socket",_("Could not create a socket for %s (f=%u t=%u p=%u)"),
+			   Name,Addr->ai_family,Addr->ai_socktype,Addr->ai_protocol);
+   
+   SetNonBlock(Fd,true);
+   if (connect(Fd,Addr->ai_addr,Addr->ai_addrlen) < 0 &&
+       errno != EINPROGRESS)
+      return _error->Errno("connect",_("Cannot initiate the connection "
+			   "to %s:%s (%s)."),Host.c_str(),Service,Name);
+   
+   /* This implements a timeout for connect by opening the connection
+      nonblocking */
+   if (WaitFd(Fd,true,TimeOut) == false)
+      return _error->Error(_("Could not connect to %s:%s (%s), "
+			   "connection timed out"),Host.c_str(),Service,Name);
+
+   // Check the socket for an error condition
+   unsigned int Err;
+   unsigned int Len = sizeof(Err);
+   if (getsockopt(Fd,SOL_SOCKET,SO_ERROR,&Err,&Len) != 0)
+      return _error->Errno("getsockopt",_("Failed"));
+   
+   if (Err != 0)
+   {
+      errno = Err;
+      return _error->Errno("connect",_("Could not connect to %s:%s (%s)."),Host.c_str(),
+			   Service,Name);
+   }
+   
+   return true;
+}
+									/*}}}*/
+// Connect - Connect to a server					/*{{{*/
+// ---------------------------------------------------------------------
+/* Performs a connection to the server */
+bool Connect(string Host,int Port,const char *Service,int DefPort,int &Fd,
+	     unsigned long TimeOut,pkgAcqMethod *Owner)
+{
+   if (_error->PendingError() == true)
+      return false;
+
+   // Convert the port name/number
+   char ServStr[300];
+   if (Port != 0)
+      snprintf(ServStr,sizeof(ServStr),"%u",Port);
+   else
+      snprintf(ServStr,sizeof(ServStr),"%s",Service);
+   
+   /* We used a cached address record.. Yes this is against the spec but
+      the way we have setup our rotating dns suggests that this is more
+      sensible */
+   if (LastHost != Host || LastPort != Port)
+   {
+      Owner->Status(_("Connecting to %s"),Host.c_str());
+
+      // Free the old address structure
+      if (LastHostAddr != 0)
+      {
+	 freeaddrinfo(LastHostAddr);
+	 LastHostAddr = 0;
+	 LastUsed = 0;
+      }
+      
+      // We only understand SOCK_STREAM sockets.
+      struct addrinfo Hints;
+      memset(&Hints,0,sizeof(Hints));
+      Hints.ai_socktype = SOCK_STREAM;
+      Hints.ai_protocol = 0;
+      
+      // Resolve both the host and service simultaneously
+      while (1)
+      {
+	 int Res;
+	 if ((Res = getaddrinfo(Host.c_str(),ServStr,&Hints,&LastHostAddr)) != 0 ||
+	     LastHostAddr == 0)
+	 {
+	    if (Res == EAI_NONAME || Res == EAI_SERVICE)
+	    {
+	       if (DefPort != 0)
+	       {
+		  snprintf(ServStr,sizeof(ServStr),"%u",DefPort);
+		  DefPort = 0;
+		  continue;
+	       }
+	       return _error->Error(_("Could not resolve '%s'"),Host.c_str());
+	    }
+	    
+	    if (Res == EAI_AGAIN)
+	       return _error->Error(_("Temporary failure resolving '%s'"),
+				    Host.c_str());
+	    return _error->Error(_("Something wicked happened resolving '%s:%s' (%i)"),
+				 Host.c_str(),ServStr,Res);
+	 }
+	 break;
+      }
+      
+      LastHost = Host;
+      LastPort = Port;
+   }
+
+   // When we have an IP rotation stay with the last IP.
+   struct addrinfo *CurHost = LastHostAddr;
+   if (LastUsed != 0)
+       CurHost = LastUsed;
+   
+   while (CurHost != 0)
+   {
+      if (DoConnect(CurHost,Host,TimeOut,Fd,Owner) == true)
+      {
+	 LastUsed = CurHost;
+	 return true;
+      }      
+      close(Fd);
+      Fd = -1;
+      
+      // Ignore UNIX domain sockets
+      do
+      {
+	 CurHost = CurHost->ai_next;
+      }
+      while (CurHost != 0 && CurHost->ai_family == AF_UNIX);
+
+      /* If we reached the end of the search list then wrap around to the
+         start */
+      if (CurHost == 0 && LastUsed != 0)
+	 CurHost = LastHostAddr;
+      
+      // Reached the end of the search cycle
+      if (CurHost == LastUsed)
+	 break;
+      
+      if (CurHost != 0)
+	 _error->Discard();
+   }   
+
+   if (_error->PendingError() == true)
+      return false;   
+   return _error->Error(_("Unable to connect to %s %s:"),Host.c_str(),ServStr);
+}
+									/*}}}*/
diff -uNr apt-0.5.28.6/methods/ftp.cc apt-0.5.28.6-new/methods/ftp.cc
--- apt-0.5.28.6/methods/ftp.cc	Mon Jan 10 16:59:09 2005
+++ apt-0.5.28.6-new/methods/ftp.cc	Mon Apr 25 16:19:16 2005
@@ -697,7 +697,7 @@
       if (WaitFd(DataFd,true,TimeOut) == false)
 	 return _error->Error(_("Could not connect data socket, connection timed out"));
       unsigned int Err;
-      unsigned int Len = sizeof(Err);
+      int Len = sizeof(Err);
       if (getsockopt(DataFd,SOL_SOCKET,SO_ERROR,&Err,&Len) != 0)
 	 return _error->Errno("getsockopt",_("Failed"));
       if (Err != 0)
diff -uNr apt-0.5.28.6/methods/ftp.cc.orig apt-0.5.28.6-new/methods/ftp.cc.orig
--- apt-0.5.28.6/methods/ftp.cc.orig	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/methods/ftp.cc.orig	Mon Jan 10 16:59:09 2005
@@ -0,0 +1,1114 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+// $Id$
+/* ######################################################################
+
+   FTP Aquire Method - This is the FTP aquire method for APT.
+
+   This is a very simple implementation that does not try to optimize
+   at all. Commands are sent syncronously with the FTP server (as the
+   rfc recommends, but it is not really necessary..) and no tricks are
+   done to speed things along.
+			
+   RFC 2428 describes the IPv6 FTP behavior
+   
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#include <apt-pkg/fileutl.h>
+#include <apt-pkg/acquire-method.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/hashes.h>
+
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <utime.h>
+#include <unistd.h>
+#include <signal.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <iostream>
+#include <apti18n.h>
+
+// Internet stuff
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include "rfc2553emu.h"
+#include "connect.h"
+#include "ftp.h"
+									/*}}}*/
+
+using namespace std;
+
+/* This table is for the EPRT and EPSV commands, it maps the OS address
+   family to the IETF address families */
+struct AFMap
+{
+   unsigned long Family;
+   unsigned long IETFFamily;
+};
+
+#ifndef AF_INET6
+struct AFMap AFMap[] = {{AF_INET,1},{}};
+#else
+struct AFMap AFMap[] = {{AF_INET,1},{AF_INET6,2},{}};
+#endif
+
+unsigned long TimeOut = 120;
+URI Proxy;
+string FtpMethod::FailFile;
+int FtpMethod::FailFd = -1;
+time_t FtpMethod::FailTime = 0;
+
+// FTPConn::FTPConn - Constructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+FTPConn::FTPConn(URI Srv) : Len(0), ServerFd(-1), DataFd(-1), 
+                            DataListenFd(-1), ServerName(Srv)
+{
+   Debug = _config->FindB("Debug::Acquire::Ftp",false);
+   PasvAddr = 0;
+}
+									/*}}}*/
+// FTPConn::~FTPConn - Destructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+FTPConn::~FTPConn()
+{
+   Close();
+}
+									/*}}}*/
+// FTPConn::Close - Close down the connection				/*{{{*/
+// ---------------------------------------------------------------------
+/* Just tear down the socket and data socket */
+void FTPConn::Close()
+{
+   close(ServerFd);
+   ServerFd = -1;
+   close(DataFd);
+   DataFd = -1;
+   close(DataListenFd);
+   DataListenFd = -1;
+   
+   if (PasvAddr != 0)
+      freeaddrinfo(PasvAddr);
+   PasvAddr = 0;
+}
+									/*}}}*/
+// FTPConn::Open - Open a new connection				/*{{{*/
+// ---------------------------------------------------------------------
+/* Connect to the server using a non-blocking connection and perform a 
+   login. */
+bool FTPConn::Open(pkgAcqMethod *Owner)
+{
+   // Use the already open connection if possible.
+   if (ServerFd != -1)
+      return true;
+   
+   Close();
+   
+   // Determine the proxy setting
+   if (getenv("ftp_proxy") == 0)
+   {
+      string DefProxy = _config->Find("Acquire::ftp::Proxy");
+      string SpecificProxy = _config->Find("Acquire::ftp::Proxy::" + ServerName.Host);
+      if (SpecificProxy.empty() == false)
+      {
+	 if (SpecificProxy == "DIRECT")
+	    Proxy = "";
+	 else
+	    Proxy = SpecificProxy;
+      }   
+      else
+	 Proxy = DefProxy;
+   }
+   else
+      Proxy = getenv("ftp_proxy");
+   
+   // Parse no_proxy, a , separated list of domains
+   if (getenv("no_proxy") != 0)
+   {
+      if (CheckDomainList(ServerName.Host,getenv("no_proxy")) == true)
+	 Proxy = "";
+   }
+   
+   // Determine what host and port to use based on the proxy settings
+   int Port = 0;
+   string Host;   
+   if (Proxy.empty() == true)
+   {
+      if (ServerName.Port != 0)
+	 Port = ServerName.Port;
+      Host = ServerName.Host;
+   }
+   else
+   {
+      if (Proxy.Port != 0)
+	 Port = Proxy.Port;
+      Host = Proxy.Host;
+   }
+
+   /* Connect to the remote server. Since FTP is connection oriented we
+      want to make sure we get a new server every time we reconnect */
+   RotateDNS();
+   if (Connect(Host,Port,"ftp",21,ServerFd,TimeOut,Owner) == false)
+      return false;
+
+   // Login must be before getpeername otherwise dante won't work.
+   Owner->Status(_("Logging in"));
+   bool Res = Login();
+   
+   // Get the remote server's address
+   PeerAddrLen = sizeof(PeerAddr);
+   if (getpeername(ServerFd,(sockaddr *)&PeerAddr,&PeerAddrLen) != 0)
+      return _error->Errno("getpeername",_("Unable to determine the peer name"));
+   
+   // Get the local machine's address
+   ServerAddrLen = sizeof(ServerAddr);
+   if (getsockname(ServerFd,(sockaddr *)&ServerAddr,&ServerAddrLen) != 0)
+      return _error->Errno("getsockname",_("Unable to determine the local name"));
+   
+   return Res;
+}
+									/*}}}*/
+// FTPConn::Login - Login to the remote server				/*{{{*/
+// ---------------------------------------------------------------------
+/* This performs both normal login and proxy login using a simples script
+   stored in the config file. */
+bool FTPConn::Login()
+{
+   unsigned int Tag;
+   string Msg;
+   
+   // Setup the variables needed for authentication
+   string User = "anonymous";
+   string Pass = "apt_get_ftp_2.1@debian.linux.user";
+
+   // Fill in the user/pass
+   if (ServerName.User.empty() == false)
+      User = ServerName.User;
+   if (ServerName.Password.empty() == false)
+      Pass = ServerName.Password;
+       
+   // Perform simple login
+   if (Proxy.empty() == true)
+   {
+      // Read the initial response
+      if (ReadResp(Tag,Msg) == false)
+	 return false;
+      if (Tag >= 400)
+	 return _error->Error(_("Server refused our connection and said: %s"),Msg.c_str());
+      
+      // Send the user
+      if (WriteMsg(Tag,Msg,"USER %s",User.c_str()) == false)
+	 return false;
+      if (Tag >= 400)
+	 return _error->Error(_("USER failed, server said: %s"),Msg.c_str());
+      
+      if (Tag == 331) { // 331 User name okay, need password.
+         // Send the Password
+         if (WriteMsg(Tag,Msg,"PASS %s",Pass.c_str()) == false)
+            return false;
+         if (Tag >= 400)
+            return _error->Error(_("PASS failed, server said: %s"),Msg.c_str());
+      }
+      
+      // Enter passive mode
+      if (_config->Exists("Acquire::FTP::Passive::" + ServerName.Host) == true)
+	 TryPassive = _config->FindB("Acquire::FTP::Passive::" + ServerName.Host,true);
+      else
+	 TryPassive = _config->FindB("Acquire::FTP::Passive",true);      
+   }
+   else
+   {      
+      // Read the initial response
+      if (ReadResp(Tag,Msg) == false)
+	 return false;
+      if (Tag >= 400)
+	 return _error->Error(_("Server refused our connection and said: %s"),Msg.c_str());
+      
+      // Perform proxy script execution
+      Configuration::Item const *Opts = _config->Tree("Acquire::ftp::ProxyLogin");
+      if (Opts == 0 || Opts->Child == 0)
+	 return _error->Error(_("A proxy server was specified but no login "
+			      "script, Acquire::ftp::ProxyLogin is empty."));
+      Opts = Opts->Child;
+
+      // Iterate over the entire login script
+      for (; Opts != 0; Opts = Opts->Next)
+      {
+	 if (Opts->Value.empty() == true)
+	    continue;
+	 
+	 // Substitute the variables into the command
+	 char SitePort[20];
+	 if (ServerName.Port != 0)
+	    sprintf(SitePort,"%u",ServerName.Port);
+	 else
+	    strcpy(SitePort,"21");
+	 string Tmp = Opts->Value;
+	 Tmp = SubstVar(Tmp,"$(PROXY_USER)",Proxy.User);
+	 Tmp = SubstVar(Tmp,"$(PROXY_PASS)",Proxy.Password);
+	 Tmp = SubstVar(Tmp,"$(SITE_USER)",User);
+	 Tmp = SubstVar(Tmp,"$(SITE_PASS)",Pass);
+	 Tmp = SubstVar(Tmp,"$(SITE_PORT)",SitePort);
+	 Tmp = SubstVar(Tmp,"$(SITE)",ServerName.Host);
+
+	 // Send the command
+	 if (WriteMsg(Tag,Msg,"%s",Tmp.c_str()) == false)
+	    return false;
+	 if (Tag >= 400)
+	    return _error->Error(_("Login script command '%s' failed, server said: %s"),Tmp.c_str(),Msg.c_str());	 
+      }
+      
+      // Enter passive mode
+      TryPassive = false;
+      if (_config->Exists("Acquire::FTP::Passive::" + ServerName.Host) == true)
+	 TryPassive = _config->FindB("Acquire::FTP::Passive::" + ServerName.Host,true);
+      else
+      {
+	 if (_config->Exists("Acquire::FTP::Proxy::Passive") == true)
+	    TryPassive = _config->FindB("Acquire::FTP::Proxy::Passive",true);
+	 else
+	    TryPassive = _config->FindB("Acquire::FTP::Passive",true);
+      }            
+   }
+
+   // Force the use of extended commands
+   if (_config->Exists("Acquire::FTP::ForceExtended::" + ServerName.Host) == true)
+      ForceExtended = _config->FindB("Acquire::FTP::ForceExtended::" + ServerName.Host,true);
+   else
+      ForceExtended = _config->FindB("Acquire::FTP::ForceExtended",false);
+   
+   // Binary mode
+   if (WriteMsg(Tag,Msg,"TYPE I") == false)
+      return false;
+   if (Tag >= 400)
+      return _error->Error(_("TYPE failed, server said: %s"),Msg.c_str());
+   
+   return true;
+}
+									/*}}}*/
+// FTPConn::ReadLine - Read a line from the server			/*{{{*/
+// ---------------------------------------------------------------------
+/* This performs a very simple buffered read. */
+bool FTPConn::ReadLine(string &Text)
+{
+   if (ServerFd == -1)
+      return false;
+   
+   // Suck in a line
+   while (Len < sizeof(Buffer))
+   {
+      // Scan the buffer for a new line
+      for (unsigned int I = 0; I != Len; I++)
+      {
+	 // Escape some special chars
+	 if (Buffer[I] == 0)
+	    Buffer[I] = '?';
+	 
+	 // End of line?
+	 if (Buffer[I] != '\n')
+	    continue;
+	 
+	 I++;
+	 Text = string(Buffer,I);
+	 memmove(Buffer,Buffer+I,Len - I);
+	 Len -= I;	 
+	 return true;
+      }
+
+      // Wait for some data..
+      if (WaitFd(ServerFd,false,TimeOut) == false)
+      {
+	 Close();
+	 return _error->Error(_("Connection timeout"));
+      }
+      
+      // Suck it back
+      int Res = read(ServerFd,Buffer + Len,sizeof(Buffer) - Len);
+      if (Res == 0)
+	 _error->Error(_("Server closed the connection"));
+      if (Res <= 0)
+      {
+	 _error->Errno("read",_("Read error"));
+	 Close();
+	 return false;
+      }      
+      Len += Res;
+   }
+
+   return _error->Error(_("A response overflowed the buffer."));
+}
+									/*}}}*/
+// FTPConn::ReadResp - Read a full response from the server		/*{{{*/
+// ---------------------------------------------------------------------
+/* This reads a reply code from the server, it handles both p */
+bool FTPConn::ReadResp(unsigned int &Ret,string &Text)
+{
+   // Grab the first line of the response
+   string Msg;
+   if (ReadLine(Msg) == false)
+       return false;
+   
+   // Get the ID code
+   char *End;   
+   Ret = strtol(Msg.c_str(),&End,10);
+   if (End - Msg.c_str() != 3)
+      return _error->Error(_("Protocol corruption"));
+
+   // All done ?
+   Text = Msg.c_str()+4;
+   if (*End == ' ')
+   {
+      if (Debug == true)
+	 cerr << "<- '" << QuoteString(Text,"") << "'" << endl;
+      return true;
+   }
+   
+   if (*End != '-')
+      return _error->Error(_("Protocol corruption"));
+   
+   /* Okay, here we do the continued message trick. This is foolish, but
+      proftpd follows the protocol as specified and wu-ftpd doesn't, so 
+      we filter. I wonder how many clients break if you use proftpd and
+      put a '- in the 3rd spot in the message? */
+   char Leader[4];
+   strncpy(Leader,Msg.c_str(),3);
+   Leader[3] = 0;
+   while (ReadLine(Msg) == true)
+   {
+      // Short, it must be using RFC continuation..
+      if (Msg.length() < 4)
+      {
+	 Text += Msg;
+	 continue;
+      }
+      
+      // Oops, finished
+      if (strncmp(Msg.c_str(),Leader,3) == 0 && Msg[3] == ' ')
+      {
+	 Text += Msg.c_str()+4;
+	 break;
+      }
+      
+      // This message has the wu-ftpd style reply code prefixed
+      if (strncmp(Msg.c_str(),Leader,3) == 0 && Msg[3] == '-')
+      {
+	 Text += Msg.c_str()+4;
+	 continue;
+      }
+      
+      // Must be RFC style prefixing
+      Text += Msg;
+   }	   
+
+   if (Debug == true && _error->PendingError() == false)
+      cerr << "<- '" << QuoteString(Text,"") << "'" << endl;
+      
+   return !_error->PendingError();
+}
+									/*}}}*/
+// FTPConn::WriteMsg - Send a message to the server			/*{{{*/
+// ---------------------------------------------------------------------
+/* Simple printf like function.. */
+bool FTPConn::WriteMsg(unsigned int &Ret,string &Text,const char *Fmt,...)
+{
+   va_list args;
+   va_start(args,Fmt);
+
+   // sprintf the description
+   char S[400];
+   vsnprintf(S,sizeof(S) - 4,Fmt,args);
+   strcat(S,"\r\n");
+ 
+   if (Debug == true)
+      cerr << "-> '" << QuoteString(S,"") << "'" << endl;
+
+   // Send it off
+   unsigned long Len = strlen(S);
+   unsigned long Start = 0;
+   while (Len != 0)
+   {
+      if (WaitFd(ServerFd,true,TimeOut) == false)
+      {
+	 Close();
+	 return _error->Error(_("Connection timeout"));
+      }
+      
+      int Res = write(ServerFd,S + Start,Len);
+      if (Res <= 0)
+      {
+	 _error->Errno("write",_("Write Error"));
+	 Close();
+	 return false;
+      }
+      
+      Len -= Res;
+      Start += Res;
+   }
+   
+   return ReadResp(Ret,Text);
+}
+									/*}}}*/
+// FTPConn::GoPasv - Enter Passive mode					/*{{{*/
+// ---------------------------------------------------------------------
+/* Try to enter passive mode, the return code does not indicate if passive
+   mode could or could not be established, only if there was a fatal error. 
+   We have to enter passive mode every time we make a data connection :| */
+bool FTPConn::GoPasv()
+{
+   /* The PASV command only works on IPv4 sockets, even though it could
+      in theory suppory IPv6 via an all zeros reply */
+   if (((struct sockaddr *)&PeerAddr)->sa_family != AF_INET || 
+       ForceExtended == true)
+      return ExtGoPasv();
+   
+   if (PasvAddr != 0)
+      freeaddrinfo(PasvAddr);
+   PasvAddr = 0;
+   
+   // Try to enable pasv mode
+   unsigned int Tag;
+   string Msg;
+   if (WriteMsg(Tag,Msg,"PASV") == false)
+      return false;
+   
+   // Unsupported function
+   string::size_type Pos = Msg.find('(');
+   if (Tag >= 400 || Pos == string::npos)
+      return true;
+
+   // Scan it
+   unsigned a0,a1,a2,a3,p0,p1;
+   if (sscanf(Msg.c_str() + Pos,"(%u,%u,%u,%u,%u,%u)",&a0,&a1,&a2,&a3,&p0,&p1) != 6)
+      return true;
+   
+   /* Some evil servers return 0 to mean their addr. We can actually speak
+      to these servers natively using IPv6 */
+   if (a0 == 0 && a1 == 0 && a2 == 0 && a3 == 0)
+   {
+      // Get the IP in text form
+      char Name[NI_MAXHOST];
+      char Service[NI_MAXSERV];
+      getnameinfo((struct sockaddr *)&PeerAddr,PeerAddrLen,
+		  Name,sizeof(Name),Service,sizeof(Service),
+		  NI_NUMERICHOST|NI_NUMERICSERV);
+      
+      struct addrinfo Hints;
+      memset(&Hints,0,sizeof(Hints));
+      Hints.ai_socktype = SOCK_STREAM;
+      Hints.ai_family = ((struct sockaddr *)&PeerAddr)->sa_family;
+      Hints.ai_flags |= AI_NUMERICHOST;
+      
+      // Get a new passive address.
+      char Port[100];
+      snprintf(Port,sizeof(Port),"%u",(p0 << 8) + p1);
+      if (getaddrinfo(Name,Port,&Hints,&PasvAddr) != 0)
+	 return true;
+      return true;
+   }
+   
+   struct addrinfo Hints;
+   memset(&Hints,0,sizeof(Hints));
+   Hints.ai_socktype = SOCK_STREAM;
+   Hints.ai_family = AF_INET;
+   Hints.ai_flags |= AI_NUMERICHOST;
+   
+   // Get a new passive address.
+   char Port[100];
+   snprintf(Port,sizeof(Port),"%u",(p0 << 8) + p1);
+   char Name[100];
+   snprintf(Name,sizeof(Name),"%u.%u.%u.%u",a0,a1,a2,a3);
+   if (getaddrinfo(Name,Port,&Hints,&PasvAddr) != 0)
+      return true;
+   return true;
+}
+									/*}}}*/
+// FTPConn::ExtGoPasv - Enter Extended Passive mode			/*{{{*/
+// ---------------------------------------------------------------------
+/* Try to enter extended passive mode. See GoPasv above and RFC 2428 */
+bool FTPConn::ExtGoPasv()
+{
+   if (PasvAddr != 0)
+      freeaddrinfo(PasvAddr);
+   PasvAddr = 0;
+   
+   // Try to enable pasv mode
+   unsigned int Tag;
+   string Msg;
+   if (WriteMsg(Tag,Msg,"EPSV") == false)
+      return false;
+   
+   // Unsupported function
+   string::size_type Pos = Msg.find('(');
+   if (Tag >= 400 || Pos == string::npos)
+      return true;
+
+   // Scan it   
+   string::const_iterator List[4];
+   unsigned Count = 0;
+   Pos++;
+   for (string::const_iterator I = Msg.begin() + Pos; I < Msg.end(); I++)
+   {
+      if (*I != Msg[Pos])
+	 continue;
+      if (Count >= 4)
+	 return true;
+      List[Count++] = I;
+   }
+   if (Count != 4)
+      return true;
+   
+   // Break it up ..
+   unsigned long Proto = 0;
+   unsigned long Port = 0;
+   string IP;
+   IP = string(List[1]+1,List[2]);
+   Port = atoi(string(List[2]+1,List[3]).c_str());
+   if (IP.empty() == false)
+      Proto = atoi(string(List[0]+1,List[1]).c_str());
+   
+   if (Port == 0)
+      return false;
+
+   // String version of the port
+   char PStr[100];
+   snprintf(PStr,sizeof(PStr),"%lu",Port);
+
+   // Get the IP in text form
+   struct addrinfo Hints;
+   memset(&Hints,0,sizeof(Hints));
+   Hints.ai_socktype = SOCK_STREAM;
+   Hints.ai_flags |= AI_NUMERICHOST;
+   
+   /* The RFC defined case, connect to the old IP/protocol using the
+      new port. */
+   if (IP.empty() == true)
+   {
+      // Get the IP in text form
+      char Name[NI_MAXHOST];
+      char Service[NI_MAXSERV];
+      getnameinfo((struct sockaddr *)&PeerAddr,PeerAddrLen,
+		  Name,sizeof(Name),Service,sizeof(Service),
+		  NI_NUMERICHOST|NI_NUMERICSERV);
+      IP = Name;
+      Hints.ai_family = ((struct sockaddr *)&PeerAddr)->sa_family;
+   }
+   else
+   {
+      // Get the family..
+      Hints.ai_family = 0;
+      for (unsigned J = 0; AFMap[J].Family != 0; J++)
+	 if (AFMap[J].IETFFamily == Proto)
+	    Hints.ai_family = AFMap[J].Family;
+      if (Hints.ai_family == 0)
+	 return true;
+   }
+   
+   // Get a new passive address.
+   int Res;
+   if ((Res = getaddrinfo(IP.c_str(),PStr,&Hints,&PasvAddr)) != 0)
+      return true;
+   
+   return true;
+}
+									/*}}}*/
+// FTPConn::Size - Return the size of a file				/*{{{*/
+// ---------------------------------------------------------------------
+/* Grab the file size from the server, 0 means no size or empty file */
+bool FTPConn::Size(const char *Path,unsigned long &Size)
+{
+   // Query the size
+   unsigned int Tag;
+   string Msg;
+   Size = 0;
+   if (WriteMsg(Tag,Msg,"SIZE %s",Path) == false)
+      return false;
+   
+   char *End;
+   Size = strtol(Msg.c_str(),&End,10);
+   if (Tag >= 400 || End == Msg.c_str())
+      Size = 0;
+   return true;
+}
+									/*}}}*/
+// FTPConn::ModTime - Return the modification time of the file		/*{{{*/
+// ---------------------------------------------------------------------
+/* Like Size no error is returned if the command is not supported. If the
+   command fails then time is set to the current time of day to fool 
+   date checks. */
+bool FTPConn::ModTime(const char *Path, time_t &Time)
+{
+   Time = time(&Time);
+   
+   // Query the mod time
+   unsigned int Tag;
+   string Msg;
+   if (WriteMsg(Tag,Msg,"MDTM %s",Path) == false)
+      return false;
+   if (Tag >= 400 || Msg.empty() == true || isdigit(Msg[0]) == 0)
+      return true;
+   
+   // Parse it
+   StrToTime(Msg,Time);
+   return true;
+}
+									/*}}}*/
+// FTPConn::CreateDataFd - Get a data connection			/*{{{*/
+// ---------------------------------------------------------------------
+/* Create the data connection. Call FinalizeDataFd after this though.. */
+bool FTPConn::CreateDataFd()
+{
+   close(DataFd);
+   DataFd = -1;
+   
+   // Attempt to enter passive mode.
+   if (TryPassive == true)
+   {
+      if (GoPasv() == false)
+	 return false;
+      
+      // Oops, didn't work out, don't bother trying again.
+      if (PasvAddr == 0)
+	 TryPassive = false;
+   }
+   
+   // Passive mode?
+   if (PasvAddr != 0)
+   {
+      // Get a socket
+      if ((DataFd = socket(PasvAddr->ai_family,PasvAddr->ai_socktype,
+			   PasvAddr->ai_protocol)) < 0)
+	 return _error->Errno("socket",_("Could not create a socket"));
+      
+      // Connect to the server
+      SetNonBlock(DataFd,true);
+      if (connect(DataFd,PasvAddr->ai_addr,PasvAddr->ai_addrlen) < 0 &&
+	  errno != EINPROGRESS)
+	 return _error->Errno("socket",_("Could not create a socket"));
+   
+      /* This implements a timeout for connect by opening the connection
+         nonblocking */
+      if (WaitFd(DataFd,true,TimeOut) == false)
+	 return _error->Error(_("Could not connect data socket, connection timed out"));
+      unsigned int Err;
+      unsigned int Len = sizeof(Err);
+      if (getsockopt(DataFd,SOL_SOCKET,SO_ERROR,&Err,&Len) != 0)
+	 return _error->Errno("getsockopt",_("Failed"));
+      if (Err != 0)
+	 return _error->Error(_("Could not connect passive socket."));
+
+      return true;
+   }
+   
+   // Port mode :<
+   close(DataListenFd);
+   DataListenFd = -1;
+
+   // Get the information for a listening socket.
+   struct addrinfo *BindAddr = 0;
+   struct addrinfo Hints;
+   memset(&Hints,0,sizeof(Hints));
+   Hints.ai_socktype = SOCK_STREAM;
+   Hints.ai_flags |= AI_PASSIVE;
+   Hints.ai_family = ((struct sockaddr *)&ServerAddr)->sa_family;
+   int Res;
+   if ((Res = getaddrinfo(0,"0",&Hints,&BindAddr)) != 0)
+      return _error->Error(_("getaddrinfo was unable to get a listening socket"));
+   
+   // Construct the socket
+   if ((DataListenFd = socket(BindAddr->ai_family,BindAddr->ai_socktype,
+			      BindAddr->ai_protocol)) < 0)
+   {
+      freeaddrinfo(BindAddr);
+      return _error->Errno("socket",_("Could not create a socket"));
+   }
+   
+   // Bind and listen
+   if (bind(DataListenFd,BindAddr->ai_addr,BindAddr->ai_addrlen) < 0)
+   {
+      freeaddrinfo(BindAddr);
+      return _error->Errno("bind",_("Could not bind a socket"));
+   }
+   freeaddrinfo(BindAddr);   
+   if (listen(DataListenFd,1) < 0)
+      return _error->Errno("listen",_("Could not listen on the socket"));
+   SetNonBlock(DataListenFd,true);
+   
+   // Determine the name to send to the remote
+   struct sockaddr_storage Addr;
+   socklen_t AddrLen = sizeof(Addr);
+   if (getsockname(DataListenFd,(sockaddr *)&Addr,&AddrLen) < 0)
+      return _error->Errno("getsockname",_("Could not determine the socket's name"));
+
+
+   // Reverse the address. We need the server address and the data port.
+   char Name[NI_MAXHOST];
+   char Service[NI_MAXSERV];
+   char Service2[NI_MAXSERV];
+   getnameinfo((struct sockaddr *)&Addr,AddrLen,
+	       Name,sizeof(Name),Service,sizeof(Service),
+	       NI_NUMERICHOST|NI_NUMERICSERV);
+   getnameinfo((struct sockaddr *)&ServerAddr,ServerAddrLen,
+	       Name,sizeof(Name),Service2,sizeof(Service2),
+	       NI_NUMERICHOST|NI_NUMERICSERV);
+
+   // Send off an IPv4 address in the old port format
+   if (((struct sockaddr *)&Addr)->sa_family == AF_INET && 
+       ForceExtended == false)
+   {
+      // Convert the dots in the quad into commas
+      for (char *I = Name; *I != 0; I++)
+	 if (*I == '.')
+	    *I = ',';
+      unsigned long Port = atoi(Service);
+      
+      // Send the port command
+      unsigned int Tag;
+      string Msg;
+      if (WriteMsg(Tag,Msg,"PORT %s,%d,%d",
+		   Name,
+		   (int)(Port >> 8) & 0xff, (int)(Port & 0xff)) == false)
+	 return false;
+      if (Tag >= 400)
+	 return _error->Error(_("Unable to send PORT command"));
+      return true;
+   }
+
+   // Construct an EPRT command
+   unsigned Proto = 0;
+   for (unsigned J = 0; AFMap[J].Family != 0; J++)
+      if (AFMap[J].Family == ((struct sockaddr *)&Addr)->sa_family)
+	 Proto = AFMap[J].IETFFamily;
+   if (Proto == 0)
+      return _error->Error(_("Unknown address family %u (AF_*)"),
+			   ((struct sockaddr *)&Addr)->sa_family);
+   
+   // Send the EPRT command
+   unsigned int Tag;
+   string Msg;
+   if (WriteMsg(Tag,Msg,"EPRT |%u|%s|%s|",Proto,Name,Service) == false)
+      return false;
+   if (Tag >= 400)
+      return _error->Error(_("EPRT failed, server said: %s"),Msg.c_str());
+   return true;
+}
+									/*}}}*/
+// FTPConn::Finalize - Complete the Data connection			/*{{{*/
+// ---------------------------------------------------------------------
+/* If the connection is in port mode this waits for the other end to hook
+   up to us. */
+bool FTPConn::Finalize()
+{
+   // Passive mode? Do nothing
+   if (PasvAddr != 0)
+      return true;
+   
+   // Close any old socket..
+   close(DataFd);
+   DataFd = -1;
+   
+   // Wait for someone to connect..
+   if (WaitFd(DataListenFd,false,TimeOut) == false)
+      return _error->Error(_("Data socket connect timed out"));
+      
+   // Accept the connection
+   struct sockaddr_in Addr;
+   socklen_t Len = sizeof(Addr);
+   DataFd = accept(DataListenFd,(struct sockaddr *)&Addr,&Len);
+   if (DataFd < 0)
+      return _error->Errno("accept",_("Unable to accept connection"));
+
+   close(DataListenFd);
+   DataListenFd = -1;
+   
+   return true;
+}
+									/*}}}*/
+// FTPConn::Get - Get a file						/*{{{*/
+// ---------------------------------------------------------------------
+/* This opens a data connection, sends REST and RETR and then
+   transfers the file over. */
+bool FTPConn::Get(const char *Path,FileFd &To,unsigned long Resume,
+		  Hashes &Hash,bool &Missing)
+{
+   Missing = false;
+   if (CreateDataFd() == false)
+      return false;
+
+   unsigned int Tag;
+   string Msg;   
+   if (Resume != 0)
+   {      
+      if (WriteMsg(Tag,Msg,"REST %u",Resume) == false)
+	 return false;
+      if (Tag >= 400)
+	 Resume = 0;
+   }
+   
+   if (To.Truncate(Resume) == false)
+      return false;
+
+   if (To.Seek(0) == false)
+      return false;
+   
+   if (Resume != 0)
+   {
+      if (Hash.AddFD(To.Fd(),Resume) == false)
+      {
+	 _error->Errno("read",_("Problem hashing file"));
+	 return false;
+      }
+   }
+   
+   // Send the get command
+   if (WriteMsg(Tag,Msg,"RETR %s",Path) == false)
+      return false;
+   
+   if (Tag >= 400)
+   {
+      if (Tag == 550)
+	 Missing = true;
+      return _error->Error(_("Unable to fetch file, server said '%s'"),Msg.c_str());
+   }
+   
+   // Finish off the data connection
+   if (Finalize() == false)
+      return false;
+   
+   // Copy loop
+   unsigned char Buffer[4096];
+   while (1)
+   {
+      // Wait for some data..
+      if (WaitFd(DataFd,false,TimeOut) == false)
+      {
+	 Close();
+	 return _error->Error(_("Data socket timed out"));
+      }
+      
+      // Read the data..
+      int Res = read(DataFd,Buffer,sizeof(Buffer));
+      if (Res == 0)
+	 break;
+      if (Res < 0)
+      {
+	 if (errno == EAGAIN)
+	    continue;
+	 break;
+      }
+   
+      Hash.Add(Buffer,Res);
+      if (To.Write(Buffer,Res) == false)
+      {
+	 Close();
+	 return false;
+      }      
+   }
+
+   // All done
+   close(DataFd);
+   DataFd = -1;
+   
+   // Read the closing message from the server
+   if (ReadResp(Tag,Msg) == false)
+      return false;
+   if (Tag >= 400)
+      return _error->Error(_("Data transfer failed, server said '%s'"),Msg.c_str());
+   return true;
+}
+									/*}}}*/
+
+// FtpMethod::FtpMethod - Constructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+FtpMethod::FtpMethod() : pkgAcqMethod("1.0",SendConfig)
+{
+   signal(SIGTERM,SigTerm);
+   signal(SIGINT,SigTerm);
+   
+   Server = 0;
+   FailFd = -1;
+}
+									/*}}}*/
+// FtpMethod::SigTerm - Handle a fatal signal				/*{{{*/
+// ---------------------------------------------------------------------
+/* This closes and timestamps the open file. This is neccessary to get 
+   resume behavoir on user abort */
+void FtpMethod::SigTerm(int)
+{
+   if (FailFd == -1)
+      _exit(100);
+   close(FailFd);
+   
+   // Timestamp
+   struct utimbuf UBuf;
+   UBuf.actime = FailTime;
+   UBuf.modtime = FailTime;
+   utime(FailFile.c_str(),&UBuf);
+   
+   _exit(100);
+}
+									/*}}}*/
+// FtpMethod::Configuration - Handle a configuration message		/*{{{*/
+// ---------------------------------------------------------------------
+/* We stash the desired pipeline depth */
+bool FtpMethod::Configuration(string Message)
+{
+   if (pkgAcqMethod::Configuration(Message) == false)
+      return false;
+   
+   TimeOut = _config->FindI("Acquire::Ftp::Timeout",TimeOut);
+   return true;
+}
+									/*}}}*/
+// FtpMethod::Fetch - Fetch a file					/*{{{*/
+// ---------------------------------------------------------------------
+/* Fetch a single file, called by the base class..  */
+bool FtpMethod::Fetch(FetchItem *Itm)
+{
+   URI Get = Itm->Uri;
+   const char *File = Get.Path.c_str();
+   FetchResult Res;
+   Res.Filename = Itm->DestFile;
+   Res.IMSHit = false;
+   
+   // Connect to the server
+   if (Server == 0 || Server->Comp(Get) == false)
+   {
+      delete Server;
+      Server = new FTPConn(Get);
+   }
+  
+   // Could not connect is a transient error..
+   if (Server->Open(this) == false)
+   {
+      Server->Close();
+      Fail(true);
+      return true;
+   }
+   
+   // Get the files information
+   Status(_("Query"));
+   unsigned long Size;
+   if (Server->Size(File,Size) == false ||
+       Server->ModTime(File,FailTime) == false)
+   {
+      Fail(true);
+      return true;
+   }
+   Res.Size = Size;
+
+   // See if it is an IMS hit
+   if (Itm->LastModified == FailTime)
+   {
+      Res.Size = 0;
+      Res.IMSHit = true;
+      URIDone(Res);
+      return true;
+   }
+   
+   // See if the file exists
+   struct stat Buf;
+   if (stat(Itm->DestFile.c_str(),&Buf) == 0)
+   {
+      if (Size == (unsigned)Buf.st_size && FailTime == Buf.st_mtime)
+      {
+	 Res.Size = Buf.st_size;
+	 Res.LastModified = Buf.st_mtime;
+	 Res.ResumePoint = Buf.st_size;
+	 URIDone(Res);
+	 return true;
+      }
+      
+      // Resume?
+      if (FailTime == Buf.st_mtime && Size > (unsigned)Buf.st_size)
+	 Res.ResumePoint = Buf.st_size;
+   }
+   
+   // Open the file
+   Hashes Hash;
+   {
+      FileFd Fd(Itm->DestFile,FileFd::WriteAny);
+      if (_error->PendingError() == true)
+	 return false;
+      
+      URIStart(Res);
+      
+      FailFile = Itm->DestFile;
+      FailFile.c_str();   // Make sure we dont do a malloc in the signal handler
+      FailFd = Fd.Fd();
+      
+      bool Missing;
+      if (Server->Get(File,Fd,Res.ResumePoint,Hash,Missing) == false)
+      {
+	 Fd.Close();
+	 
+	 // Timestamp
+	 struct utimbuf UBuf;
+	 UBuf.actime = FailTime;
+	 UBuf.modtime = FailTime;
+	 utime(FailFile.c_str(),&UBuf);
+	 
+	 // If the file is missing we hard fail otherwise transient fail
+	 if (Missing == true)
+	    return false;
+	 Fail(true);
+	 return true;
+      }
+
+      Res.Size = Fd.Size();
+   }
+   
+   Res.LastModified = FailTime;
+   Res.TakeHashes(Hash);
+   
+   // Timestamp
+   struct utimbuf UBuf;
+   UBuf.actime = FailTime;
+   UBuf.modtime = FailTime;
+   utime(Queue->DestFile.c_str(),&UBuf);
+   FailFd = -1;
+
+   URIDone(Res);
+   
+   return true;
+}
+									/*}}}*/
+
+int main(int argc,const char *argv[])
+{ 
+   setlocale(LC_ALL, "");
+
+   /* See if we should be come the http client - we do this for http
+      proxy urls */
+   if (getenv("ftp_proxy") != 0)
+   {
+      URI Proxy = string(getenv("ftp_proxy"));
+      
+      // Run the HTTP method
+      if (Proxy.Access == "http")
+      {
+	 // Copy over the environment setting
+	 char S[300];
+	 snprintf(S,sizeof(S),"http_proxy=%s",getenv("ftp_proxy"));
+	 putenv(S);
+	 putenv("no_proxy=");
+	 
+	 // Run the http method
+	 string Path = flNotFile(argv[0]) + "http";
+	 execl(Path.c_str(),Path.c_str(),0);
+	 cerr << _("Unable to invoke ") << Path << endl;
+	 exit(100);
+      }      
+   }
+   
+   FtpMethod Mth;
+   
+   return Mth.Run();
+}
diff -uNr apt-0.5.28.6/methods/rfc2553emu.h apt-0.5.28.6-new/methods/rfc2553emu.h
--- apt-0.5.28.6/methods/rfc2553emu.h	Mon Jan 10 16:50:08 2005
+++ apt-0.5.28.6-new/methods/rfc2553emu.h	Mon Apr 25 16:19:16 2005
@@ -26,6 +26,11 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 
+// Always use full emulation on Darwin:
+//  netdb.h has the structures and constants, but getnameinfo() is missing
+//  and getaddrinfo() seems to be broken
+#ifndef __APPLE__
+
 // Autosense getaddrinfo
 #if defined(AI_PASSIVE) && defined(EAI_NONAME)
 #define HAVE_GETADDRINFO
@@ -36,6 +41,8 @@
 #define HAVE_GETNAMEINFO
 #endif
 
+#endif /* __APPLE__ */
+
 // getaddrinfo support?
 #ifndef HAVE_GETADDRINFO
   // Renamed to advoid type clashing.. (for debugging)
@@ -100,6 +107,9 @@
 //  #define NI_NOFQDN (1<<2)
   #define NI_NAMEREQD (1<<3)
   #define NI_DATAGRAM (1<<4)
+  #endif
+  #ifndef NI_DATAGRAM
+  #define NI_DATAGRAM NI_DGRAM
   #endif
 
   #define sockaddr_storage sockaddr_in
diff -uNr apt-0.5.28.6/patch_flush apt-0.5.28.6-new/patch_flush
--- apt-0.5.28.6/patch_flush	Wed Dec 31 19:00:00 1969
+++ apt-0.5.28.6-new/patch_flush	Mon Apr 25 16:19:16 2005
@@ -0,0 +1,11 @@
+#!/bin/sh
+set -e
+
+files=`find . -name '*.cc' -print | xargs grep -l 'flush;'`
+
+for i in $files ; do
+  sed 's/<< flush;/<< flush, fflush(NULL);/g' <$i >$i.tmp
+  mv $i.tmp $i
+done
+
+exit 0

diff -uNr arts-1.4.0/flow/Makefile.am arts-1.4.0-new/flow/Makefile.am
--- arts-1.4.0/flow/Makefile.am	2004-11-18 15:19:59.000000000 -0500
+++ arts-1.4.0-new/flow/Makefile.am	2005-05-10 10:50:03.000000000 -0400
@@ -1,4 +1,3 @@
-
 SUBDIRS = mcopclass gsl gslpp
 INCLUDES = -I$(top_srcdir)/mcop -I$(top_builddir)/mcop $(all_includes)
 AM_CXXFLAGS = $(MAS_CFLAGS) $(JACK_CFLAGS) -DQT_CLEAN_NAMESPACE
@@ -13,7 +12,7 @@
 
 libartsflow_la_LIBADD = $(top_builddir)/mcop/libmcop.la libartsflow_idl.la $(top_builddir)/flow/gslpp/libgslpp.la $(LIBAUDIOFILE) $(LIBASOUND) $(LIBAUDIOIO) $(LIBOSSAUDIO) $(LIBAUDIONAS) $(LIBCSL) $(SGILIBAUDIO) $(LIBESD) $(LIBMAS) $(JACK_LIBADD) -lm \
   $(top_builddir)/flow/gsl/libgsl.la
-libartsflow_la_LDFLAGS = $(MAS_LDFLAGS) $(JACK_LDFLAGS) $(LIBAUDIOFILE_LDFLAGS) $(LIBAUDIONAS_LDFLAGS) $(LIBESD_LDFLAGS) -no-undefined -version-info 1:0
+libartsflow_la_LDFLAGS = $(MAS_LDFLAGS) $(JACK_LDFLAGS) $(LIBAUDIOFILE_LDFLAGS) $(LIBAUDIONAS_LDFLAGS) $(LIBESD_LDFLAGS) -no-undefined -version-info 1:0 $(FRAMEWORK_COREAUDIO)
 libartsflow_la_COMPILE_FIRST = artsflow.h
 libartsflow_la_SOURCES =  synth_play_impl.cc \
   gslschedule.cc audiosubsys.cc \
@@ -27,7 +26,7 @@
   audioionull.cc audioiolibaudioio.cc audioioesd.cc audioiojack.cc \
   audioiosun.cc audioioaix.cc audioionas.cc cpuinfo.cc \
   audioioossthreaded.cc audiotobytestream_impl.cc audioiosgi.cc \
-  audioiocsl.cc audioiomas.cc datahandle_impl.cc
+  audioiocsl.cc audioiomas.cc datahandle_impl.cc audioiocoreaudio.cc
 
 artsincludedir = $(includedir)/arts
 artsinclude_HEADERS = artsflow.h audiosubsys.h cache.h \
diff -uNr arts-1.4.0/flow/audioiocoreaudio.cc arts-1.4.0-new/flow/audioiocoreaudio.cc
--- arts-1.4.0/flow/audioiocoreaudio.cc	1969-12-31 19:00:00.000000000 -0500
+++ arts-1.4.0-new/flow/audioiocoreaudio.cc	2005-05-10 10:43:37.000000000 -0400
@@ -0,0 +1,689 @@
+    /*
+    
+    Copyright (C) 2001 Stefan Westerfeld
+                        stefan@space.twc.de
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+    
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.
+    
+    */
+    /*
+        Modifications for ARTS -    
+        Ben Hines <bhines@alumni.ucsd.edu>
+        Ben Reed  <ranger@befunk.com>
+        
+        Some CoreAudio code borrowed from ESD -
+        Shawn Hsiao <phsiao@mac.com>
+        Masanori Sekino <m-sekino@mb.kcom.ne.jp>
+    */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_COREAUDIO
+
+#define DEBUG 1
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/file.h>
+
+/* for useful debugging macros */
+#include <mach/error.h>
+
+#include <CoreAudio/CoreAudio.h>
+
+#include "debug.h"
+#include "audioio.h"
+#include "audiosubsys.h"
+
+#define NAME_LEN 256		/* max length of a device name */
+#define BUF_SIZE (4 * 1024)  /* from ESD */
+
+#define driverVersion "0.01 alpha"
+
+#ifdef BIG_ENDIAN
+#define defaultFormat 17
+#else
+#define defaultFormat 16
+#endif
+  
+bool NotifyOnError (OSStatus inRetVal, const char * inStringDesc);
+
+struct audio_queue {
+    float dataBuf[BUF_SIZE];
+    pthread_mutex_t mutex;
+    pthread_cond_t condition;
+    int numSamples;
+};
+
+static OSStatus PlaybackIOProc(AudioDeviceID inDevice,
+			const AudioTimeStamp *inNow,
+			const AudioBufferList *inInputData,
+			const AudioTimeStamp *inInputTime,
+			AudioBufferList *outOutputData,
+			const AudioTimeStamp *inOutputTime,
+			audio_queue *inClientData);
+
+static OSStatus RecordIOProc(AudioDeviceID inDevice,
+		      const AudioTimeStamp *inNow,
+		      const AudioBufferList *inInputData,
+		      const AudioTimeStamp *inInputTime,
+		      AudioBufferList *outOutputData,
+		      const AudioTimeStamp *inOutputTime,
+		      audio_queue *inClientData);
+                      
+OSStatus PropertyListenerProc(AudioHardwarePropertyID	inPropertyID,
+                      void* inClientData);
+
+namespace Arts {
+
+class AudioIOCoreAudio : public AudioIO {
+
+protected:
+     /* From ESD */
+     AudioDeviceID gOutputDeviceID, gInputDeviceID;
+    
+     audio_queue input;
+     audio_queue output;    
+    
+     int audioPlaybackStarted, audioRecordStarted;
+     int coreaudio_has_output_device;
+     int coreaudio_has_input_device;
+     int coreaudio_init;
+     
+     /* Arts Specific */
+     int audio_fd;
+     int bytesPerSec;
+     timeval start;
+        
+public:
+	AudioIOCoreAudio();
+	bool supportsFormat(AudioDeviceID device, AudioStreamBasicDescription *format);
+	void setParam(AudioParam param, int& value);
+	int getParam(AudioParam param);
+
+	bool open();
+	void close();
+	int read(void *buffer, int size);
+	int write(void *buffer, int size);
+
+};
+
+REGISTER_AUDIO_IO(AudioIOCoreAudio, "coreaudio", "Apple CoreAudio");
+}; // end namespace Arts
+
+using namespace std;
+using namespace Arts;
+             
+AudioIOCoreAudio::AudioIOCoreAudio() {
+        
+        artsdebug("CoreAudio driver version %s", driverVersion);
+        /*
+         * default parameters
+         */
+        param(samplingRate) = 44100;
+        paramStr(deviceName) = "default";
+        param(fragmentSize) = 1024;
+        param(fragmentCount) = 7;
+        param(channels) = 2;
+        param(direction) = 2;
+        param(format) = defaultFormat;
+        
+        input.numSamples = output.numSamples = 0;
+    
+        audioPlaybackStarted = 0, audioRecordStarted = 0;
+        coreaudio_has_output_device = 0;
+        coreaudio_has_input_device = 0;
+        coreaudio_init = 0;
+}
+
+void
+AudioIOCoreAudio::close()
+{   
+    artsdebug("AudioIOCoreAudio::close().. ");
+    /* deactivate both of them */
+    if (coreaudio_has_output_device) {
+        if(audioPlaybackStarted)
+        NotifyOnError(AudioDeviceStop(gOutputDeviceID, 
+                  (AudioDeviceIOProc) PlaybackIOProc),
+                        "AudioDeviceStop (PlaybackIOProc)");
+                        
+        NotifyOnError(AudioDeviceRemoveIOProc(gOutputDeviceID,
+                  (AudioDeviceIOProc) PlaybackIOProc),
+                        "AudioDeviceRemoveIOProc (PlaybackIOProc)");
+                            
+        NotifyOnError(AudioHardwareRemovePropertyListener(
+            kAudioHardwarePropertyDefaultOutputDevice, 
+            PropertyListenerProc),
+                "AudioHardwareRemovePropertyListener (PropertyListenerProc)");
+                        
+        artsdebug(" ... closing output\n");
+        audioPlaybackStarted = 0;
+        coreaudio_has_output_device = 0;
+    }
+    
+    if (coreaudio_has_input_device) {        
+        if(audioRecordStarted)
+        NotifyOnError(AudioDeviceStop(gInputDeviceID, 
+                            (AudioDeviceIOProc) RecordIOProc),
+                        "AudioDeviceStop (RecordIOProc)");
+                        
+        NotifyOnError(AudioDeviceRemoveIOProc(gInputDeviceID,
+                            (AudioDeviceIOProc) RecordIOProc),
+                        "AudioDeviceRemoveIOProc (RecordIOProc)");
+                            
+        NotifyOnError(AudioHardwareRemovePropertyListener(
+            kAudioHardwarePropertyDefaultOutputDevice, 
+            PropertyListenerProc),
+                "AudioHardwareRemovePropertyListener (PropertyListenerProc)");
+                        
+        artsdebug(" ... closing intput\n");
+        audioRecordStarted = 0;
+        coreaudio_has_input_device = 0;
+    }
+}
+
+ 
+int 
+AudioIOCoreAudio::write(void *buffer, int buf_size) {
+
+  float scale = 1.0 / SHRT_MAX;
+  int remain_to_write = buf_size;
+
+  if (!coreaudio_has_output_device)
+  {
+    arts_warning("AudioIOCoreAudio::write with no output device!");
+    return -1;
+  }
+  if (!audioPlaybackStarted) {
+    NotifyOnError(AudioDeviceStart(gOutputDeviceID,(AudioDeviceIOProc)  PlaybackIOProc),
+                    "AudioDeviceStart (PlaybackIOProc)");
+    audioPlaybackStarted = 1;
+  }
+
+  while (remain_to_write)
+  {
+    pthread_mutex_lock(&output.mutex);
+
+    while(output.numSamples == BUF_SIZE)
+      pthread_cond_wait(&output.condition, &output.mutex);
+
+    {
+      short *src_data = (short *)buffer + (buf_size - remain_to_write) / sizeof(short);
+      float *dst_data = output.dataBuf + output.numSamples;
+      int src_samples = remain_to_write / sizeof(short);
+      int dst_samples = BUF_SIZE - output.numSamples;
+      int n = (dst_samples < src_samples) ? dst_samples : src_samples;
+      int i;
+
+      for (i = 0; i < n; i++)
+        dst_data[i] = scale * src_data[i];
+
+      output.numSamples += n;
+      remain_to_write -= n * sizeof(short);
+    }
+
+    pthread_mutex_unlock(&output.mutex);
+  }
+
+  return (buf_size);
+
+}
+
+int AudioIOCoreAudio::read(void *buffer, int buf_size) {
+  float scale = SHRT_MAX;
+  int remain_to_read = buf_size;
+
+  if (!coreaudio_has_input_device)
+  {
+    arts_warning("AudioIOCoreAudio::read with no input device!");
+    return -1;
+  }
+
+  if (!audioRecordStarted) {
+    NotifyOnError(AudioDeviceStart(gInputDeviceID,(AudioDeviceIOProc)  RecordIOProc),
+                    "AudioDeviceStart (RecordIOProc)");
+    audioRecordStarted = 1;
+  }
+
+  while (remain_to_read)
+  {
+    pthread_mutex_lock(&input.mutex);
+
+    while(input.numSamples == BUF_SIZE)
+      pthread_cond_wait(&input.condition, &input.mutex);
+
+    {
+      float *src_data = input.dataBuf + input.numSamples;
+      short *dst_data = (short *)buffer + (buf_size - remain_to_read) / sizeof(short);
+      int src_samples = BUF_SIZE - input.numSamples;
+      int dst_samples = remain_to_read / sizeof(short);
+      int n = (dst_samples < src_samples) ? dst_samples : src_samples;
+      int i;
+
+      for (i = 0; i < n; i++)
+        dst_data[i] = (short)(scale * src_data[i]);
+
+      input.numSamples += n;
+      remain_to_read -= n * sizeof(short);
+    }
+
+    pthread_mutex_unlock(&input.mutex);
+  }
+
+  return (buf_size);
+
+}
+
+
+bool
+AudioIOCoreAudio::open()
+{
+        #define LEN_DEVICE_NAME 128
+        UInt32 propertySize, bufferByteCount;
+        char deviceName[LEN_DEVICE_NAME];
+        char fdName[LEN_DEVICE_NAME + 50];
+        struct AudioStreamBasicDescription streamDesc;
+
+        /***** Arts Specific ***/
+	arts_warning("info: requesting %d, %d channel sound at %d hz\n",
+            param(direction), param(channels), param(samplingRate));
+
+        bytesPerSec = param(channels) * 2 * param(samplingRate);
+        gettimeofday(&start,0);
+	if (param(direction) & directionWrite) {
+            if(coreaudio_has_output_device)
+            {
+                arts_warning("yes.. AudioIOCoreAudio::open() called twice for writing!");
+                return true;
+            }
+                
+            /* HACK - create the file descriptor?  */
+            sprintf(fdName, "/tmp/audioiocoreaudio");
+            fopen(fdName, "w+");
+            audio_fd = ::open(fdName,  O_RDWR | O_NDELAY, 0);
+            /* Obtain a file descriptor for our "listening" socket */
+            if(audio_fd == -1)
+            {
+                arts_warning("file descriptor can't be created, %s\n", strerror(errno));
+                return false;
+            }
+            /***** End Arts Specific ***/
+            /*  Stuff from ESD... */
+            /********************** playback section ***************************/
+            /* get default output device */
+            propertySize = sizeof(gOutputDeviceID);
+            NotifyOnError(AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
+                                                &propertySize,
+                                                &gOutputDeviceID),
+                        "AudioHardwareGetProperty (Default Output Device)");
+            
+            arts_assert(gOutputDeviceID != kAudioDeviceUnknown);
+            
+            /* got default output device */
+            coreaudio_has_output_device = 1;
+        
+            /* get output device name */
+            propertySize = sizeof(char)*LEN_DEVICE_NAME;
+            NotifyOnError(AudioDeviceGetProperty(gOutputDeviceID,
+                                            1,
+                                            0,
+                                            kAudioDevicePropertyDeviceName,
+                                            &propertySize,
+                                            deviceName),
+                            "AudioDeviceGetProperty (Output Device Name)");
+        
+            /* get output format */
+            propertySize = sizeof(struct AudioStreamBasicDescription);
+            NotifyOnError(AudioDeviceGetProperty(gOutputDeviceID,
+                                            1,
+                                            0,
+                                            kAudioDevicePropertyStreamFormat,
+                                            &propertySize,
+                                            &streamDesc),
+                        "AudioDeviceGetProperty (Output StreamFormat)");
+                        
+            if ((streamDesc.mSampleRate != 44100.0) ||
+                (streamDesc.mFormatID != kAudioFormatLinearPCM) ||
+               !(streamDesc.mFormatFlags & kLinearPCMFormatFlagIsFloat) ||
+                (streamDesc.mChannelsPerFrame != 2))
+            {
+            	arts_warning("Unsupported output device format!\n");
+                return (-2);
+            }
+        
+            /* set buffer size */
+            bufferByteCount = BUF_SIZE * sizeof(float);
+            propertySize = sizeof(bufferByteCount);
+            NotifyOnError(AudioDeviceSetProperty(gOutputDeviceID,
+                                            0,
+                                            0,
+                                            0,
+                                            kAudioDevicePropertyBufferSize,
+                                            propertySize,
+                                            &bufferByteCount),
+                        "AudioDeviceSetProperty (Output BufferSize)");
+    
+            artsdebug("using device %s for output:\n", deviceName);
+            artsdebug("\twith sample rate %f, %ld channels and %ld-bit sample\n",
+                    streamDesc.mSampleRate,
+                    streamDesc.mChannelsPerFrame,
+                    streamDesc.mBitsPerChannel);
+        
+            arts_return_val_if_fail(pthread_mutex_init(&output.mutex, NULL) == 0, -1);
+            arts_return_val_if_fail(pthread_cond_init(&output.condition, NULL) == 0, -1);
+            
+            /* Registers PlaybackIOProc with the device without activating it. */
+            NotifyOnError(AudioDeviceAddIOProc(gOutputDeviceID, 
+                            (AudioDeviceIOProc) PlaybackIOProc, 
+                                                (void *)&output),
+                            "AudioDeviceAddIOProc (PlaybackIOProc)");
+                            
+            NotifyOnError(AudioHardwareAddPropertyListener(
+                kAudioHardwarePropertyDefaultOutputDevice, 
+                PropertyListenerProc, this),
+                 "AudioHardwareAddPropertyListener (PropertyListenerProc)");
+                
+	}
+
+        if (param(direction) & directionRead) {
+            /********************** record section ***************************/
+            if(coreaudio_has_input_device)
+            {
+                arts_warning("AudioIOCoreAudio::open() called twice for reading!");
+                return true;
+            }
+                
+            /* get default input device */
+            propertySize = sizeof(gInputDeviceID);
+            NotifyOnError(AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
+                                                &propertySize,
+                                                &gInputDeviceID),
+                          "AudioHardwareGetProperty (Default Input Device)");
+
+            arts_assert(gInputDeviceID != kAudioDeviceUnknown);         
+            
+            /* got default input device */
+            coreaudio_has_input_device = 1;
+        
+            /* get input device name */
+            propertySize = sizeof(char)*64;
+            NotifyOnError(AudioDeviceGetProperty(gInputDeviceID,
+                                            1,
+                                            1,
+                                            kAudioDevicePropertyDeviceName,
+                                            &propertySize,
+                                            deviceName),
+                        "AudioDeviceGetProperty (Input Device Name)");
+
+            /* get input format */
+            propertySize = sizeof(struct AudioStreamBasicDescription);
+            NotifyOnError(AudioDeviceGetProperty(gInputDeviceID,
+                                            1,
+                                            1,
+                                            kAudioDevicePropertyStreamFormat,
+                                            &propertySize,
+                                            &streamDesc),
+                        "AudioDeviceGetProperty (Input Stream Size)");
+        
+            if ((streamDesc.mSampleRate != 44100.0) ||
+                (streamDesc.mFormatID != kAudioFormatLinearPCM) ||
+                !(streamDesc.mFormatFlags & kLinearPCMFormatFlagIsFloat) ||
+                (streamDesc.mChannelsPerFrame != 2))
+            {
+                artsdebug("Unsupported Input Device format.\n");
+                return (-2);
+            }
+        
+            /* set buffer size */
+            bufferByteCount = BUF_SIZE * sizeof(float);
+            propertySize = sizeof(bufferByteCount);
+            NotifyOnError(AudioDeviceSetProperty(gInputDeviceID,
+                                            0,
+                                            0,
+                                            1,
+                                            kAudioDevicePropertyBufferSize,
+                                            propertySize,
+                                            &bufferByteCount),
+                        "AudioDeviceSetProperty (input buffersize)");
+
+            artsdebug("using device %s for input:\n", deviceName);
+            artsdebug("\twith sample rate %f, %ld channels and %ld-bit sample\n",
+                    streamDesc.mSampleRate,
+                    streamDesc.mChannelsPerFrame,
+                    streamDesc.mBitsPerChannel);
+
+            arts_return_val_if_fail(pthread_mutex_init(&input.mutex, NULL) == 0, -1);
+            arts_return_val_if_fail(pthread_cond_init(&input.condition, NULL) == 0, -1);
+        
+            /* Registers PlaybackIOProc with the device without activating it. */
+            NotifyOnError(AudioDeviceAddIOProc(gInputDeviceID, 
+                                (AudioDeviceIOProc) RecordIOProc, 
+                                                (void *)&input),
+                            "AudioDeviceAddIOProc (RecordIOProc)");
+                                                                                        
+            NotifyOnError(AudioHardwareAddPropertyListener(
+                kAudioHardwarePropertyDefaultInputDevice, 
+                PropertyListenerProc, this),
+                 "AudioHardwareAddPropertyListener (PropertyListenerProc)");
+
+	}
+        
+	return true;
+}
+
+void AudioIOCoreAudio::setParam(AudioParam p, int& value) {
+	switch(p)
+	{
+		default:
+			param(p) = value;
+			break;
+	}
+}
+
+int AudioIOCoreAudio::getParam(AudioParam p) {
+	timeval now;
+	double delta;
+	int bytes;
+
+	switch(p)
+	{
+		case canRead:
+		case canWrite:
+			gettimeofday(&now,0);
+			delta = (double)now.tv_sec + (double)now.tv_usec/1000000.0;
+			delta -= (double)start.tv_sec + (double)start.tv_usec/1000000.0;
+			bytes = (int)( (delta * bytesPerSec) -  ((p == canRead)?input.numSamples:output.numSamples));
+               //         printf("%s %d bytes\n", ((p == canRead)?"canRead":"canWrite"), bytes);
+			return bytes;
+			break;
+
+		case autoDetect:
+			return 1;
+			break;
+                        
+		case selectReadFD:
+			return (param(direction) & directionRead)?audio_fd:-1;
+			break;
+
+		case selectWriteFD:
+			return (param(direction) & directionWrite)?audio_fd:-1;
+			break;
+                        
+		default:
+			return param(p);
+			break;
+	}
+}
+
+bool 
+AudioIOCoreAudio::supportsFormat(AudioDeviceID device, 
+                                 AudioStreamBasicDescription *format) {
+
+	UInt32 formatSize;
+	OSStatus err;
+
+	formatSize = sizeof(*format);
+	err = AudioDeviceGetProperty(device, 0, false,
+		kAudioDevicePropertyStreamFormatSupported, &formatSize, format);
+	NotifyOnError(err, "supportsFormat");
+
+	if (err == noErr) {
+		return true;
+	} else {
+		return false;
+	}
+
+}
+
+/* Add __attribute__((unused)) to unused parameters when that gcc bug is fixed for OS X (3.4?)*/
+static OSStatus PlaybackIOProc(AudioDeviceID inDevice,
+			const AudioTimeStamp *inNow,
+			const AudioBufferList *inInputData,
+			const AudioTimeStamp *inInputTime,
+			AudioBufferList *outOutputData,
+			const AudioTimeStamp *inOutputTime,
+			audio_queue *inClientData)
+{
+  float *bufPtr = (float *) outOutputData->mBuffers[0].mData;
+  int i;
+
+  pthread_mutex_lock(&inClientData->mutex);
+
+  for (i = 0; i < inClientData->numSamples; i++)
+    bufPtr[i] = inClientData->dataBuf[i];
+  for ( ; i < BUF_SIZE; i++)
+    bufPtr[i] = 0;
+  inClientData->numSamples = 0;
+
+  pthread_mutex_unlock(&inClientData->mutex);
+  pthread_cond_signal(&inClientData->condition);
+
+  return (kAudioHardwareNoError);
+}
+
+/* Add __attribute__((unused)) to unused parameters when that gcc bug is fixed for OS X (3.4?)*/
+static OSStatus RecordIOProc(AudioDeviceID inDevice,
+		      const AudioTimeStamp *inNow,
+		      const AudioBufferList *inInputData,
+		      const AudioTimeStamp *inInputTime,
+		      AudioBufferList *outOutputData,
+		      const AudioTimeStamp *inOutputTime,
+		      audio_queue *inClientData)
+{
+  float *bufPtr = inInputData->mBuffers[0].mData;
+  int i;
+
+  pthread_mutex_lock(&inClientData->mutex);
+
+  for (i = 0; i < BUF_SIZE; i++)
+    inClientData->dataBuf[i] = bufPtr[i];
+  inClientData->numSamples = 0;
+
+  pthread_mutex_unlock(&inClientData->mutex);
+  pthread_cond_signal(&inClientData->condition);
+
+  return (kAudioHardwareNoError);
+}
+
+OSStatus PropertyListenerProc(AudioHardwarePropertyID	inPropertyID, 
+                                void *	inClientData)
+{
+   UInt32 propertySize = sizeof(AudioDeviceID);
+   AudioDeviceID deviceID;
+   
+   arts_warning("PropertyListenerProc called ... ");
+    
+   switch(inPropertyID)
+   {
+        case kAudioHardwarePropertyDefaultOutputDevice:
+            artsdebug("PropertyListenerProc kAudioHardwarePropertyDefaultOutputDevice:\n");
+            ((AudioIOCoreAudio*)inClientData)->close();
+            ((AudioIOCoreAudio*)inClientData)->open();
+            return noErr;
+        case kAudioHardwarePropertyDefaultInputDevice:
+            artsdebug("PropertyListenerProc kAudioHardwarePropertyDefaultOutputDevice:\n");
+            ((AudioIOCoreAudio*)inClientData)->close();
+            ((AudioIOCoreAudio*)inClientData)->open();
+            return noErr;
+            break;
+            
+        default:
+            return noErr;
+            break;    
+    }
+}
+
+/* Utility */
+
+bool NotifyOnError (OSStatus inRetVal, const char * inStringDesc) {
+	if (inRetVal == noErr) {
+		return true;
+	} else {
+		switch(inRetVal) {
+			case kAudioHardwareNoError:
+				break;
+			case kAudioHardwareNotRunningError:
+				arts_warning("error: hardware not running in %s", inStringDesc);
+				break;
+			case kAudioHardwareUnspecifiedError:
+				arts_warning("error: unspecified error in %s", inStringDesc);
+				break;
+			case kAudioHardwareUnknownPropertyError:
+				arts_warning("error: unknown property in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadPropertySizeError:
+				arts_warning("error: bad property size in %s", inStringDesc);
+				break;
+			case kAudioHardwareIllegalOperationError:
+				arts_warning("error: illegal operation in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadDeviceError:
+				arts_warning("error: bad device in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadStreamError:
+				arts_warning("error: bad stream in %s", inStringDesc);
+				break;
+			case kAudioDeviceUnsupportedFormatError:
+				arts_warning("error: unsupported format in %s", inStringDesc);
+				break;
+			case kAudioDevicePermissionsError:
+				arts_warning("error: bad device permissions in %s", inStringDesc);
+				break;
+			default:
+				arts_warning("error: unknown CoreAudio error in %s", inStringDesc);
+				break;
+		}
+			
+		arts_warning("  system: 0x%d", err_get_system(inRetVal));
+		arts_warning("  sub:    0x%d", err_get_sub(inRetVal));
+		arts_warning("  code:   0x%d", err_get_code(inRetVal));
+		return false;
+	}
+}
+
+void ExitOnError (OSStatus inRetVal, const char * inStringDesc) {
+	if ( NotifyOnError (inRetVal, inStringDesc) ) {
+		exit(1);
+	}
+}
+
+#endif // HAVE_COREAUDIO
diff -uNr arts-1.4.0/flow/audioioesd.cc arts-1.4.0-new/flow/audioioesd.cc
--- arts-1.4.0/flow/audioioesd.cc	2005-02-03 05:19:06.000000000 -0500
+++ arts-1.4.0-new/flow/audioioesd.cc	2005-05-10 08:12:35.000000000 -0400
@@ -213,6 +213,9 @@
 		// of any portable way to peek at the socket's send or receive
 		// buffers.
 
+	case autoDetect:
+		return 12;
+
 	default:
 		return param(p);
 	}
diff -uNr arts-1.4.0/flow/gsl/Makefile.am arts-1.4.0-new/flow/gsl/Makefile.am
--- arts-1.4.0/flow/gsl/Makefile.am	2005-02-03 05:19:06.000000000 -0500
+++ arts-1.4.0-new/flow/gsl/Makefile.am	2005-05-10 08:12:35.000000000 -0400
@@ -15,7 +15,7 @@
 libgsl_la_LIBADD = $(top_builddir)/mcop/libmcop.la -lm $(LIBPOSIX4) $(GSL_LIBS) $(LIB_POLL) $(GLIB_LIBADD)
 libgsl_la_LDFLAGS = -no-undefined $(all_libraries)
 
-#noinst_PROGRAMS = $(GSL_NOINST_PROGS)
+noinst_PROGRAMS = $(GSL_NOINST_PROGS)
 
 GSL_progs_ldadd = libgsl.la -lm $(LIBPTHREAD)
 
diff -uNr arts-1.4.0/libltdl/ltdl.c arts-1.4.0-new/libltdl/ltdl.c
--- arts-1.4.0/libltdl/ltdl.c	2004-09-07 07:13:36.000000000 -0400
+++ arts-1.4.0-new/libltdl/ltdl.c	2005-05-10 08:12:35.000000000 -0400
@@ -643,7 +643,20 @@
      lt_module module;
      const char *symbol;
 {
+#ifdef TIGER_DLSYM_HACK
+  lt_ptr address = NULL;
+  char* u_symbol = NULL;
+  int val=asprintf(&u_symbol,"_%s",symbol);
+  address = NSAddressOfSymbol(NSLookupSymbolInModule(module,u_symbol));
+  if (((!strcmp("__kde_do_not_unload",symbol)) && (!strcmp("__kde_do_unload",symbol)))) {
+    if ((NULL == address) && NSIsSymbolNameDefined(u_symbol)) {
+      address = dlsym (module, symbol);
+    }
+  }
+  free(u_symbol);
+#else
   lt_ptr address = dlsym (module, symbol);
+#endif
 
   if (!address)
     {
diff -uNr arts-1.4.0/soundserver/Makefile.am arts-1.4.0-new/soundserver/Makefile.am
--- arts-1.4.0/soundserver/Makefile.am	2005-02-03 05:19:06.000000000 -0500
+++ arts-1.4.0-new/soundserver/Makefile.am	2005-05-10 08:20:55.000000000 -0400
@@ -51,37 +51,38 @@
 
 ###### "real" programs
 
-bin_PROGRAMS = artsd artsplay artscat artswrapper artsshell artsrec
+bin_PROGRAMS = artswrapper
+kdeinit_LTLIBRARIES = artsd.la artsplay.la artscat.la artsshell.la artsrec.la
 
-artsd_LDADD = libsoundserver_idl.la $(FLOWLIBS) \
+artsd_la_LIBADD = libsoundserver_idl.la $(FLOWLIBS) \
               $(top_builddir)/mcop_mt/libmcop_mt.la
-artsd_LDFLAGS = $(USE_THREADS)
-artsd_SOURCES = soundserverv2_impl.cc soundserver_impl.cc simplesoundserver_impl.cc artsd.cc cpuusage.cc samplestorage_impl.cc crashhandler.cc soundserverstartup_impl.cc
-artsd_COMPILE_FIRST = soundserver.h artsversion.h
-
-artscat_LDADD = libsoundserver_idl.la $(FLOWLIBS) $(LIBPTHREAD)
-artscat_LDFLAGS = $(USE_THREADS)
-artscat_SOURCES = artscat.cc
-artscat_COMPILE_FIRST = soundserver.h artsversion.h 
-
-artsrec_LDADD = libsoundserver_idl.la $(FLOWLIBS) $(LIBPTHREAD)
-artsrec_LDFLAGS = $(USE_THREADS)
-artsrec_SOURCES = artsrec.cc
-artsrec_COMPILE_FIRST = soundserver.h artsversion.h
-
-artsplay_LDADD = libsoundserver_idl.la $(LIBPTHREAD)
-artsplay_LDFLAGS = $(USE_THREADS)
-artsplay_SOURCES = artsplay.cc
-artsplay_COMPILE_FIRST = soundserver.h artsversion.h
+artsd_la_LDFLAGS = $(USE_THREADS) -module
+artsd_la_SOURCES = soundserverv2_impl.cc soundserver_impl.cc simplesoundserver_impl.cc artsd.cc cpuusage.cc samplestorage_impl.cc crashhandler.cc soundserverstartup_impl.cc
+artsd_la_COMPILE_FIRST = soundserver.h artsversion.h
+
+artscat_la_LIBADD = libsoundserver_idl.la $(FLOWLIBS) $(LIBPTHREAD)
+artscat_la_LDFLAGS = $(USE_THREADS) -module
+artscat_la_SOURCES = artscat.cc
+artscat_la_COMPILE_FIRST = soundserver.h artsversion.h 
+
+artsrec_la_LIBADD = libsoundserver_idl.la $(FLOWLIBS) $(LIBPTHREAD)
+artsrec_la_LDFLAGS = $(USE_THREADS) -module
+artsrec_la_SOURCES = artsrec.cc
+artsrec_la_COMPILE_FIRST = soundserver.h artsversion.h
+
+artsplay_la_LIBADD = libsoundserver_idl.la $(LIBPTHREAD)
+artsplay_la_LDFLAGS = $(USE_THREADS) -module
+artsplay_la_SOURCES = artsplay.cc
+artsplay_la_COMPILE_FIRST = soundserver.h artsversion.h
 
 artswrapper_SOURCES = artswrapper.c
 artswrapper_INCLUDES = -I$(top_builddir) -DEXECUTE=\"$(artsdpath)\"
 artswrapper_LDADD = $(LIBPOSIX4)
 
-artsshell_LDADD = libsoundserver_idl.la $(LIBPTHREAD)
-artsshell_LDFLAGS = $(USE_THREADS)
-artsshell_SOURCES = artsshell.cc tradercheck.cc
-artsshell_COMPILE_FIRST = soundserver.h artsversion.h ../flow/artsflow.h
+artsshell_la_LIBADD = libsoundserver_idl.la $(LIBPTHREAD)
+artsshell_la_LDFLAGS = $(USE_THREADS) -module
+artsshell_la_SOURCES = artsshell.cc tradercheck.cc
+artsshell_la_COMPILE_FIRST = soundserver.h artsversion.h ../flow/artsflow.h
 
 DISTCLEANFILES = soundserver.cc soundserver.h soundserver.mcopclass \
   soundserver.mcoptype kmedia2.h kmedia2.cc kmedia2.mcopclass kmedia2.mcoptype artsversion.h
diff -uNr arts-1.4.0/soundserver/artscat.cc arts-1.4.0-new/soundserver/artscat.cc
--- arts-1.4.0/soundserver/artscat.cc	2003-07-05 18:20:23.000000000 -0400
+++ arts-1.4.0-new/soundserver/artscat.cc	2005-05-10 08:15:19.000000000 -0400
@@ -178,7 +178,7 @@
 	exit(1);	
 }
 
-int main(int argc, char **argv)
+extern "C" int kdemain(int argc, char **argv)
 {
 	bool titleSetByUser = false;
 	int optch;
diff -uNr arts-1.4.0/soundserver/artsd.cc arts-1.4.0-new/soundserver/artsd.cc
--- arts-1.4.0/soundserver/artsd.cc	2004-11-05 13:33:20.000000000 -0500
+++ arts-1.4.0-new/soundserver/artsd.cc	2005-05-10 08:15:25.000000000 -0400
@@ -249,7 +249,7 @@
 	cerr << endl;
 }
 
-int main(int argc, char **argv)
+extern "C" int kdemain(int argc, char **argv)
 {
 	handleArgs(argc, argv);
 
diff -uNr arts-1.4.0/soundserver/artsplay.cc arts-1.4.0-new/soundserver/artsplay.cc
--- arts-1.4.0/soundserver/artsplay.cc	2003-03-07 17:07:30.000000000 -0500
+++ arts-1.4.0-new/soundserver/artsplay.cc	2005-05-10 08:15:31.000000000 -0400
@@ -50,7 +50,7 @@
 		return string(buffer) + '/' + path;
 }
 
-int main(int argc, char **argv)
+extern "C" int kdemain(int argc, char **argv)
 {
 	if(argc != 2)
 	{
diff -uNr arts-1.4.0/soundserver/artsrec.cc arts-1.4.0-new/soundserver/artsrec.cc
--- arts-1.4.0/soundserver/artsrec.cc	2003-07-05 18:20:23.000000000 -0400
+++ arts-1.4.0-new/soundserver/artsrec.cc	2005-05-10 08:15:37.000000000 -0400
@@ -136,7 +136,7 @@
 	exit(1);	
 }
 
-int main(int argc, char **argv)
+extern "C" int kdemain(int argc, char **argv)
 {
 	int optch;
 	while((optch = getopt(argc,argv,"r:b:c:hv")) > 0)
diff -uNr arts-1.4.0/soundserver/artsshell.cc arts-1.4.0-new/soundserver/artsshell.cc
--- arts-1.4.0/soundserver/artsshell.cc	2003-07-29 04:31:54.000000000 -0400
+++ arts-1.4.0-new/soundserver/artsshell.cc	2005-05-10 08:15:45.000000000 -0400
@@ -643,7 +643,7 @@
 	return 0;
 }
 
-int main(int argc, char *argv[])
+extern "C" int kdemain(int argc, char *argv[])
 {
 	Arts::Dispatcher dispatcher;
 	Arts::SoundServerV2 server(Arts::Reference("global:Arts_SoundServer"));
diff -uNr arts-1.4.0/x11/Makefile.am arts-1.4.0-new/x11/Makefile.am
--- arts-1.4.0/x11/Makefile.am	2005-01-03 09:24:21.000000000 -0500
+++ arts-1.4.0-new/x11/Makefile.am	2005-05-10 08:12:35.000000000 -0400
@@ -6,7 +6,7 @@
 
 libx11globalcomm_la_SOURCES = x11globalcomm.cc x11globalcomm_impl.cc
 libx11globalcomm_la_LIBADD = $(top_builddir)/mcop/libmcop.la $(LIB_X11)
-libx11globalcomm_la_LDFLAGS = -no-undefined -module -version-info 1:0 $(X_LDFLAGS) $(all_libraries)
+libx11globalcomm_la_LDFLAGS = -no-undefined -module -version-info 1:0 $(all_libraries) $(X_LDFLAGS)
 
 DISTCLEANFILES = x11globalcomm.cc x11globalcomm.h \
                  x11globalcomm.mcoptype x11globalcomm.mcopclass

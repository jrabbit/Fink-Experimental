diff -Nurd -x'*~' mapm3-source.orig/Makefile mapm3-source/Makefile
--- mapm3-source.orig/Makefile	1993-02-10 01:12:59.000000000 -0500
+++ mapm3-source/Makefile	2006-06-09 02:57:30.000000000 -0400
@@ -24,7 +24,7 @@
 #### datasets (roughly 5000 loci vs 1000 loci). For even bigger datasets, 
 #### modify mapm/mapm.h.
 
-SYS= -D_SYS_SUNOS
+SYS= -D_BIG_DATASETS
 
 #### Next define the system libraries to link with Mapmaker. On SunOS, Ultrix
 #### and other vanilla-ish BSD systems, the correct setting is:
@@ -35,7 +35,7 @@
 #### is probably best (for ex: on A/UX or HP/UX, respectively). 
 #### On A/UX -lmalloc is likely a good idea too.
 
-SYS_LIBS= -lm -ltermcap
+SYS_LIBS= -ltermcap
 
 #### Below we define the directories for these programs. Set DIR to the place
 #### in which the executables and help files should permanently be installed
@@ -70,9 +70,9 @@
 #### (see the end of readline/readline.c). Readline will not compile on
 #### A/UX without using GCC instead of A/UX's cc (because it needs alloca).
 
-OUR_LIB= gnu.o
-GNU_OPT= -D_GNU_READLINE -I.
-GNU_LIBS= -L$(RDLN) -lreadline
+OUR_LIB= lib.o
+GNU_OPT= 
+GNU_LIBS= 
 
 #### Now we specify the commands used to compile MAPMAKER.  The stuff
 #### below works on Sun SPARCStations running SunOS 4.1.x (aka Solaris 1.x)
@@ -82,8 +82,8 @@
 #### person at your site should be able to figure out what to do almost
 #### trivially. See the file INSTALL.ME for details. 
 
-COMPILE= cc
-LINKALL= cc
+COMPILE= cc -fwritable-strings -Wall
+LINKALL= cc -Wl,-stack_size -Wl,4048000 -Wall
 LINKLIB= ld -r
 DELETE=  rm -f
 INSTALL= cp
@@ -249,7 +249,7 @@
 	$(LINTALL) $(MAPM_LN)   $(LIB_LN) $(SYS_LIBS)   >Temp.lint
 	echo "=======================================" >>Temp.lint
 	fgrep -v -f Lint.grep Temp.lint $(MAPM_LINT) $(LIB_LINT) >mapm.lint
-		
+
 .c.ln:
 	$(LINT) -I$(LIB) $(SYS) -c $< -o $*.ln >$*.lint
 
diff -Nurd -x'*~' mapm3-source.orig/lib/eqn.c mapm3-source/lib/eqn.c
--- mapm3-source.orig/lib/eqn.c	1993-02-09 11:35:23.000000000 -0500
+++ mapm3-source/lib/eqn.c	2006-06-09 00:47:39.000000000 -0400
@@ -250,7 +250,7 @@
 EQUATION **parsed_eqn;
 int mark,parsed_token, *new_size, *the_index;
 {
-    int t, var_index;
+    int t;
         
     if (mark == VARIABLE) {
 	parsed_eqn[*the_index]->is_a = mark;
@@ -348,7 +348,7 @@
 void postfix(parsed_eqn, postfixed)
 EQUATION **parsed_eqn, **postfixed;
 {
-    int i,kj,parsed_index=0, temp_index=0, post_index=0;
+    int i,parsed_index=0, temp_index=0, post_index=0;
     EQUATION **temp_eqn;
     
     array(temp_eqn,MAX_EQN_SIZE,EQUATION*);
@@ -400,7 +400,6 @@
 real (*value_find)();
 {
     int i, missing = FALSE;
-    char *symbol;
     real number_to_use,c,exponent, divisor, var_push,subtract, value_lookup();
     i=0;
     stack_pointer = 0;
@@ -527,7 +526,6 @@
 
 void eqn_init()
 {
-    int i;
 
    
     
diff -Nurd -x'*~' mapm3-source.orig/lib/iolib.c mapm3-source/lib/iolib.c
--- mapm3-source.orig/lib/iolib.c	1993-02-09 11:35:24.000000000 -0500
+++ mapm3-source/lib/iolib.c	2006-06-09 03:04:04.000000000 -0400
@@ -19,6 +19,7 @@
 #define INC_HELP_DEFS
 #include "system.h"
 #include "shell.h" /* just to get the decl of error()? */
+#include "misclib.h"
 
 /***** globals- see descriptions in iolib.h *****/
 char *ps, *ps_, *ln, *ln_; 
@@ -75,7 +76,6 @@
 FILE *fp;
 char **name, *modechar; /* side-effected if non-null */
 {
-    int i;
     
     if (fp==NULL) { 
 	if (name!=NULL) *name= null_string;
@@ -313,7 +313,6 @@
 FILE *fp;
 int *count;
 {
-    int i;
     char *p;
 
     if (fp==stdin) { getln("? "); if (count!=NULL) ++*count; return; }
@@ -385,7 +384,6 @@
    always start dumping into the left column. Thus clear_screen works right. */
 {
     int i;
-    bool did_early_more;
     
     if (held[hold_count][0]!='\0') 
       { hold_count++; held[hold_count][len(held[hold_count])-1]='\n'; }
@@ -654,7 +652,6 @@
 bool temp_print(simple_str,fancy_str)
 char *simple_str, *fancy_str;
 {
-    int i, chrs, pos;
     char *str;
 
     /* If the last print command was not temp_print(), we must first get the
@@ -779,7 +776,7 @@
 
 void review_memory() 
 {
-    int i, old_photo, old_more, start, num, old_memory;
+    int i, old_photo, start, num, old_memory;
 
     if (memory_end==0 && !memory_wrapped) return;
     if (more_break_pending) if (!really_do_more()) send(INTERRUPT);
@@ -861,7 +858,7 @@
 char *prompt, *str;		
 int length;			
 {				
-    int l; bool eof;
+    bool eof;
     more_break_pending= FALSE; eof= FALSE; 
 
     if (redirs==0) { /* it's not redirected via redirect_input() */
@@ -902,12 +899,12 @@
 
 /* edit_line(): essentially the same rules as input() */
 
-bool edit_line(prompt,str,length,initial)
+void edit_line(prompt,str,length,initial)
 char *prompt, *str;
 int length;			
 char *initial;
 {				
-    int l; bool eof;
+    bool eof;
     more_break_pending= FALSE; eof= FALSE; 
 
     if (interactive && redirs==0 && use_gnu_readline) {
diff -Nurd -x'*~' mapm3-source.orig/lib/iolib.h mapm3-source/lib/iolib.h
--- mapm3-source.orig/lib/iolib.h	1993-02-09 11:35:27.000000000 -0500
+++ mapm3-source/lib/iolib.h	2006-06-09 03:07:54.000000000 -0400
@@ -168,6 +168,7 @@
    Ignore_eof is on whether the standard input is a terminal or not. 
    All are set by tty_init() and get_cmd_line_args() */
 
+bool do_hold();
 #define hold(with_more_on) \
   for (do_hold(TRUE,with_more_on); holding>0; do_hold(FALSE,FALSE))
 extern int holding;
@@ -371,7 +372,7 @@
 bool do_delete_previous_line();
 bool do_cursor_left(); /* args int spaces; char *str_to_then_print; */
 #define FAR_LEFT -1
-bool check_tty_lines();
+void check_tty_lines();
 
 void lib_puts();
 bool tty_gets();
@@ -414,5 +415,5 @@
 bool do_gnu_edit();
 bool gnu_copyright();
 
-bool edit_line(); /* make real decl above */
+void edit_line(); /* make real decl above */
 
diff -Nurd -x'*~' mapm3-source.orig/lib/makehelp.c mapm3-source/lib/makehelp.c
--- mapm3-source.orig/lib/makehelp.c	1993-02-09 16:19:35.000000000 -0500
+++ mapm3-source/lib/makehelp.c	2006-06-09 01:02:02.000000000 -0400
@@ -267,7 +267,7 @@
 int kind;
 char *name, *abbrev;
 {
-    bool rest=FALSE, need_break;
+    bool rest=FALSE;
     int i;
     STRING line, key;
 
@@ -409,7 +409,7 @@
 
 void write_topics_and_end()
 {
-    int i, s, k;
+    int i, s;
     STRING temp;
     if (!make_man) return;
 
diff -Nurd -x'*~' mapm3-source.orig/lib/mathlib.c mapm3-source/lib/mathlib.c
--- mapm3-source.orig/lib/mathlib.c	1993-02-09 11:35:24.000000000 -0500
+++ mapm3-source/lib/mathlib.c	2006-06-09 00:28:57.000000000 -0400
@@ -337,7 +337,8 @@
    its left square will be left with the result (ignore the right side) */
 {
     int row, col, c, twice_size;
-    real diff, value;
+/*    real diff; OLD */
+    real value;
     
     twice_size= 2 * size;
     for (row=0; row<size; row++)
diff -Nurd -x'*~' mapm3-source.orig/lib/mathlib.h mapm3-source/lib/mathlib.h
--- mapm3-source.orig/lib/mathlib.h	1993-02-09 11:35:27.000000000 -0500
+++ mapm3-source/lib/mathlib.h	2006-06-09 04:12:59.000000000 -0400
@@ -49,6 +49,7 @@
 int  ipow();  /* arg: int x,i; returns x to the i, for small x,i */
 long lpow2(); /* arg: int i;   returns 2 to the i, for i<=31*/
 int  ipow2(); /* arg: int i;   returns 2 to the i, for i<=15*/
+int ichoose();
 
 
 /* Remember, its a no-no to change any of these defs! VAX is the smallest! */
diff -Nurd -x'*~' mapm3-source.orig/lib/memlib.c mapm3-source/lib/memlib.c
--- mapm3-source.orig/lib/memlib.c	1993-02-09 11:35:25.000000000 -0500
+++ mapm3-source/lib/memlib.c	2006-06-09 00:39:10.000000000 -0400
@@ -26,9 +26,9 @@
 int yy, zz;
 
 #define ALLOC_MSG \
-	"alloc:\t%dx%d\tbytes @ %8lxH. total bytes alloced=%ld\n"
+	"alloc:\t%zdx%zd\tbytes @ %8lxH. total bytes alloced=%ld\n"
 #define ALLOC_FAIL_MSG \
-	"FAILED:\t%dx%d\tbytes              total bytes alloced=%ld\n"
+	"FAILED:\t%zdx%zd\tbytes              total bytes alloced=%ld\n"
 
 CALLOC_PTR_TO *xalloc(num,cell_sizeof)
 CALLOC_NUM_TYPE num;
diff -Nurd -x'*~' mapm3-source.orig/lib/misclib.h mapm3-source/lib/misclib.h
--- mapm3-source.orig/lib/misclib.h	1993-02-09 11:35:27.000000000 -0500
+++ mapm3-source/lib/misclib.h	2006-06-09 03:04:59.000000000 -0400
@@ -32,6 +32,8 @@
 bool get_directory();     /* args: char *str; str>=PATH_LENGTH+1 chars */
 bool change_directory();  /* args: char *str; str is directory name */
 
+bool get_home_directory();
+bool get_code_directory();
 
 /***** SORT OPERATIONS FOR SIMPLE ARRAYS (code is in mathlib.c) *****/
 
diff -Nurd -x'*~' mapm3-source.orig/lib/shell.c mapm3-source/lib/shell.c
--- mapm3-source.orig/lib/shell.c	1993-02-09 11:35:25.000000000 -0500
+++ mapm3-source/lib/shell.c	2006-06-09 02:22:46.000000000 -0400
@@ -184,7 +184,6 @@
 /* help_filename must be side-effectable */
 {
     int i;
-    char *full_name[PATH_LENGTH+1];
     
     array(cmd, MAX_COMMANDS, COMMAND*);
     array(matched, MAX_COMMANDS, bool);
@@ -359,7 +358,7 @@
 bool valid_name(str) /* checks the syntax of names */
 char *str;
 { 
-  int i;  char *token;
+  int i;
 
   if (!is_a_token(str)) return(FALSE);
   if (strin(NAME_TAG_CHARS,str[0])) str++;
@@ -380,7 +379,7 @@
 char **rest; /* side-effected */
 bool help_ok;
 { 
-    int i, j, n_tokens, last_match;
+    int i, n_tokens, last_match;
     char *foo;
     extern char **tokens, **remaining; /* temps */
     extern int *matched, num_matched;
@@ -478,7 +477,7 @@
 char **in_tokens, **com_tokens;
 int num_to_match, *exact;
 {
-    int i,j;
+    int i;
 	
     for (i=0, *exact=TRUE; i<num_to_match; i++) 
       if (!matches(in_tokens[i],com_tokens[i])) return(FALSE);
@@ -497,7 +496,7 @@
 char *line; /* line IS side-effected */
 {
     char *str, *save;
-    int num, first, foo, i;
+    int num, first, i;
 
     /* The cmd_history num will NOT have been incremented between the call
        to prompt and here! Also remember that 1+ that number is printed. */
@@ -1042,7 +1041,7 @@
 
 		    if (!nullstr(cmd[i]->abbreviation)) 
 		      sf(str,"%s (%s)",cmd[i]->name,cmd[i]->abbreviation);
-		    else sf(str,"%s",cmd[i]->name,"");
+		    else sf(str,"%s",cmd[i]->name);
 		    if (!nullstr(cmd[i]->cmd_help)) {
 			for (k=len(str); k<HELP_LEFT; k++) str[k]='.'; 
 			str[HELP_LEFT]='\0';
@@ -1059,7 +1058,7 @@
 		      { print("\nOTHER COMMANDS:\n"); got_any=TRUE; }
 		    if (!nullstr(cmd[i]->abbreviation))
 		      sf(ps,"%s (%s)\n",cmd[i]->name,cmd[i]->abbreviation);
-		    else sf(ps,"%s\n",cmd[i]->name,"");
+		    else sf(ps,"%s\n",cmd[i]->name);
 		    pr();
 		}
 	    }
diff -Nurd -x'*~' mapm3-source.orig/lib/strlib.c mapm3-source/lib/strlib.c
--- mapm3-source.orig/lib/strlib.c	1993-02-09 11:35:26.000000000 -0500
+++ mapm3-source/lib/strlib.c	2006-06-09 00:33:51.000000000 -0400
@@ -181,7 +181,6 @@
 char *s1, *s2;
 {
     int i, j, preceeding_space;
-    char c, d;
 	
     i=0; j=0; 
     while (white(s1[i]) || trash(s1[j])) i++;
diff -Nurd -x'*~' mapm3-source.orig/lib/strlib.h mapm3-source/lib/strlib.h
--- mapm3-source.orig/lib/strlib.h	1993-02-09 11:35:28.000000000 -0500
+++ mapm3-source/lib/strlib.h	2006-06-09 04:26:38.000000000 -0400
@@ -198,6 +198,7 @@
 int count_tokens();  /* args: char *str; */
 bool is_a_token();   /* args: char *str; must be despaced, or from stoken() */
 bool split_string(); /* args: char *str, **rest, divider; rest side-effected */
+int field();
 
 
 /****************************************************************************
diff -Nurd -x'*~' mapm3-source.orig/lib/syscode.c mapm3-source/lib/syscode.c
--- mapm3-source.orig/lib/syscode.c	1993-02-09 11:35:26.000000000 -0500
+++ mapm3-source/lib/syscode.c	2006-06-09 02:18:42.000000000 -0400
@@ -63,7 +63,12 @@
 bool shell_command(cmd) 
 char *cmd; 
 { 
-    bool success, had_curses;
+  bool success;
+#ifndef NO_SYSTEM_FUNC
+#ifdef HAVE_CURSES
+  bool had_curses;
+#endif
+#endif
     success=FALSE;
 
 #ifdef NO_SYSTEM_FUNC
@@ -91,7 +96,12 @@
 bool subshell()
 {
         char *shell_name, cmd[120];
-	bool success=FALSE, had_curses;
+	bool success=FALSE;
+#ifndef NO_SYSTEM_FUNC
+#ifdef HAVE_CURSES
+	bool had_curses;
+#endif
+#endif
 	
 #ifdef NO_SYSTEM_FUNC
     return(FALSE);
@@ -231,7 +241,7 @@
 {
     /* if (msg!=IOERROR) flush(); most are disk errors */
     if (msg<1 || msg>MSGS) 
-      { fprintf(stderr, "Untrapped error %d (???)\n",msg); exit(1); }
+      { fprintf(stderr, "Untrapped error %d (%s)\n",msg,"???"); exit(1); }
     fprintf(stderr,"Untrapped error %d (%s)\n",msg,mname[msg]);
     (*(mstrmsg[msg]))(ps_); fprintf(stderr,ps_); fprintf(stderr,"\n");
 }
@@ -240,7 +250,7 @@
 {
     /* if (msg!=IOERROR) flush(); most are disk errors */
     if (msg<1 || msg>MSGS) 
-      { fprintf(stderr,"Error %d (???)\n",msg); exit(1); }
+      { fprintf(stderr,"Error %d (%s)\n",msg,"???"); exit(1); }
     fprintf(stderr,"Error %d (%s)\n",msg,mname[msg]);
     (*(mstrmsg[msg]))(ps_); fprintf(stderr,ps_); fprintf(stderr,"\n");
 }
@@ -252,7 +262,7 @@
 void verbose_untrapped_msg() /* DO NOT ASSUME THAT MSGNAME IS SET! */
 {
   fprintf(stderr,"*** Drats! An unhandled internal error occured. ***\n");
-  if (msg<1 || msg>MSGS) { fprintf(stderr,"error #%d (???)\n",msg); exit(1); }
+  if (msg<1 || msg>MSGS) { fprintf(stderr,"error #%d (%s)\n",msg,"???"); exit(1); }
     else fprintf(stderr,"Error message #%d (%s) was sent.\n",msg,mname[msg]);
   (*(mstrmsg[msg]))(ps_); fprintf(stderr,ps_); 
   if (!nullstr(ps_)) fprintf(stderr,"\n");
@@ -535,7 +545,7 @@
 }
 
 
-bool check_tty_lines() /* return TRUE and set tty_lines if changed */
+void check_tty_lines() /* return TRUE and set tty_lines if changed */
 {
 /* maybe add some weird PC thing here to get #lines */
 #ifdef TRY_WINSIZE
@@ -716,11 +726,45 @@
 #define NOTSCREEN_ \
 { fprintf(stderr,ERROR_NOTSCREEN,argv[0],argv[i]); abnormal_exit(); }
 
+void check_file_arg(num,arg,name,type,def_ext,prog,mode)
+int num;
+char *arg, *name, *type, *def_ext, *prog, *mode;
+{
+    char file[PATH_LENGTH+1];
+    FILE *fp;
+
+    if (!nullstr(name)) {
+	fprintf(stderr,ERROR_ONEFILE,prog,type); 
+	abnormal_exit();
+    }
+    nstrcpy(file,arg,PATH_LENGTH);
+    if (!make_filename(file,DEFAULT_EXTENSION,def_ext)) {
+	fprintf(stderr,ERROR_BADFILE,prog,type,file); 
+	abnormal_exit();
+    }
+    run {
+	fp=open_file(file,mode);
+	close_file(fp);
+	strcpy(name,file);
+    } except {
+	when IOERROR: 
+	when CANTOPEN:
+	when CANTCLOSE:
+	  fprintf(stderr,ERROR_NOFILE,prog,type,file);
+	  abnormal_exit();
+	when ENDOFILE:
+	  fprintf(stderr,ERROR_EMPTYFILE,prog,type,file);
+	  abnormal_exit();
+	default: 
+	  relay; 
+    }
+}
+
 void get_cmd_line_args(argc_ptr,argv)
 int *argc_ptr;
 char *argv[];
 {
-    int i, n;
+    int i;
 
     for (i=1; i<*argc_ptr; i++) {
 	if (argv[i][0]!=ARG_CHAR) {
@@ -778,41 +822,6 @@
 }
 
 
-bool check_file_arg(num,arg,name,type,def_ext,prog,mode)
-int num;
-char *arg, *name, *type, *def_ext, *prog, *mode;
-{
-    char file[PATH_LENGTH+1];
-    FILE *fp;
-
-    if (!nullstr(name)) {
-	fprintf(stderr,ERROR_ONEFILE,prog,type); 
-	abnormal_exit();
-    }
-    nstrcpy(file,arg,PATH_LENGTH);
-    if (!make_filename(file,DEFAULT_EXTENSION,def_ext)) {
-	fprintf(stderr,ERROR_BADFILE,prog,type,file); 
-	abnormal_exit();
-    }
-    run {
-	fp=open_file(file,mode);
-	close_file(fp);
-	strcpy(name,file);
-    } except {
-	when IOERROR: 
-	when CANTOPEN:
-	when CANTCLOSE:
-	  fprintf(stderr,ERROR_NOFILE,prog,type,file);
-	  abnormal_exit();
-	when ENDOFILE:
-	  fprintf(stderr,ERROR_EMPTYFILE,prog,type,file);
-	  abnormal_exit();
-	default: 
-	  relay; 
-    }
-}
-
-
 bool update_top()
 { return(FALSE); }
 
diff -Nurd -x'*~' mapm3-source.orig/lib/system.h mapm3-source/lib/system.h
--- mapm3-source.orig/lib/system.h	1993-02-09 11:35:28.000000000 -0500
+++ mapm3-source/lib/system.h	2006-06-09 00:18:40.000000000 -0400
@@ -94,13 +94,23 @@
 #endif
 
 
+#define _SYS_UNIX
+#define SIGHANDLE void
+#define USE_DRAND48
+#define CALLOC_PTR_TO void
+#define CALLOC_NUM_TYPE size_t
+#define SIZEOF_TYPE size_t
+#define QSORT_LENGTH size_t
+#define QSORT_DATA_PTR_TO void
+#define INC_LIB
 
 /************************ File name syntax ****************************
 Setup the following for the OS's path types (these are used by the 
 make_filename() procedure in iolib.c). Note that the lengths of various 
 elements of a path are not checked, only its total length.
 *************************************************************************/
-#define PATH_LENGTH		200
+#include <sys/param.h>
+#define PATH_LENGTH		MAXPATHLEN
 
 #ifndef _SYS_DOS /* e.g. _SYS_UNIX or some POSIX like thing */
 #define HELP_EXT                ".help"
@@ -583,7 +593,6 @@
 #include <signal.h> 
 #include <errno.h> 	
 #include <time.h>       /* for ctime() def - Who does not have this file? */
-#include <malloc.h>
 #include <sys/types.h>
 
 #ifdef TRY_WINSIZE
@@ -598,8 +607,6 @@
 
 /* The HPUX (and System V?) random number functions... ditto */
 #ifdef USE_DRAND48
-double drand48(); 
-void srand48(); 
 #endif
 
 /* Library declarations only to be used by the helpers library code itself */
diff -Nurd -x'*~' mapm3-source.orig/lib/table.c mapm3-source/lib/table.c
--- mapm3-source.orig/lib/table.c	1993-02-09 11:35:26.000000000 -0500
+++ mapm3-source/lib/table.c	2006-06-09 02:24:28.000000000 -0400
@@ -124,8 +124,7 @@
 char *name, *str;
 TABLE *p; /* side-effected */
 {
-    TABLE_ENTRY *last, *match, *q;
-    int num_matched;
+    TABLE_ENTRY *last, *q;
 
     if (!p->named_entries || !valid_name(name)) send(CRASH);
 
@@ -158,7 +157,6 @@
 flag *fail_reason; /* side-effected */
 {
     TABLE_ENTRY *q;
-    int num_matched;
 
     /* Changed to allow only exact matches */
     if (!p->named_entries || !is_a_token(name)) send(CRASH);
@@ -179,7 +177,6 @@
 flag *fail_reason;
 {
     TABLE_ENTRY *match, *match_prev, *q;
-    int num_matched;
 
     if (!p->named_entries || !is_a_token(name)) send(CRASH);
     for (match=match_prev=NULL, q=p->list; q!=NULL; q=q->next) {
@@ -236,7 +233,7 @@
 bool delete_numbered_entry(num,p)
 int num;
 TABLE *p;
-{ send(CRASH); /* NOT IMPLEMENTED */ }
+{ send(CRASH); /* NOT IMPLEMENTED */ return(FALSE); }
 
 
 void save_table(p,fp,index)
@@ -244,8 +241,6 @@
 FILE *fp;
 int index;
 {
-    char *str,*name;
-    int num;
 
     if(index == INDEX_BY_NAME) {
 	for(Te=p->list; Te!=NULL; Te=Te->next) {
@@ -265,7 +260,7 @@
 FILE *fp;
 int index;
 {
-    char *str=NULL, *ptr, name[TOKLEN+1], *err;
+    char *str=NULL, *ptr, name[TOKLEN+1];
     int num,i;
 
     run {
diff -Nurd -x'*~' mapm3-source.orig/mapm/auto_cmd.c mapm3-source/mapm/auto_cmd.c
--- mapm3-source.orig/mapm/auto_cmd.c	1993-02-09 11:35:02.000000000 -0500
+++ mapm3-source/mapm/auto_cmd.c	2006-06-09 01:37:12.000000000 -0400
@@ -97,7 +97,7 @@
 {
     MAP *map, *old;
     char title[TOKLEN+1];
-    int i, chrom, num_loci;
+    int chrom, num_loci;
 
     mapm_ready(ANY_DATA,MAYBE_SEQ,ONE_ORDER,&num_loci);
     chrom=get_chrom_arg(FALSE);
@@ -248,7 +248,7 @@
 
 command attach()
 {
-    int total_loci, i, chrom, n_loci, *locus=NULL;
+    int i, chrom, n_loci, *locus=NULL;
 
     mapm_ready(ANY_DATA,1,UNCRUNCHED_LIST,&n_loci);
     chrom=get_chrom_arg(FALSE);
@@ -278,7 +278,7 @@
 
 command unassign()
 {
-    int n_loci, i, j, k, *locus=NULL;
+    int n_loci, i, *locus=NULL;
 
     mapm_ready(ANY_DATA,1,UNCRUNCHED_LIST,&n_loci);
     nomore_args(0);
@@ -306,10 +306,10 @@
 #define NPT_WINDOW 5
 command place()
 {
-    int  chrom, i, j, left, right;
+    int  chrom, i, left, right;
     int  *locus=NULL, n_loci, *chrom_locus=NULL, n_to_place, n_allowed;
     int  *chrom_all=NULL, n_chrom, n_frame, n_to_punt;
-    real npt_thresh, diff;
+    real npt_thresh;
     bool got_any, ok;
     PLACE **placements=NULL;
     PLACEME **unplaced=NULL;
@@ -435,11 +435,9 @@
 
 command show_chrom()
 {
-    int chrom, i, j;
-    bool found_in_frame, found;
+    int chrom;
     int *marker=NULL, num_markers, **placement_state=NULL;
-    char name[TOKLEN+1], title[TOKLEN+1];
-    MAP *map=NULL;
+    char title[TOKLEN+1];
 
     mapm_ready(ANY_DATA,0,0,NULL);
     chrom=get_chrom_arg(FALSE);
@@ -481,11 +479,11 @@
 
 command place_together()
 {
-    int  chrom, i, j, left, right;
-    int  *locus=NULL, n_loci, *chrom_locus=NULL, n_to_place, n_allowed;
-    int  *chrom_all=NULL, n_chrom, n_frame, n_to_punt, n_unplaced, num, prev;
-    real npt_thresh, diff;
-    bool got_any, ok;
+    int  chrom, i;
+    int  *locus=NULL, n_loci, *chrom_locus=NULL, n_to_place;
+    int  *chrom_all=NULL, n_chrom, n_frame, n_unplaced, num, prev;
+    real npt_thresh;
+    bool got_any;
     PLACEME **unplaced=NULL;
     MAP *order=NULL, *frame; /* frame is NOT malloced */
   
@@ -631,7 +629,6 @@
 
 command draw_all_chromosomes()
 {
-    int chrom;
     char name[PATH_LENGTH+1];
     FILE *fp=NULL;
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/chroms.c mapm3-source/mapm/chroms.c
--- mapm3-source.orig/mapm/chroms.c	1993-02-09 11:35:02.000000000 -0500
+++ mapm3-source/mapm/chroms.c	2006-06-09 01:56:45.000000000 -0400
@@ -72,7 +72,7 @@
 bool framework_marker(locus)
 int locus;
 {
-    int j, k, found_in_frame;
+    int j/*, k */;
     MAP *frame;
 
     /* force_haplo_sanity(&locus,FALSE); */
@@ -446,8 +446,8 @@
 real lod1, unlinked_lod1, theta1, lod2, unlinked_lod2, theta2;
 bool haplo;
 {
-    int i, j, state, num_chroms;
-    bool assigned_any, do_changed_only;
+    int i, state, num_chroms;
+    bool assigned_any /*, do_changed_only */;
     int **anchor=NULL, *count=NULL;
     real lod, unlinked_lod, theta;
 
@@ -640,7 +640,6 @@
 bool is_placeable(locus,chrom)
 int locus, chrom;
 {
-    int framework, old_chrom, k;
     
     /* unplace_this() helps to clean up the placement structure, when this 
        is called by place or place_together */
@@ -937,8 +936,8 @@
 void read_mapping_data(fp)
 FILE *fp;
 {
-    int locus, num, chrom_num, i, j, num_chroms;
-    real rnum, rnum2;
+    int locus, num, i, j, num_chroms;
+    real rnum;
     char word[TOKLEN+1], temp_locus_name[NAME_LEN+2];
     MAP  *map;
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/ctm.c mapm3-source/mapm/ctm.c
--- mapm3-source.orig/mapm/ctm.c	1993-02-09 11:35:02.000000000 -0500
+++ mapm3-source/mapm/ctm.c	2006-06-09 02:30:00.000000000 -0400
@@ -250,7 +250,6 @@
 void converge_to_map(map)
 MAP *map;
 {
-    int i, hmm;
 
     if (map==NULL || map->num_loci<2 || raw.data_type!=F2) send(CRASH);
     if (map->num_loci>MAX_MAP_LOCI) 
@@ -321,8 +320,7 @@
 int *num_dom, *num_het; /* side-effected */
 int *observation; /* array of raw.num_indivs observations */
 {
-    int homo, het, dom, missing, num_inf, j;
-    real rhomo, rhet, rdom, rinf;
+    int homo, het, dom, missing, j;
 
     homo= het= dom= missing= 0;
     for (j=0; j<raw.data.f2.num_indivs; j++)
@@ -344,7 +342,7 @@
 void hmm_converge_to_map(map)
 MAP *map;
 {
-    int iter, i;
+    int iter;
     int testing, one;
     real old_like, new_like;
 
@@ -396,7 +394,7 @@
 void setup_hmm(map)
 MAP *map;
 {
-    int i, type;
+    int type;
 
     n_loci=map->num_loci; 
     n_intervals=n_loci-1;
@@ -420,7 +418,7 @@
 int cross_type;
 {
     int i, j, k, obs;
-    real total, **recs, **norecs, error_prob;
+    real **recs, **norecs, error_prob;
 
     max_states=2; 	/* STATE_A or _B */
     max_observations=3; /* OBS_A, _H, or _MISSING (yup, this is odd for BC) */
@@ -609,8 +607,7 @@
 int *locus; /* The locus numbers in the sequence */
 {
     int i, j, k, the_obs;
-    real total, recs;
-    int x, y;
+    real recs;
     int a[3], b[3], h[3], n[3], aa, ab, ah, ba, bb, bh, ha, hb, hh;
     
     max_states=16; f3_states=0;	 
@@ -755,7 +752,7 @@
 real ***implied_recs;  /* [interval][from_state][to_state] side-effected */
 /* for now, assume obs_probs are fixed and initialized by setup_hmm() */
 {
-    int i, k, j;
+    int i;
     real rec, norec, theta;
     real **prob;
 
@@ -790,9 +787,9 @@
 real ***implied_recs;  /* [interval][from_state][to_state] side-effected */
 /* for now, assume obs_probs are fixed and initialized by setup_hmm() */
 {
-    int i, k, j;
+    int i;
     real theta, one_minus_theta, no_recs, one_rec, two_recs;
-    real **prob, recs, total;
+    real **prob, recs;
 
     /* set the trans_probs (right geno, conditional on left) given theta */
     for (i=0; i<n_intervals; i++) {
@@ -873,7 +870,6 @@
 SUFF_STATS **sufficient_stats; /* [locus] => ptr to struct (recs,norecs)... */
 {
     int i, k, j;
-    int state, left, right;    
     real **transitions_exp, **recs_implied, **norecs_implied;
     real recs, norecs;
 
@@ -941,9 +937,6 @@
     real indiv_like, total_like;
     real **the_transitions, **my_transitions, *temp, **the_trans_prob;
 
-    /* debugging */
-    int x, y;
-    real r, n;
 
     /* Sometime unroll array refs in here for a little speed */
 
@@ -1147,7 +1140,7 @@
 real **p;
 char *name;
 {
-    int i, j, k, n;
+    int j, k, n;
 
     n= n_intervals > 1 ? 3:2;
     printf("=== %s ===\n    ",name);
@@ -1173,7 +1166,7 @@
 real ***obs_prob;         /* [locus#][observation][state] */
 real **error_lod;         /* [locus#][indiv] side-effected */
 {
-    real apostiori_rate, state_prob, e1, e2, like;
+    real apostiori_rate, e1, e2, like;
     int i, j, state, the_obs;
 
     for (j=0; j<n_indivs; j++) {
diff -Nurd -x'*~' mapm3-source.orig/mapm/database.c mapm3-source/mapm/database.c
--- mapm3-source.orig/mapm/database.c	1993-02-09 11:35:02.000000000 -0500
+++ mapm3-source/mapm/database.c	2006-06-09 00:23:49.000000000 -0400
@@ -23,12 +23,11 @@
 
 command import()
 {
+#ifndef NO_DATABASE
     char *out_name, *str, first_token[TOKLEN+1];
     int length, prev_data, filenum;
     FILE *fp=NULL;
 
-#ifndef NO_DATABASE
-
     /* command initialization */
     mapm_ready(MAYBE_DATA, 0, 0, NULL);
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/info.c mapm3-source/mapm/info.c
--- mapm3-source.orig/mapm/info.c	1993-02-09 11:35:03.000000000 -0500
+++ mapm3-source/mapm/info.c	2006-06-09 03:50:53.000000000 -0400
@@ -112,7 +112,6 @@
 int a, b;
 bool *used_needs_incrementing;
 {
-    int i;
     TWO_PT_DATA *p;
     
     if (two_pt_data[a][b]!=NULL && two_pt_data[a][b]!=UNLINKED_TWO_PT) {
@@ -340,6 +339,39 @@
     save_triple(loc1,loc2,loc3,d1,d2,d3);
 }
 
+bool get_triple(locus1,locus2,locus3,d1,d2,d3)
+int locus1,locus2,locus3;
+real *d1,*d2,*d3;
+{
+    TRIPLE_LIST *p;
+
+    if (three_pt_data->entry[locus1].locus2 == locus2) {
+        if (three_pt_data->entry[locus1].locus3 == locus3) {
+	    *d1= (real) three_pt_data->entry[locus1].delta1;
+	    *d2= (real) three_pt_data->entry[locus1].delta2;
+	    *d3= (real) three_pt_data->entry[locus1].delta3;
+	    return(TRUE);
+	} else {
+	    if (!same_2_loop(three_pt_data->entry[locus1].next_same2,locus3,
+			     d1,d2,d3))
+	      return(FALSE);
+	    else
+	      return(TRUE);
+	}
+    } else {
+	p= three_pt_data->entry[locus1].next;
+	if (p == NULL) return(FALSE);
+	while(p->locus2 != locus2) {
+	    if (p->next == NULL)
+	      return(FALSE);
+	    p= p->next;
+	}
+	if (!same_2_loop(p,locus3,d1,d2,d3))
+	  return(FALSE);
+	else
+	  return(TRUE);
+    }
+}
 
 void save_triple(locus1,locus2,locus3,d1,d2,d3)
 int locus1,locus2,locus3;
@@ -542,39 +574,6 @@
 }
 
 
-bool get_triple(locus1,locus2,locus3,d1,d2,d3)
-int locus1,locus2,locus3;
-real *d1,*d2,*d3;
-{
-    TRIPLE_LIST *p;
-
-    if (three_pt_data->entry[locus1].locus2 == locus2) {
-        if (three_pt_data->entry[locus1].locus3 == locus3) {
-	    *d1= (real) three_pt_data->entry[locus1].delta1;
-	    *d2= (real) three_pt_data->entry[locus1].delta2;
-	    *d3= (real) three_pt_data->entry[locus1].delta3;
-	    return(TRUE);
-	} else {
-	    if (!same_2_loop(three_pt_data->entry[locus1].next_same2,locus3,
-			     d1,d2,d3))
-	      return(FALSE);
-	    else
-	      return(TRUE);
-	}
-    } else {
-	p= three_pt_data->entry[locus1].next;
-	if (p == NULL) return(FALSE);
-	while(p->locus2 != locus2) {
-	    if (p->next == NULL)
-	      return(FALSE);
-	    p= p->next;
-	}
-	if (!same_2_loop(p,locus3,d1,d2,d3))
-	  return(FALSE);
-	else
-	  return(TRUE);
-    }
-}
 
 
 bool same_2_loop(p,locus3,d1,d2,d3)
@@ -763,7 +762,7 @@
 void bash_order_info(changed,num_changed)
 int *changed, num_changed;
 {
-    int a, b, i, j, locus;
+    int a, b, i, j;
     TRIPLE_LIST *p, *q, *prev;
     /* this is merciless - might do *something* smarter */
 
@@ -1110,7 +1109,7 @@
 void read_three_pt(fp)
 FILE *fp;
 {
-    int i,j,k,filenum;
+    int i,j,k;
     real d1,d2,d3;
 
     while((fscanf(fp,"%d %d %d %lf %lf %lf\n",&i,&j,&k,&d1,&d2,&d3)) == 6) {
@@ -1123,7 +1122,7 @@
 void write_three_pt(fp)  
 FILE *fp;
 {
-    int i, j;
+    int i;
     TRIPLE_LIST *p;
 
     for (i= 0; i < raw.num_markers; i++) {
diff -Nurd -x'*~' mapm3-source.orig/mapm/main.c mapm3-source/mapm/main.c
--- mapm3-source.orig/mapm/main.c	1993-02-09 16:10:42.000000000 -0500
+++ mapm3-source/mapm/main.c	2006-06-09 02:02:20.000000000 -0400
@@ -20,11 +20,11 @@
 void make_help_entries();    /* move these to lib */
 extern char help_filename[];
 
-main(argc,argv)
+int main(argc,argv)
 int argc;
 char *argv[];
 {
-    char *version, help_filename[PATH_LENGTH+1];
+    char help_filename[PATH_LENGTH+1];
     FILE *fp;
 
     custom_lib_init();
@@ -372,7 +372,7 @@
 bool edges_ok;
 {
     int interval, to_interval, i, first, last;
-    char token[TOKLEN+1], *str, *save_str, c;
+    char *str, *save_str, c;
 
     run {
 	if (edges_ok) { first=0; last=num_markers; }
@@ -428,7 +428,7 @@
 real *real_list;
 int *num_reals;
 {
-    int i, *temp_ints;
+    int i;
 
     if(nullstr(command_str)) {
         getln(prompt); crunch(ln);
diff -Nurd -x'*~' mapm3-source.orig/mapm/map_info.h mapm3-source/mapm/map_info.h
--- mapm3-source.orig/mapm/map_info.h	1993-02-09 11:35:06.000000000 -0500
+++ mapm3-source/mapm/map_info.h	2006-06-09 03:32:19.000000000 -0400
@@ -210,7 +210,7 @@
     MAP  *best_map;      
 } PLACEME;
 
-
+bool find_seed_order();
 
 /***** Chromosome framework, assignment, and placement stuff - chroms.c *****/
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/mapm.h mapm3-source/mapm/mapm.h
--- mapm3-source.orig/mapm/mapm.h	1993-02-09 11:35:06.000000000 -0500
+++ mapm3-source/mapm/mapm.h	2006-06-09 03:26:52.000000000 -0400
@@ -398,6 +398,7 @@
 command prepdat();    		
 command translate();
 
+void valid_new_name();
 
 /* moved set_age and make_note */
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/npt_cmds.c mapm3-source/mapm/npt_cmds.c
--- mapm3-source.orig/mapm/npt_cmds.c	1993-02-09 11:35:04.000000000 -0500
+++ mapm3-source/mapm/npt_cmds.c	2006-06-09 01:39:33.000000000 -0400
@@ -7,7 +7,7 @@
  #   ##  #          #            #    #  #    #  #    #  #    #   ###    #    #
  #    #  #          #   #######   ####   #    #  #####    ####    ###     ####
 
-******************************************************************************
+******************************************************************************/
 /* This file is part of MAPMAKER 3.0b, Copyright 1987-1992, Whitehead Institute
    for Biomedical Research. All rights reserved. See READ.ME for license. */
 
@@ -141,7 +141,7 @@
     MAP *map;
     int maps_to_save, num_to_print, loci_per_map, n, total, excluded, tried, i;
     int *locus, num_loci, prev;
-    real input_num, threshold, best;
+    real threshold, best;
 
     mapm_ready(ANY_DATA,2,PERM_SEQ,&num_loci);
     get_arg(itoken,20,&maps_to_save);
@@ -212,7 +212,7 @@
 {
     MAP *map0=NULL, *map;
     SAVED_LIST *list;
-    int n_loci, window, excluded, tried, num_ok, i, j, k, n;
+    int n_loci, window, excluded, tried, i, j, k, n;
     real thresh, best;
     bool same;
 
@@ -300,9 +300,9 @@
     MAP *map=NULL;
     int *marker_to_try=NULL, **new_marker=NULL, num_to_try_at_once, num_tries;
     int num_seq_loci, num_intervals, first_marker, i, j, n, m, next;
-    int **paired_loci=NULL, next_paired, num_paired, num_total, max_paired;
-    bool **exclude_interval=NULL, **zero_placement=NULL, *is_locus_paired=NULL;
-    char *err, token[TOKLEN+1], *intervals, *p;
+    int num_total, max_paired;
+    bool **exclude_interval=NULL, **zero_placement=NULL;
+    char *err, token[TOKLEN+1];
 
     void expand_seq_names();      /* KLUDGE from sequence.c, gotta do better */
     char *markers, str[MAX_SEQ_LEN+99]; /* KLUDGE KLUDGE KLUDGE */
@@ -455,7 +455,7 @@
 bool *excluded, *zero;
 int *count;
 {
-    int i, j, num_loci, next, num_ok, last, sex, loc, num_paired, best_i;
+    int i, j, num_ok, last, sex, num_paired, best_i;
     MAP *map;
     real best;
     
@@ -533,8 +533,8 @@
 command order_maker()
 {
     int *loci=NULL, num_loci, *linkage_group=NULL, num_unlinked, group_size;
-    int starter[3], *subset=NULL, **seed_temp=NULL, subset_size, groups_done;
-    int i, j, k, num, prev, num_to_place, num_unplaced, seed_size, seed_tries;
+    int *subset=NULL, **seed_temp=NULL, subset_size, groups_done;
+    int i, j, num, prev, num_unplaced, seed_size, seed_tries;
     bool seed_ok, found;
     MAP  *order=NULL, *seed_map=NULL;
     PLACEME **unplaced;
diff -Nurd -x'*~' mapm3-source.orig/mapm/orders.c mapm3-source/mapm/orders.c
--- mapm3-source.orig/mapm/orders.c	1993-02-09 11:35:04.000000000 -0500
+++ mapm3-source/mapm/orders.c	2006-06-09 03:47:34.000000000 -0400
@@ -333,7 +333,7 @@
 int leftmost, rightmost;  /* presumably, the left and rightmost intervals? */
 int init_window_size, newmarker;
 {
-    int first, last, start, end, left, width, i, j;
+    int first, last, start, end, width, i, j;
     
     for (width=init_window_size; width>=1; width--) {
 	first=max(1,leftmost-width+1);
@@ -383,7 +383,7 @@
 bool three_pt_verify(locus,num_loci,window_size)
 int *locus, num_loci, window_size;
 {
-    int i, j, k, left, right;
+    int i, j, k;
     if (num_loci<3 || window_size<3) return(TRUE); /* crash? */
 
     for (i=0; i<num_loci-2; i++)
@@ -406,7 +406,7 @@
 int *best_pos;   /* side effected */
 MAP *best_map, *temp;  /* max_loci must be >=finish-start+2 */
 {
-    int i, j, k, num_allowed, last, *zero=NULL;
+    int i, j, k, num_allowed, last;
     real best_like, lod, theta;
     real theta1, theta2, dist1, dist2, distframe, distscale;
     
@@ -614,7 +614,29 @@
     } while (deleted);
 }
 
-
+bool good_seed(map,temp_map,thresh)
+MAP *map, *temp_map;
+real thresh;
+{
+    real best2=VERY_UNLIKELY, best=VERY_UNLIKELY;
+    
+    make_compare_seq(temp_map->locus,temp_map->num_loci,0,temp_map->num_loci);
+    for_all_orders(seq,temp_map) {
+	if (use_three_pt &&
+	    !three_pt_verify(temp_map->locus,temp_map->num_loci,
+			     three_pt_window)) continue;
+	init_rec_fracs(temp_map);
+	converge_to_map(temp_map);
+	if (temp_map->log_like>best) 
+	  { best2=best; best=temp_map->log_like; mapcpy(map,temp_map,TRUE); }
+	else if (temp_map->log_like>best2) { best2=temp_map->log_like; }
+    }
+    if (best==VERY_UNLIKELY) return(FALSE);
+    else if (best2==VERY_UNLIKELY || best2-best<thresh) {
+	sf(ps,"Got one at log-likelihood %.2lf\n",best-best2); pr();
+	return(TRUE); 
+    } else return(FALSE);
+}
 
 #define irand(n) (int)(randnum()*(real)n)
 #define SEED_FAILED \
@@ -700,29 +722,7 @@
 }
 
 
-bool good_seed(map,temp_map,thresh)
-MAP *map, *temp_map;
-real thresh;
-{
-    real best2=VERY_UNLIKELY, best=VERY_UNLIKELY;
-    
-    make_compare_seq(temp_map->locus,temp_map->num_loci,0,temp_map->num_loci);
-    for_all_orders(seq,temp_map) {
-	if (use_three_pt &&
-	    !three_pt_verify(temp_map->locus,temp_map->num_loci,
-			     three_pt_window)) continue;
-	init_rec_fracs(temp_map);
-	converge_to_map(temp_map);
-	if (temp_map->log_like>best) 
-	  { best2=best; best=temp_map->log_like; mapcpy(map,temp_map,TRUE); }
-	else if (temp_map->log_like>best2) { best2=temp_map->log_like; }
-    }
-    if (best==VERY_UNLIKELY) return(FALSE);
-    else if (best2==VERY_UNLIKELY || best2-best<thresh) {
-	sf(ps,"Got one at log-likelihood %.2lf\n",best-best2); pr();
-	return(TRUE); 
-    } else return(FALSE);
-}
+
     
 
 
@@ -749,7 +749,7 @@
 real npt_thresh;        /* both are side-effected, and may have NO_LOCUS */
 bool print_anyway;
 {
-    int i, j, k, num, total;
+    int i, j, total;
     bool placed_any, contradiction;
     PLACE   **placements=NULL;
     MAP     *temp_map=NULL;
@@ -820,9 +820,9 @@
 PLACE **placements; /* these are all temps */
 MAP *temp_map;
 {
-    int places, best_places, best_pos, best_i, i, j;
-    int left, right, pos, how;
-    real next_best, best_unallowed, error_lod, e1, e2; /* e1, e2=threshs */
+    int places, best_places, best_i, i, j;
+    int left, right, how;
+    real next_best, best_unallowed, error_lod; /* e1, e2=threshs */
     bool zero_place, off_ends, single_error;
 
     if (placed->num_loci>=MAX_MAP_LOCI) 
diff -Nurd -x'*~' mapm3-source.orig/mapm/print.c mapm3-source/mapm/print.c
--- mapm3-source.orig/mapm/print.c	1993-02-09 11:35:04.000000000 -0500
+++ mapm3-source/mapm/print.c	2006-06-09 02:11:37.000000000 -0400
@@ -93,10 +93,10 @@
 int *old_locus;  /* can omit if num_args==0 - should do this with VARARGS */
 {
     int  i, j, n, m;
-    real cm, length, male_cm, female_cm, male_length, female_length;
+    real length, male_cm, female_cm, male_length, female_length;
     real best, next, lod;
     int  bestj, nextj;
-    char haplo, p1, p2, name[TOKLEN+1], num[TOKLEN+1], my_title[TOKLEN+1];
+    char haplo, p1, p2, num[TOKLEN+1], my_title[TOKLEN+1];
 
     if (!map->sex_specific) { /**************** CEPH or F2 ****************/
 	length= 0.0;
@@ -248,7 +248,7 @@
 {
     int i,num_to_print;
     char str[TOKLEN+1];
-    real best, x;
+    real best;
 
     if (how_many==FULL_LIST || how_many>list->num_maps || how_many<0)
       num_to_print= list->num_maps;
@@ -355,7 +355,7 @@
 int **new_marker;
 int num_tried, first;
 {
-    int i, j, k, q, width_ea, next, last;
+    int i, j, k, q, width_ea, last;
     bool any_paired=FALSE;
     real best[8];
     char *line1= get_temp_string(), *line2= get_temp_string();
@@ -464,7 +464,6 @@
 int locus;
 char **errs;
 {
-    int i;
     
     *errs= ptr_to("0.0");
     return("abc1-xyz999");
@@ -475,7 +474,7 @@
 int locus;
 bool haplo;
 {
-    int type, n_infs, n_dom_obs, n_het_obs, *observation=NULL;
+    int type, n_infs, n_dom_obs, n_het_obs;
     char *retoin= get_temp_string();
 
     if (raw.data_type!=F2) { strcpy(retoin,"ceph"); return(retoin); }
@@ -508,8 +507,8 @@
 int *locus, n_loci;
 bool haplo;
 {
-    int i, any_new, g, *observation=NULL;
-    char *status, *chrom, *hap, lg[TOKLEN+1];
+    int i, any_new, g;
+    char *chrom, *hap, lg[TOKLEN+1];
 
     for (any_new=FALSE, i=0; i<n_loci; i++) 
       if (modified[locus[i]]) { any_new=TRUE; break; }
@@ -540,7 +539,7 @@
     }    
 }
 
-#define MAPPING_HEAD1\
+#define MAPPING_HEAD1 \
 "                                                      2nd    Left "
 #define MAPPING_HEAD2 \
 " Num  Name      Assignment Chrom     LOD   Mapping    Like   Locus     Errors"
@@ -554,7 +553,7 @@
 int *locus, n_loci;
 bool haplo;
 {
-    int i, j, k, pos, state, *observation=NULL;
+    int i, j, k, pos, state;
     real val;
     char *chrom, *linked, *lod, *theta, *assign;
     char *mapping, *left, *like, *errs, *star;
@@ -740,7 +739,6 @@
 {
     int num_remaining, num_across, num_done, num_intervals;
     int i, j, num_places, rightmost;
-    char dist[TOKLEN+1];
 
     if (map->sex_specific) send(CRASH);
 
@@ -832,9 +830,12 @@
     int indiv, n_indivs, firsti, lasti;
     int locus, i, j, *obs=NULL, *prev_obs=NULL, *num_recs=NULL, old;
     int *last_homo=NULL, *last_het=NULL, *homo_was=NULL;
+    real error_rate;
+#ifdef FIX_THIS_SOMEDAY
     int got_one, num;
-    real error_rate, cm;
+    real cm;
     char ch;
+#endif
 
     if (map->sex_specific || raw.data_type!=F2) send(CRASH);
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/ps_maps.c mapm3-source/mapm/ps_maps.c
--- mapm3-source.orig/mapm/ps_maps.c	1993-02-09 11:35:04.000000000 -0500
+++ mapm3-source/mapm/ps_maps.c	2006-06-09 01:02:47.000000000 -0400
@@ -227,7 +227,7 @@
 real scale;
 {
     int i, j, k, l, num_crunched, interval, marker;
-    double map_length, interval_length, ps_length, dist;
+    double interval_length, ps_length, dist;
     char *loc_str, **placed_markers=NULL;
     MAP *frame;
 
diff -Nurd -x'*~' mapm3-source.orig/mapm/quick23.c mapm3-source/mapm/quick23.c
--- mapm3-source.orig/mapm/quick23.c	1993-02-09 11:35:05.000000000 -0500
+++ mapm3-source/mapm/quick23.c	2006-06-09 02:00:50.000000000 -0400
@@ -36,7 +36,7 @@
 bool sexflag;
 {
     LOCUS locus;
-    real conv_like, unconv_like, theta;
+    real conv_like, unconv_like;
     RECVECTOR **rec_frac;
     if (raw.data_type!=F2) send(CRASH);
 
@@ -68,8 +68,8 @@
     int i;
     int indiv;
     int x, y;
-    real old_log_like, new_log_like, likelihood, recs;
-    real theta, pr_zero, pr_one, pr_two;
+    real recs;
+    real theta, pr_zero, pr_one;
     int pairs[3];  /* pairs: [0]=A-A, B-B; [1]=A-B; [2]=no data */
     
     for(i=0; i<3; i++)
@@ -125,7 +125,7 @@
     char x, y;
     real old_log_like, new_log_like, likelihood, numerator;
     real theta, recs;
-    real matrix1[3], matrix2[3], prob[6][4];
+    real prob[6][4];
 
     theta=startrecombs;
     probinit(prob);
diff -Nurd -x'*~' mapm3-source.orig/mapm/reader.c mapm3-source/mapm/reader.c
--- mapm3-source.orig/mapm/reader.c	1993-02-09 11:35:05.000000000 -0500
+++ mapm3-source/mapm/reader.c	2006-06-09 03:55:42.000000000 -0400
@@ -538,12 +538,72 @@
     }
 }	
 
+void add_to_seg_dist(c,locus)
+char c;
+int locus;
+{
+    switch(c) {
+	case PARENTAL_TYPE_A: {
+	    raw.data.f2.allelic_distribution[locus][0] += 1.0;
+	    return;
+	}
+	case PARENTAL_TYPE_B: {
+	    raw.data.f2.allelic_distribution[locus][3] += 1.0;
+	    return;
+	}
+	case TYPE_NOT_A: {
+	    if(raw.data.f2.cross_type == F3_SELF) {
+		raw.data.f2.allelic_distribution[locus][1] += (1.0/5.0);
+		raw.data.f2.allelic_distribution[locus][2] += (1.0/5.0);
+		raw.data.f2.allelic_distribution[locus][3] += (3.0/5.0);
+	    } else {
+		raw.data.f2.allelic_distribution[locus][1] += (1.0/3.0);
+		raw.data.f2.allelic_distribution[locus][2] += (1.0/3.0);
+		raw.data.f2.allelic_distribution[locus][3] += (1.0/3.0);
+	    }
+	    return;
+	}
+	case TYPE_NOT_B: {
+	    if(raw.data.f2.cross_type == F3_SELF) {
+		raw.data.f2.allelic_distribution[locus][0] += (3.0/5.0);
+		raw.data.f2.allelic_distribution[locus][1] += (1.0/5.0);
+		raw.data.f2.allelic_distribution[locus][2] += (1.0/5.0);
+	    } else {
+		raw.data.f2.allelic_distribution[locus][0] += (1.0/3.0);
+		raw.data.f2.allelic_distribution[locus][1] += (1.0/3.0);
+		raw.data.f2.allelic_distribution[locus][2] += (1.0/3.0);
+	    }
+	    return;
+	}
+	case HYBRID_TYPE_H: {
+	    raw.data.f2.allelic_distribution[locus][1] += 0.5;
+	    raw.data.f2.allelic_distribution[locus][2] += 0.5;
+	    return;
+	}
+    }
+}
+
+void scale_seg_dist(locus)
+int locus;
+{
+    real total;
+    int i;
+    
+    total = 0.0;
+    for(i=0; i<4; i++) {
+	total += raw.data.f2.allelic_distribution[locus][i];
+    }
+    for(i=0; i<4; i++) {
+	raw.data.f2.allelic_distribution[locus][i] =
+	  raw.data.f2.allelic_distribution[locus][i] / total;
+    }
+}
 
 void new_read_f2_locus(fp,locus_num)
 FILE *fp;
 int locus_num;
 {
-    int i, chrom_num; 
+    int i;
     char c, name[NAME_LEN+2];
 
     getdataln(fp); /* Must be at the start of a line */
@@ -607,7 +667,6 @@
 char *symbols;
 {
     int i;
-    char *leftovers;
 
     run {
 	allocate_f2_data(raw.num_markers,raw.data.f2.num_indivs);
@@ -627,7 +686,7 @@
 int locus_num;
 char *symbol;
 {
-    int i, j, num, templen;
+    int i, j;
     char c, *name, converted;
 
     name= get_temp_string();
@@ -881,63 +940,3 @@
 
 
 
-add_to_seg_dist(c,locus)
-char c;
-int locus;
-{
-    switch(c) {
-	case PARENTAL_TYPE_A: {
-	    raw.data.f2.allelic_distribution[locus][0] += 1.0;
-	    return;
-	}
-	case PARENTAL_TYPE_B: {
-	    raw.data.f2.allelic_distribution[locus][3] += 1.0;
-	    return;
-	}
-	case TYPE_NOT_A: {
-	    if(raw.data.f2.cross_type == F3_SELF) {
-		raw.data.f2.allelic_distribution[locus][1] += (1.0/5.0);
-		raw.data.f2.allelic_distribution[locus][2] += (1.0/5.0);
-		raw.data.f2.allelic_distribution[locus][3] += (3.0/5.0);
-	    } else {
-		raw.data.f2.allelic_distribution[locus][1] += (1.0/3.0);
-		raw.data.f2.allelic_distribution[locus][2] += (1.0/3.0);
-		raw.data.f2.allelic_distribution[locus][3] += (1.0/3.0);
-	    }
-	    return;
-	}
-	case TYPE_NOT_B: {
-	    if(raw.data.f2.cross_type == F3_SELF) {
-		raw.data.f2.allelic_distribution[locus][0] += (3.0/5.0);
-		raw.data.f2.allelic_distribution[locus][1] += (1.0/5.0);
-		raw.data.f2.allelic_distribution[locus][2] += (1.0/5.0);
-	    } else {
-		raw.data.f2.allelic_distribution[locus][0] += (1.0/3.0);
-		raw.data.f2.allelic_distribution[locus][1] += (1.0/3.0);
-		raw.data.f2.allelic_distribution[locus][2] += (1.0/3.0);
-	    }
-	    return;
-	}
-	case HYBRID_TYPE_H: {
-	    raw.data.f2.allelic_distribution[locus][1] += 0.5;
-	    raw.data.f2.allelic_distribution[locus][2] += 0.5;
-	    return;
-	}
-    }
-}
-
-scale_seg_dist(locus)
-int locus;
-{
-    real total;
-    int i;
-    
-    total = 0.0;
-    for(i=0; i<4; i++) {
-	total += raw.data.f2.allelic_distribution[locus][i];
-    }
-    for(i=0; i<4; i++) {
-	raw.data.f2.allelic_distribution[locus][i] =
-	  raw.data.f2.allelic_distribution[locus][i] / total;
-    }
-}
diff -Nurd -x'*~' mapm3-source.orig/mapm/sequence.c mapm3-source/mapm/sequence.c
--- mapm3-source.orig/mapm/sequence.c	1993-02-09 11:35:05.000000000 -0500
+++ mapm3-source/mapm/sequence.c	2006-06-09 03:53:52.000000000 -0400
@@ -78,6 +78,7 @@
 bool parse_seq_chrom();
 void seq_expand();
 void add_chr();
+bool is_a_named_locus();
 bool is_a_named_sequence();
 bool is_an_old_sequence();
 bool is_a_special_sequence();
@@ -195,7 +196,6 @@
 SEQ_NODE *mk_locus_range(first,last)
 int first, last;
 {
-    int i;
     SEQ_NODE *node=get_seq_node();
 
     node=mk_locus(first);
@@ -323,7 +323,6 @@
     char c, *not_a_locus_errmsg;
     int n, m;
     SEQ_NODE **p, *q;
-    real theta;
 
     p=NULL; 
 
@@ -476,7 +475,6 @@
 SEQ_NODE *p;
 MAP *map;
 { 
-    int i;
 
     reset_seq(p,TRUE);
     clean_map(map); /* resets map->num_loci, among other things */
@@ -492,7 +490,6 @@
    loci, not just haplo groups, even if use_haplotypes==TRUE. The size 
    returned by mapm_ready should be right for this. */
 { 
-    int total;
 
     *num_loci=0;
     reset_seq(p,TRUE); 
@@ -530,7 +527,6 @@
    the maximum number of loci the array holds (CRASH if it's exceeded) */
 {
     int j; 
-    real val;
     
     if (p==NULL) return(TRUE); /* should never happen? */
     if (direction==BACKWARDS) while(p->next!=NULL) p=p->next; /* to end */
@@ -770,7 +766,6 @@
 int *i_cnt, *j_cnt, *k_cnt;
 int *locus, num_loci;
 {
-    SEQ_NODE *p;
 
     if (num_loci<3) send(CRASH);
     *ok= TRUE;
@@ -813,7 +808,6 @@
 bool expanded; /* if seq_str is set to the name-expanded seq or not */
 /* if error relay BADSEQ message without changing anything */
 {
-    SEQ_NODE *p;   /* add history stuff later */
     int save_chrom, num_loci;
     char *rest, chrom_name[99];
 
@@ -990,7 +984,7 @@
 void make_compare_seq(locus,num_loci,start_set,set_size)
 int *locus, num_loci, start_set, set_size;
 {
-    int i, j;
+    int i;
     char *last;
     
     last=seq_temp; last[0]='\0';
@@ -1095,7 +1089,7 @@
 /* send BADSEQ if expansion >MAX_SEQ_LEN chars or if it contains circularly 
    defined names- this should never happen */
 { 
-    char *token_start, *expansion, *errmsg=NULL, *all, *rest, name[TOKLEN+1];
+    char *token_start, *expansion, *errmsg=NULL, *all, *rest;
     int loop_count, chrom;
 
     loop_count=0; all=str; BADSEQ_errpos= -1; 
@@ -1125,7 +1119,7 @@
 /* send BADSEQ if expansion >MAX_SEQ_LEN chars or if it contains circularly 
    defined names- this should never happen */
 { 
-    char *token_start, *rest, *value, *errmsg=NULL, *all, name[TOKLEN+1];
+    char *token_start, *rest, *value, *errmsg=NULL, *all;
     int loop_count, chrom;
 
     loop_count=0; all=str; BADSEQ_errpos= -1; 
@@ -1154,7 +1148,6 @@
 char *seq, **token;
 int *num_tokens;
 {
-    int i;
 
     swap_for_dash(seq);  /* makes '-' a delimiter ('~') */
     expand_seq_names(seq);
@@ -1210,8 +1203,7 @@
 int *n;         /* side-effected with locus# iff TRUE is returned */
 char **why_not; /* side-effected iff FALSE is returned */
 { 
-    char *foo, *bar;
-    int fail, num;
+    int num;
 
     if (!data_loaded() || !is_a_token(str)) send(CRASH);
     *why_not=ptr_to("");
@@ -1243,8 +1235,7 @@
 char **seq;      /* side-effected */
 char **why_not;  /* side-effected iff FALSE is returned */
 {
-    int n;
-    char *rest, name[TOKLEN+1];
+    char name[TOKLEN+1];
 
     if (!data_loaded() || !is_a_token(str)) send(CRASH);
     *why_not=ptr_to("");
@@ -1275,7 +1266,7 @@
 bool expanded;
 { 
     char *foo, *rest;
-    int chrom, save_chrom;
+    int save_chrom;
     /* if (name[0]=='*') name++; */
 
     despace(str);
@@ -1432,7 +1423,7 @@
 char **seq;      /* side-effected iff TRUE returned */
 char **why_not;  /* side-effected iff TRUE returned and *str=="" */
 {
-    int chrom, one_chrom, i, j, k, n, contig, num, locus, ordered_seq;
+    int chrom, one_chrom, i, j, k, n, contig, num, ordered_seq;
     char *last;
 
     one_chrom=FALSE; chrom=0;
diff -Nurd -x'*~' mapm3-source.orig/mapm/state.c mapm3-source/mapm/state.c
--- mapm3-source.orig/mapm/state.c	1993-02-09 11:35:05.000000000 -0500
+++ mapm3-source/mapm/state.c	2006-06-09 00:57:03.000000000 -0400
@@ -282,7 +282,7 @@
 
 command set_cm_func()
 {
-    int i, mapnum;
+    int i;
 
     char type[TOKLEN+1];
     mapm_ready(ANY_DATA,0,FALSE,NULL);
@@ -565,8 +565,6 @@
 void allocate_context(con)
 STATUS_CONTEXT *con;
 {
-    TABLE *seqhist=NULL, *names=NULL;
-
     run {
 	con->sex_specific= FALSE;
 	con->compress_DNA= TRUE;
diff -Nurd -x'*~' mapm3-source.orig/mapm/sys_cmds.c mapm3-source/mapm/sys_cmds.c
--- mapm3-source.orig/mapm/sys_cmds.c	1993-02-09 11:35:06.000000000 -0500
+++ mapm3-source/mapm/sys_cmds.c	2006-06-09 03:36:22.000000000 -0400
@@ -20,6 +20,10 @@
 void try_to_unload();
 void try_to_load();
 
+/* from sequence.c */
+bool is_an_old_sequence();
+bool is_a_named_sequence();
+
 #define SAVE_ERR1 \
  "\nAn error occured while saving data: previous data remain loaded\n"
 #define SAVE_ERR2 \
@@ -157,7 +161,6 @@
 {
     char name[PATH_LENGTH+1];
     FILE *fp=NULL;
-    int end, data_type;
     bool prev_data;
 
     use_uncrunched_args();
@@ -230,7 +233,6 @@
 
 command make_classes()
 {
-    int i;
     char name[TOKLEN+1], *errmsg;
 
     mapm_ready(ANY_DATA,0,0,NULL);
@@ -300,7 +302,7 @@
 command make_note()
 {
     int n, n_loci, i, *locus=NULL;
-    char *middle=ptr_to(""), *name=get_temp_string(), *rest, *errmsg;
+    char *name=get_temp_string(), *rest, *errmsg;
 
     mapm_ready(ANY_DATA,0,0,&n_loci);
 
@@ -393,7 +395,7 @@
 #define BADEDITEDSEQ "An illegal sequence was specified.\nsequence= %s\n"
 command edit_sequence()
 {
-    char name[TOKLEN+1], prompt[TOKLEN+1], *value, *err, n, init;
+    char name[TOKLEN+1], prompt[TOKLEN+1], *value, *err;
     int *locus=NULL, num_loci;
     bool set_seq;
     mapm_ready(ANY_DATA,0,0,NULL);
@@ -435,8 +437,7 @@
 
 command show_seq_history()
 {
-    int i, start, num_to_do, any=FALSE;
-    char *str= get_temp_string();
+    int num_to_do;
 
     mapm_ready(ANY_DATA,0,0,NULL);
     get_one_arg(itoken,20,&num_to_do);
@@ -497,8 +498,7 @@
 
 command forget()
 {
-    char *errmsg, *seq, *name= get_temp_string();
-    int err;
+    char *errmsg, *name= get_temp_string();
     mapm_ready(ANY_DATA,0,0,NULL);
     get_one_arg(stoken,sREQUIRED,name);
 
@@ -511,10 +511,9 @@
 
 command new_delete()
 {
-    int i, j, loc, found, num_seq_tokens, k, *locus=NULL, num_loci;
+    int i, j, found, num_seq_tokens, k, *locus=NULL, num_loci;
     int *seq_locus=NULL, seq_loci;
     char locus_name[TOKLEN+1], locus_num[TOKLEN+1], locus_plus[TOKLEN+1];
-    char *errmsg;
 
     mapm_ready(ANY_DATA,1,MAYBE_PERM,NULL);
     if (nullstr(args)) usage_error(0);
@@ -562,9 +561,7 @@
 
 command new_append()
 {
-    int i, j, found, num_seq_tokens, append_at_top;
     int *locus=NULL, num_loci;
-    char *errmsg;
     
     mapm_ready(ANY_DATA,1,MAYBE_PERM,NULL);
     if (nullstr(args)) usage_error(0);
@@ -638,7 +635,7 @@
 command translate()
 {
     int i, num_loci, *locus=NULL, source;
-    char *name[TOKLEN+1], c;
+    char c;
 
     mapm_ready(ANY_DATA,MAYBE_SEQ,UNCRUNCHED_LIST,&num_loci);
     run {
diff -Nurd -x'*~' mapm3-source.orig/mapm/toplevel.h mapm3-source/mapm/toplevel.h
--- mapm3-source.orig/mapm/toplevel.h	1993-02-09 11:35:07.000000000 -0500
+++ mapm3-source/mapm/toplevel.h	2006-06-09 00:20:23.000000000 -0400
@@ -42,7 +42,7 @@
 
 /* this is also now all in main.c */
 bool crunch_locus_list(); 
-/* args: locus[], *num_loci; int verbosity,  check_assignments, in_sequence;
+/* args: locus[], *num_loci; int verbosity,  check_assignments, in_sequence; */
 /* side-effects locus[], *num_loci; and, if verbose, may print a msg.
    Deletes duplicates in the list, multiple loci from the same haplo
    group, and renumbers haploed loci to their primary. If
diff -Nurd -x'*~' mapm3-source.orig/mapm/two_cmds.c mapm3-source/mapm/two_cmds.c
--- mapm3-source.orig/mapm/two_cmds.c	1993-02-09 11:35:06.000000000 -0500
+++ mapm3-source/mapm/two_cmds.c	2006-06-09 01:48:41.000000000 -0400
@@ -452,8 +452,7 @@
 
 command pairwise()
 {
-    int i, j, a, b, num_trials, *try_me=NULL, num_loci, *loci=NULL;
-    bool sex;
+    int num_trials, *try_me=NULL, num_loci, *loci=NULL;
 
     mapm_ready(ANY_DATA,2,UNCRUNCHED_LIST,&num_loci);
     run {
@@ -497,7 +496,7 @@
 	    sf(ps," %-10s %-10s  %s    %s   %s    %s    %s",
 	       loc2str(i),loc2str(j),
 	       rsd(5.2,thetam),rsd(5.2,thetaf),rsd(5.2,lod),
-	       cm_dist(thetam),cm_dist(thetaf)); pr();
+	       rsd(5.2,cm_dist(thetam)),rsd(5.2,cm_dist(thetaf))); pr();
 	    if (chrom!=NO_CHROM) { sf(ps,"   (%s)",chrom2str(chrom)); pr(); }
 	    nl();
 	    return(TRUE);
@@ -636,7 +635,7 @@
 
 command three_point()
 {
-    int i, num_loci, *loci=NULL, num_trips, num_groups, num_links;
+    int num_loci, *loci=NULL, num_trips, num_groups, num_links;
     int *linkage_group=NULL, group_size, num_unlinked, three_locus[3], foo;
     SEQ_NODE *three_seq;
     MAP *map=NULL;
@@ -766,7 +765,7 @@
 
 command suggest_subset()
 {
-    real lodbound, thetabound, seed_like;
+    real lodbound, thetabound;
     int *loci=NULL, num_loci, *linkage_group=NULL, group_size, groups_done;
     int *subset=NULL, subset_size, num_unlinked, i, prev;
 
diff -Nurd -x'*~' mapm3-source.orig/quant/qcmds.c mapm3-source/quant/qcmds.c
--- mapm3-source.orig/quant/qcmds.c	1993-02-09 16:12:33.000000000 -0500
+++ mapm3-source/quant/qcmds.c	2006-06-09 04:07:13.000000000 -0400
@@ -374,7 +374,7 @@
 
 command translate()
 {
-    int printed, i, j;
+    int printed, i;
     
     qtl_ready(ANY_DATA,NOSEQ,NOTRAIT,NOQCTM);
     nomore_args(0);
@@ -453,10 +453,10 @@
 
 command qtl_like()
 {
-    int perm;
+/*    int perm;
     real like;
     
-/*    qtl_ready(ANY_DATA,SEQ,TRAIT,QCTM);
+    qtl_ready(ANY_DATA,SEQ,TRAIT,QCTM);
     nl(); 
     
     for_all_orders(ints,map,perm) {
@@ -662,7 +662,7 @@
 command list_wiggles()
 {
     char arg[TOKLEN+1];
-    int wiggle, order, last;
+    int wiggle, order;
     WIGGLE_OPERATION *op;
 
     qtl_ready(ANY_DATA,NOSEQ,NOTRAIT,NOQCTM);
@@ -864,7 +864,6 @@
     real *normal_array=NULL;
     NORMAL_TEST *normal_check=NULL;
     char *eqn, *name_to_check, *name;
-    char *error_message=get_temp_string();
     int trait_redone, trait_index;
     EQUATION **postfixed;
 
@@ -978,9 +977,9 @@
 
 command dump_scan()
 {
-    char arg[TOKLEN+1], *errmsg=get_temp_string();
+  char arg[TOKLEN+1];
     char *name=get_temp_string();
-    int t[8], num, i, j;
+    int i, j;
     FILE *fp=NULL;
     WIGGLE_OPERATION *op;
     WIGGLE_INTERVAL **data;
@@ -1021,7 +1020,6 @@
 
 command dump_traits()
 {
-    char arg[TOKLEN+1], *errmsg=get_temp_string();
     int t[8], num, i, j;
     FILE *fp=NULL;
     
@@ -1060,12 +1058,12 @@
 command dump_genome()
 {
     FILE *fp=NULL;
-    int i,j,k,l;
+    int k,l;
     int tot_aa=0,tot_bb=0,tot_ab=0,total_num=0;
     run {
 	print("dumping to 'genome.dump'\n");
 	fp = open_file("genome.dump",WRITE);
-	fprintf(fp,"*loci\t \%AA\t \%AB  \%BB\t n_indivs");
+	fprintf(fp,"*loci\t %%AA\t %%AB  %%BB\t n_indivs");
 	for(k=0;k<raw.n_loci;k++) {
 	    fprintf(fp,"\n");
 	    for(l=0;l<raw.n_indivs;l++) {
@@ -1308,7 +1306,7 @@
 
 command sequence_editor()
 {
-    char name[TOKLEN+1], prompt[TOKLEN+1], *seq, *err, *foo, *new_seq;
+    char prompt[TOKLEN+1], *new_seq;
     int errpos;
 
     qtl_ready(ANY_DATA,NOSEQ,NOTRAIT,NOQCTM);
@@ -1409,7 +1407,7 @@
 	    if (msg==CANTOPEN) {
 		sf(ps,"error: unable to open data file\n"); pr();
 	    } else if (msg==BADDATA) {
-		sf(ps,"error: unable to load data from file\nline %d:",
+		sf(ps,"error: unable to load data from file %s\nline %d:",
 		   temp,BADDATA_line_num); pr(); 
 		print(BADDATA_error); nl();
 		strcpy(raw.file,"");
@@ -1630,8 +1628,8 @@
 
 command tester()
 {
-    real theta, pos, f2_sum, f3_sum, a, b, c, x, y, z, left_rf, right_rf;
-    int geno, qtl, left, right;
+    real theta, f2_sum, f3_sum, a, b, c, x, y, z, left_rf, right_rf;
+    int qtl, left, right;
 
     getln("Theta, L_Pos, R_pos: ");
     sscanf(ln,"%lf %lf %lf",&theta,&left_rf,&right_rf);
@@ -1691,7 +1689,7 @@
 command draw_wiggle()
 {
     char arg[TOKLEN+1];
-    int wiggle, order, last;
+    int wiggle, order;
     real threshold, scale;
     WIGGLE_OPERATION *op;
 
diff -Nurd -x'*~' mapm3-source.orig/quant/qcontext.c mapm3-source/quant/qcontext.c
--- mapm3-source.orig/quant/qcontext.c	1993-02-09 11:35:57.000000000 -0500
+++ mapm3-source/quant/qcontext.c	2006-06-09 01:06:44.000000000 -0400
@@ -100,7 +100,7 @@
 STATUS_CONTEXT *con;
 bool save_it;
 {
-    char *name,*seqnce,*err;
+    char *err;
 
     if(save_it) {
 	for(Te=con->named_sequences->list; Te!=NULL; Te=Te->next) {
diff -Nurd -x'*~' mapm3-source.orig/quant/qctm.c mapm3-source/quant/qctm.c
--- mapm3-source.orig/quant/qctm.c	1993-02-09 11:35:57.000000000 -0500
+++ mapm3-source/quant/qctm.c	2006-06-09 01:31:43.000000000 -0400
@@ -641,7 +641,7 @@
 real **S_matrix, **expected_genotype, *phenotype, *fix_weight;
 real *mu, *qtl_weight, *sigma_sq;  /* side effect these three */
 {
-    int n, size, i, j;
+    int n, size, i;
     real total, prediction;
     /* S_inverse and row are side-effected */
 
@@ -943,9 +943,7 @@
 DATA *data;
 QTL_MAP *map; 	/* many parts of this are side-effected */
 {
-    real old_like, new_like;
-    int i;
-    bool done;
+    real new_like;
     /* use externs null_qtl_weight, qctm_qtl_weight, qctm_qtl_pos */
 
     set_qctm_globals(data,map);
diff -Nurd -x'*~' mapm3-source.orig/quant/qdata.c mapm3-source/quant/qdata.c
--- mapm3-source.orig/quant/qdata.c	1993-02-09 11:35:58.000000000 -0500
+++ mapm3-source/quant/qdata.c	2006-06-09 04:20:04.000000000 -0400
@@ -15,6 +15,7 @@
 #define INC_SHELL
 #define INC_CALLQCTM
 #define INC_QLOWLEVEL
+#define INC_QTOPLEVEL
 #include "qtl.h"
 
 
@@ -279,8 +280,8 @@
 void make_genotype_arrays(data_type,num_intervals)
 int data_type,num_intervals;
 {
-    int i, j, this_genotype, N, M, g0, g1;
-    GENOTYPE geno, k;
+    int i, j, this_genotype, N;
+    GENOTYPE geno;
 
     /* The array and matrix macros don't handle things bigger with a dimension
        bigger than 32K. For now we assume that GENOTYPE is a short, and that 
diff -Nurd -x'*~' mapm3-source.orig/quant/qprint.c mapm3-source/quant/qprint.c
--- mapm3-source.orig/quant/qprint.c	1993-02-09 11:35:58.000000000 -0500
+++ mapm3-source/quant/qprint.c	2006-06-09 03:57:18.000000000 -0400
@@ -218,7 +218,7 @@
 GENO_PROBS *expected_recs;
 int n_individuals, n_genotype_vars, n_continuous_vars, n_intervals;
 {
-    int i, j, n, g, q, m, L, R, num;
+    int i, j, n, g, q, m, num;
 
     num= n_genotype_vars + n_continuous_vars;
 
@@ -395,7 +395,6 @@
 {
     int i, k;
     WIGGLE_OPERATION *op;
-    char *left;
 
     if (wiggle<0) return;
     if (wiggle>=num_wiggles || (op=wiggles[wiggle])==NULL) send(CRASH);
@@ -572,7 +571,7 @@
 int wiggle, order;
 real threshold;
 {
-    int i, j, k, test;
+    int i, j, test;
     WIGGLE_OPERATION *op;
     WIGGLE_INTERVAL **data[NUM_MODELS];
     WIGGLE_POINT *point[NUM_MODELS];
@@ -629,7 +628,6 @@
 bool fill;
 {
     char *str= get_temp_string();
-    int i;
     if (print_mapm_loci) {
 	if (!print_names) sf(str,"%d-%d",raw.original_locus[left],
 			     raw.original_locus[right]);
@@ -699,7 +697,7 @@
 	  case TEST_MODELS:     strcpy(str,"try");         break;
 	  case CONSTRAINED: 	
 	      if (!verbose) strcpy(str,"constrain");
-	      else sf(str,"constraints: A=%-4.2lf B=%-4.2lf C=-4.2lf",
+	      else sf(str,"constraints: A=%-4.2lf B=%-4.2lf C=%-4.2lf",
 		      genetics->a,genetics->b,genetics->c);
 	      break;
 	  case FIXED:
@@ -906,7 +904,6 @@
 {
     COMPARE_OPERATION *op;
     int i, start;
-    bool bad_maps_yet, good_maps_printed;
     real best, like;
 
     if ((op=compares[compare])==NULL) send(CRASH);
diff -Nurd -x'*~' mapm3-source.orig/quant/qps_scan.c mapm3-source/quant/qps_scan.c
--- mapm3-source.orig/quant/qps_scan.c	1993-02-09 11:35:58.000000000 -0500
+++ mapm3-source/quant/qps_scan.c	2006-06-09 01:03:46.000000000 -0400
@@ -39,7 +39,7 @@
 int wiggle, order;
 real threshold;
 {
-    int i, j, k, count=0, num_notches=0, pagenum=1;
+    int i, j, count=0, num_notches=0, pagenum=1;
     double *xval, *yval, *notch, highest, longest, current_len;
     WIGGLE_OPERATION *op;
     WIGGLE_INTERVAL **data;
@@ -196,7 +196,7 @@
 int num_points;
 char *line_type;
 {
-    int i, j;
+    int i;
     double *x0, *x1, *x2, *x3, *y0, *y1, *y2, *y3, *slope, s1, s2;
 
     array(x0, num_points, real);
@@ -396,10 +396,9 @@
 int wiggle;
 real threshold;
 {
-    int i, j, k, count=0, num_notches=0, pagenum=1, order;
+    int i, j, count=0, num_notches=0, pagenum=1, order;
     double **xval, **yval, *notch, highest, longest, current_len;
     WIGGLE_OPERATION *op;
-    WIGGLE_INTERVAL **data;
     WIGGLE_POINT *point;
     FILE *fp;
     char **label, *trait_str, *filename, *line_choice();
diff -Nurd -x'*~' mapm3-source.orig/quant/qraw.c mapm3-source/quant/qraw.c
--- mapm3-source.orig/quant/qraw.c	1993-02-09 11:35:59.000000000 -0500
+++ mapm3-source/quant/qraw.c	2006-06-09 04:36:09.000000000 -0400
@@ -138,12 +138,12 @@
 char *temp;
 {
  
-    int k=0,v,l,i,seq_size,e,hist_size,num_chrom,num_loc=0,t_loc=0,j=0,loc;
-    int mapnum,name_len=80, checker, mapm_loci;
+    int k=0,v,l,i,e,num_chrom,num_loc=0,t_loc=0,j=0,loc;
+    int name_len=80, checker, mapm_loci;
     int n_indivs, n_loci, n_traits, random_check1, random_check2, num_entries;
-    real ma=0,rf;
-    char *size_of_sequence,number_of_lines[TOKLEN+1],*name,*err;
-    char num_of_chroms[TOKLEN+1],pointer_to_lines[TOKLEN+1];
+    real rf;
+    char *name,*err;
+    char num_of_chroms[TOKLEN+1];
     char all_str[5*SEQ_LEN], current_chrom[SEQ_LEN];
     char default_intercross_chars[10], default_backcross_chars[10];
 
@@ -409,8 +409,7 @@
 void save_traitfile(fp)
 FILE *fp;
 {
-    char *name,mapnum;
-    int i,j,loci_tot,map_tot,usenum;
+    int i,j,loci_tot,map_tot;
     
     run {
         sf(ps,"%d mapmaker trait data\n",raw.filenumber);
@@ -498,8 +497,8 @@
 /* could send BADDATA or IOERROR */
 {
     
-    char **temp_set,c, nam[TOKLEN+1], *namp;
-    int j,k,i,name_len=80,t,num_of_terms = 0;
+  char **temp_set,c, nam[TOKLEN+1];
+    int j,k,i,t,num_of_terms = 0;
     matrix(temp_set,n_loci,80,char);
     for(i=0;i<t_loc;i++) {
 	if (order[i] == -1) {
@@ -544,7 +543,6 @@
 FILE *fp;
 int num;
 {
-	int bar;
 	real map_dist;
 	if (nullstr(ln)) getdataln(fp);
 	if (!rtoken(&ln, rREQUIRED, &map_dist))
@@ -599,9 +597,8 @@
 FILE *fp;
 char *path;
 {
-    int i, j, k, n_indivs, n_loci, n_traits, pos;
-    char nam[TOKLEN], c, tok[TOKLEN + 1];
-    real val;
+    int i, j, n_indivs, n_loci, n_traits;
+    char tok[TOKLEN + 1];
     extern int nam_len;	
 	
     BADDATA_line_num= 0;
@@ -664,7 +661,7 @@
 int num, indivs;
 /* could send BADDATA or IOERROR */
 {
-    char c, nam[TOKLEN+1], *namp;
+    char c;
     int i;
 
     /* read the locus name */
@@ -748,7 +745,7 @@
 
     real r[3], l[3], right, left;
     INTERVAL_GENOTYPE_PROBS *indiv_probs;
-    int geno, foo;
+    int geno;
 
     first=0; last=raw.n_loci-1;
     for (i=0; i<raw.n_indivs; i++) {
@@ -812,7 +809,6 @@
 int locus;
 char this_genotype;
 {
-    int i;
     prob[locus][A]= prob[locus][B]= prob[locus][H]= 0.0;
 
     if (raw.data_type==BACKCROSS) 
@@ -881,6 +877,7 @@
 	  default:  send(CRASH);
       }
     else send(CRASH);
+    exit(1);
 }
 
 
@@ -891,7 +888,7 @@
 real rec_frac;
 int side;
 {
-    int i, geno_was, geno_is, max_recs,geno1,geno2;
+    int i, geno_was, geno_is, geno1,geno2;
     real rec, norec, total;
 
     for (i=0; i<MAX_LOCUS_GENOTYPES; i++) prob[locus][i]=0.0;
@@ -916,8 +913,7 @@
 int data_type, geno_was, geno_is;
 real theta;
 {
-    INTERVAL_GENOTYPE_PROBS prob;
-    real x, y, z, sum;
+    real sum;
     real C2, D2, E2, F2, G2, C3, D3, E3, F3, G3;
 
     if (data_type==BACKCROSS) {
@@ -1052,7 +1048,9 @@
 	    default: send(CRASH);
 	}
 #endif 
-    } else send(CRASH);
+    }
+    send(CRASH);
+    exit(1);
 
 }
 
@@ -1061,7 +1059,7 @@
 int left, right;		/* Assumes check_interval() has succeeded */
 {
     real total_cm, total_rf;
-    int i,temp;
+    int i;
     
 	
 /*  if (zero_interval(left,right)) return(MIN_REC_FRAC);  */
@@ -1116,6 +1114,7 @@
 	case B: return(0.25);
 	case H: return(0.50);
     }
+    exit(1);
 }
 
 
diff -Nurd -x'*~' mapm3-source.orig/quant/qseq.c mapm3-source/quant/qseq.c
--- mapm3-source.orig/quant/qseq.c	1993-02-09 11:35:59.000000000 -0500
+++ mapm3-source/quant/qseq.c	2006-06-09 04:15:21.000000000 -0400
@@ -20,6 +20,7 @@
 #define INC_QTOPLEVEL
 #define INC_QLOWLEVEL
 #include "qtl.h"
+#include "mathlib.h"
 
 /***** Global *****/
 QTL_SEQUENCE *ints;
@@ -202,6 +203,21 @@
 
 char dummy;
 
+bool try_right(str,opt)
+char **str;  /* may be side-effected */
+QTL_SEQ_OPTION *opt; /* may be side-effected */
+{
+    int num;
+    char right[TOKLEN+1];
+
+    if (LOOKAHEAD(VERTICAL_BAR)) {
+	if (!stoken(str,sREQUIRED,right)) FAIL_(err_BADRIGHT)
+	if (!valid_locus_str(right,&num,seqerr)) FAIL_(seqerr)
+	if (num<=opt->isa.interval.left) FAIL_(err_BADINT)
+	opt->isa.interval.right=num; return(TRUE);
+    } else return(FALSE);
+}
+
 QTL_SEQUENCE *int_compiler(str)
 char **str; 
 {
@@ -365,20 +381,6 @@
 }
 
 
-bool try_right(str,opt)
-char **str;  /* may be side-effected */
-QTL_SEQ_OPTION *opt; /* may be side-effected */
-{
-    int num;
-    char right[TOKLEN+1];
-
-    if (LOOKAHEAD(VERTICAL_BAR)) {
-	if (!stoken(str,sREQUIRED,right)) FAIL_(err_BADRIGHT)
-	if (!valid_locus_str(right,&num,seqerr)) FAIL_(seqerr)
-	if (num<=opt->isa.interval.left) FAIL_(err_BADINT)
-	opt->isa.interval.right=num; return(TRUE);
-    } else return(FALSE);
-}
 
 
 bool try_fix_pos(str,opt)
@@ -911,7 +913,7 @@
 {
     char *every, *super_exp, *new_str, *tok, *expansion, *dummy;
     char *temp_str;
-    int err, i, new_num, num;
+    int err, num;
 
     new_str= NULL; every=get_temp_string(); tok= get_temp_string();
     temp_str=get_temp_string();
diff -Nurd -x'*~' mapm3-source.orig/quant/qtl.h mapm3-source/quant/qtl.h
--- mapm3-source.orig/quant/qtl.h	1993-02-09 11:36:00.000000000 -0500
+++ mapm3-source/quant/qtl.h	2006-06-09 04:01:58.000000000 -0400
@@ -105,6 +105,7 @@
 
 /*** in QWIGGLE.C ***/
 void wiggle_init();  /* no args */
+bool isa_test_wiggle();
 
 /*** QTL user state variables  ***/				/* file */
 /* all (most?) of these are initialized by cmd_init() */
diff -Nurd -x'*~' mapm3-source.orig/quant/qtop.c mapm3-source/quant/qtop.c
--- mapm3-source.orig/quant/qtop.c	1993-02-09 16:12:33.000000000 -0500
+++ mapm3-source/quant/qtop.c	2006-06-09 04:24:32.000000000 -0400
@@ -60,6 +60,8 @@
 void ps_BADDATA() { sf(ps,"line=\"%s\"\nerror=%s",
 		       truncstr(BADDATA_ln,60),truncstr(BADDATA_error,70)); }
 
+void make_help_entries();
+
 void top_init()
 { 
   BADDATA_ln= BADDATA_error= NULL; 
@@ -85,12 +87,11 @@
 
 /********** Welcome to the Top of the World **********/
 
-main(argc,argv)
+int main(argc,argv)
 int argc;
 char *argv[];
 {
-    char *version, help_filename[PATH_LENGTH+1];
-    FILE *fp;
+    char help_filename[PATH_LENGTH+1];
     
     custom_lib_init();
     get_cmd_line_args(&argc,argv);
@@ -535,6 +536,67 @@
     }
 }
 
+/* Lower-level */
+
+bool isa_trait_name(str,num,exact)
+char *str;
+int *num; /* the trait# if TRUE, else the #matched if FALSE */
+bool *exact;
+{
+    int i, n_matched;
+
+    *num=0; *exact=FALSE;
+    /* see if we uniquely match a trait name */
+    for (i=0, n_matched=0; i<raw.n_traits; i++)
+      if (!nullstr(raw.trait_name[i]) && matches(str,raw.trait_name[i])) { 
+	  n_matched++; *num=i; 
+	  if (len(str)==len(raw.trait_name[i])) 
+	    { *exact=TRUE; n_matched=1; break; }
+      }
+    return(n_matched==1 ? TRUE:FALSE);
+}
+
+
+bool isa_locus_name(str,num,exact)
+char *str;
+int *num; /* the locus# if TRUE, else the #matched if FALSE */
+bool *exact;
+{
+    int i, n_matched;
+
+    *num=0; *exact=FALSE;
+    /* see if we uniquely match a locus name */
+    for (i=0, n_matched=0; i<raw.n_loci; i++)
+      if (matches(str,raw.locus_name[i])) { 
+	  n_matched++; *num=i; 
+	  if (len(str)==len(raw.locus_name[i])) 
+	    { *exact=TRUE; n_matched=1; break; }
+      }
+/*  if (matches(str,"inf"))  { *num= INF_LOCUS; n_matched++; }
+    if (matches(str,"ter"))  { *num= INF_LOCUS; n_matched++; }
+    if (matches(str,"pter")) { *num= INF_LOCUS; n_matched++; }
+    if (matches(str,"qter")) { *num= INF_LOCUS; n_matched++; } */
+    return(n_matched==1 ? TRUE:FALSE);
+}
+
+
+bool isa_seq_name(str,num,exact)
+char *str;
+int *num; /* the #matched if FALSE - undefined if true */
+bool *exact;
+{
+    char *seq, *full_name;
+    int err;
+
+    if (!get_named_entry(str,&seq,&full_name,
+	  context[active_context]->named_sequences,&err)) {
+	if (err==NAME_DOESNT_MATCH) *num=0;
+	else /* err==NAME_IS_AMBIGUOUS */ *num=2;
+	return(FALSE);
+    } 
+    *exact= (len(full_name)==len(str) ? TRUE:FALSE);
+    return(TRUE);
+}
 
 #define eNOTRAIT    "Missing trait name or number following '*'."
 #define eNOLOCUS    "Missing locus name or number following '*'."
@@ -737,67 +799,6 @@
 
 
 
-/* Lower-level */
-
-bool isa_trait_name(str,num,exact)
-char *str;
-int *num; /* the trait# if TRUE, else the #matched if FALSE */
-bool *exact;
-{
-    int i, n_matched;
-
-    *num=0; *exact=FALSE;
-    /* see if we uniquely match a trait name */
-    for (i=0, n_matched=0; i<raw.n_traits; i++)
-      if (!nullstr(raw.trait_name[i]) && matches(str,raw.trait_name[i])) { 
-	  n_matched++; *num=i; 
-	  if (len(str)==len(raw.trait_name[i])) 
-	    { *exact=TRUE; n_matched=1; break; }
-      }
-    return(n_matched==1 ? TRUE:FALSE);
-}
-
-
-bool isa_locus_name(str,num,exact)
-char *str;
-int *num; /* the locus# if TRUE, else the #matched if FALSE */
-bool *exact;
-{
-    int i, n_matched;
-
-    *num=0; *exact=FALSE;
-    /* see if we uniquely match a locus name */
-    for (i=0, n_matched=0; i<raw.n_loci; i++)
-      if (matches(str,raw.locus_name[i])) { 
-	  n_matched++; *num=i; 
-	  if (len(str)==len(raw.locus_name[i])) 
-	    { *exact=TRUE; n_matched=1; break; }
-      }
-/*  if (matches(str,"inf"))  { *num= INF_LOCUS; n_matched++; }
-    if (matches(str,"ter"))  { *num= INF_LOCUS; n_matched++; }
-    if (matches(str,"pter")) { *num= INF_LOCUS; n_matched++; }
-    if (matches(str,"qter")) { *num= INF_LOCUS; n_matched++; } */
-    return(n_matched==1 ? TRUE:FALSE);
-}
-
-
-bool isa_seq_name(str,num,exact)
-char *str;
-int *num; /* the #matched if FALSE - undefined if true */
-bool *exact;
-{
-    char *seq, *full_name;
-    int err;
-
-    if (!get_named_entry(str,&seq,&full_name,
-	  context[active_context]->named_sequences,&err)) {
-	if (err==NAME_DOESNT_MATCH) *num=0;
-	else /* err==NAME_IS_AMBIGUOUS */ *num=2;
-	return(FALSE);
-    } 
-    *exact= (len(full_name)==len(str) ? TRUE:FALSE);
-    return(TRUE);
-}
 
 
 /* Upper level */
diff -Nurd -x'*~' mapm3-source.orig/quant/qtop.h mapm3-source/quant/qtop.h
--- mapm3-source.orig/quant/qtop.h	1993-02-09 11:36:01.000000000 -0500
+++ mapm3-source/quant/qtop.h	2006-06-09 04:11:31.000000000 -0400
@@ -175,6 +175,8 @@
    #permutations of the left part of the sequence, and *num_wiggle_ints
    will indicate the #intervals specified for the rightmost qtl. */
 
+int add_continuous_var();
+
 #define SEQ         1
 #define NOSEQ       0
 #define WIGSEQ      (-1)
diff -Nurd -x'*~' mapm3-source.orig/quant/qwiggle.c mapm3-source/quant/qwiggle.c
--- mapm3-source.orig/quant/qwiggle.c	1993-02-09 11:36:00.000000000 -0500
+++ mapm3-source/quant/qwiggle.c	2006-06-09 01:08:08.000000000 -0400
@@ -50,7 +50,7 @@
 int n_wiggles, n_compares;
 /* use globals raw.max_traits, raw.data_type, and raw.n_loci as params */
 {
-    int i, j, k, n_models, n_intervals;
+    int i, n_models, n_intervals;
 
     if (raw.data_type==NO_DATA) send(CRASH);
     wiggles=NULL; compares=NULL; /* qtls=NULL; */
@@ -169,7 +169,6 @@
     WIGGLE_INTERVAL *data, *prev;
     int i, j, k, n, t;
     real cm, interval_cm;
-    bool new;
 
     if (wiggle_num<0) return;
 
@@ -229,7 +228,7 @@
 #ifdef DELETED
 	/* It does want to go in... */
 	/* if (qtls[t][i][j]!=NULL) {  but these wiggle data already exist! */
-	    /* prev= qtls[t][i][j]; new=FALSE;
+	    /* prev= qtls[t][i][j]; new=FALSE; */
 	    /* If the old one has points, we keep the higher resolution one */
 	    if (prev->point==NULL || data->cm_increment<=prev->cm_increment) {
 		prev->in_qtls_struct=FALSE; 
@@ -304,7 +303,7 @@
 int n_intervals, n_orders;
 /* return compare struct entry#, or -1 if error */
 {
-    int n, i, j;
+    int n;
 
     /* KLUDGE - How to recycle these things? */
     if (num_compares==max_compares) return(-1);
@@ -361,8 +360,8 @@
 {
     COMPARE_OPERATION *op;
     COMPARE_DATA *data;
-    WIGGLE_INTERVAL *wig, *prev;
-    int i, j, k, n, t;
+    WIGGLE_INTERVAL *wig;
+    int i, j, t;
 
     if (compare_num<0) return;
     if (compare_num>=max_compares || compares[compare_num]==NULL ||
@@ -462,7 +461,7 @@
 {
     int i, j, peak_i, peak_j, n_intervals;
     bool still_falling, off_end, contig;
-    real lod, local_maxima, pos, cm;
+    real lod, local_maxima;
     real local_minima, prev_lod, starting_value;
     WIGGLE_INTERVAL **interval; 
     WIGGLE_PEAK *first, *last, *peak;
diff -Nurd -x'*~' mapm3-source.orig/sun/xmapmaker mapm3-source/sun/xmapmaker
--- mapm3-source.orig/sun/xmapmaker	1993-02-10 00:57:29.000000000 -0500
+++ mapm3-source/sun/xmapmaker	2006-06-09 00:18:40.000000000 -0400
@@ -10,5 +10,5 @@
 else if (-e /usr/openwin/demo/xterm) then
 	exec /usr/openwin/demo/xterm $xoptions $fontsize -e $program $*
 else
-	exec xterm $options $fontsize -e $program
+	exec xterm $xoptions $fontsize -e $program
 endif
diff -Nurd -x'*~' mapm3-source.orig/sun/xqtl mapm3-source/sun/xqtl
--- mapm3-source.orig/sun/xqtl	1993-02-10 00:57:29.000000000 -0500
+++ mapm3-source/sun/xqtl	2006-06-09 00:18:40.000000000 -0400
@@ -10,5 +10,5 @@
 else if (-e /usr/openwin/demo/xterm) then
 	exec /usr/openwin/demo/xterm $xoptions $fontsize -e $program $*
 else
-	exec xterm $options $fontsize -e $program
+	exec xterm $xoptions $fontsize -e $program
 endif

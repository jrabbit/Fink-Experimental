diff -Nurd -x'*~' avahi-0.6.20.orig/avahi-autoipd/Makefile.am avahi-0.6.20/avahi-autoipd/Makefile.am
--- avahi-0.6.20.orig/avahi-autoipd/Makefile.am	2007-04-21 14:48:34.000000000 -0400
+++ avahi-0.6.20/avahi-autoipd/Makefile.am	2007-06-26 20:36:37.000000000 -0400
@@ -47,8 +47,13 @@
 avahi_autoipd_SOURCES += iface-bsd.c
 avahi_autoipd_LDADD += -lpcap
 else
+if TARGET_DARWIN
+avahi_autoipd_SOURCES += iface-darwin.c
+avahi_autoipd_LDADD += -lpcap
+else
 avahi_autoipd_SOURCES += iface-linux.c
 endif
+endif
 
 nodist_pkgsysconf_SCRIPTS = avahi-autoipd.action
 
@@ -56,9 +61,14 @@
 avahi-autoipd.action: avahi-autoipd.action.bsd
 	cp $< $@
 else
+if TARGET_DARWIN
+avahi-autoipd.action: avahi-autoipd.action.darwin
+	cp $< $@
+else
 avahi-autoipd.action: avahi-autoipd.action.linux
 	cp $< $@
 endif
+endif
 
 if TARGET_DEBIAN
 
@@ -91,6 +101,6 @@
 endif
 endif
 
-EXTRA_DIST = dhclient-enter-hook.in dhclient-exit-hook.in avahi-autoipd.action.linux avahi-autoipd.action.bsd
+EXTRA_DIST = dhclient-enter-hook.in dhclient-exit-hook.in avahi-autoipd.action.linux avahi-autoipd.action.bsd avahi-autoipd.action.darwin
 
 CLEANFILES = dhclient-enter-hook dhclient-exit-hook avahi-autoipd.action
diff -Nurd -x'*~' avahi-0.6.20.orig/avahi-autoipd/avahi-autoipd.action.darwin avahi-0.6.20/avahi-autoipd/avahi-autoipd.action.darwin
--- avahi-0.6.20.orig/avahi-autoipd/avahi-autoipd.action.darwin	1969-12-31 19:00:00.000000000 -0500
+++ avahi-0.6.20/avahi-autoipd/avahi-autoipd.action.darwin	2007-06-26 18:01:49.000000000 -0400
@@ -0,0 +1,50 @@
+#!/bin/sh
+
+# $Id$
+#
+# This file is part of avahi.
+# 
+# avahi is free software; you can redistribute it and/or modify it
+# under the terms of the GNU Lesser General Public License as
+# published by the Free Software Foundation; either version 2 of the
+# License, or (at your option) any later version.
+#
+# avahi is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with avahi; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+# USA.
+
+set -e
+
+# Command line arguments:
+#   $1 event that happened:
+#          BIND:     Successfully claimed address
+#          CONFLICT: An IP address conflict happened
+#          UNBIND:   The IP address is no longer needed
+#          STOP:     The daemon is terminating
+#   $2 interface name
+#   $3 IP adddress
+
+# We have the BSD ifconfig tool
+
+case "$1" in
+BIND)
+    ifconfig "$2" "$3"/16
+    ;;
+
+CONFLICT|STOP|UNBIND)
+    ifconfig "$2" "$3"/16 delete
+    ;;
+
+*)
+    echo "Unknown event $1" >&2
+    exit 1
+    ;;
+esac
+
+exit 0
diff -Nurd -x'*~' avahi-0.6.20.orig/avahi-autoipd/iface-darwin.c avahi-0.6.20/avahi-autoipd/iface-darwin.c
--- avahi-0.6.20.orig/avahi-autoipd/iface-darwin.c	1969-12-31 19:00:00.000000000 -0500
+++ avahi-0.6.20/avahi-autoipd/iface-darwin.c	2007-06-26 19:12:34.000000000 -0400
@@ -0,0 +1,382 @@
+/* rcs tags go here */
+/* Original author of iface-linux.c: Bruce M. Simpson <bms@FreeBSD.org> */
+/* Hacked for darwin by the Fink Project */
+
+/***
+  This file is part of avahi.
+ 
+  avahi is free software; you can redistribute it and/or modify it
+  under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+ 
+  avahi is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
+  Public License for more details.
+ 
+  You should have received a copy of the GNU Lesser General Public
+  License along with avahi; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <sys/sysctl.h>
+
+#include <net/if.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include <unistd.h>
+
+#include <libdaemon/dlog.h>
+
+#include <avahi-common/llist.h>
+#include <avahi-common/malloc.h>
+
+#include "iface.h"
+
+#ifndef IN_LINKLOCAL
+#define IN_LINKLOCAL(i)	(((u_int32_t)(i) & (0xffff0000)) == (0xa9fe0000))
+#endif
+
+#ifndef elementsof
+#define elementsof(array)	(sizeof(array)/sizeof(array[0]))
+#endif
+
+#ifndef so_set_nonblock
+#define so_set_nonblock(s, val) \
+	do {						\
+		int __flags;				\
+		__flags = fcntl((s), F_GETFL);		\
+		if (__flags == -1)			\
+			break;				\
+		if (val != 0)				\
+			__flags |= O_NONBLOCK;		\
+		else					\
+			__flags &= ~O_NONBLOCK;		\
+		(void)fcntl((s), F_SETFL, __flags);	\
+	} while (0)
+#endif
+
+#define MAX_RTMSG_SIZE 2048
+
+struct rtm_dispinfo {
+	u_char		*di_buf;
+	ssize_t		 di_buflen;
+	ssize_t		 di_len;
+};
+
+union rtmunion {
+	struct rt_msghdr		 rtm;
+	struct if_msghdr		 ifm;
+	struct ifa_msghdr		 ifam;
+	struct ifma_msghdr		 ifmam;
+};
+typedef union rtmunion rtmunion_t;
+
+struct Address;
+typedef struct Address Address;
+
+struct Address {
+	in_addr_t	address;
+	AVAHI_LLIST_FIELDS(Address, addresses);
+};
+
+static int rtm_dispatch(void);
+static int rtm_dispatch_newdeladdr(struct rtm_dispinfo *di);
+static struct sockaddr *next_sa(struct sockaddr *sa);
+
+static int fd = -1;
+static int ifindex = -1;
+static AVAHI_LLIST_HEAD(Address, addresses) = NULL;
+
+int
+iface_init(int idx)
+{
+
+	fd = socket(PF_ROUTE, SOCK_RAW, 0);
+	if (fd == -1) {
+		daemon_log(LOG_ERR, "socket(PF_ROUTE): %s", strerror(errno));
+		return (-1);
+	}
+
+	so_set_nonblock(fd, 1);
+
+	ifindex = idx;
+
+	return (fd);
+}
+
+int
+iface_get_initial_state(State *state)
+{
+	int			 mib[6];
+	char			*buf;
+	struct if_msghdr	*ifm;
+	struct ifa_msghdr	*ifam;
+	char			*lim;
+	char			*next;
+	struct sockaddr		*sa;
+	size_t			 len;
+	int			 naddrs;
+
+	assert(state != NULL);
+	assert(fd != -1);
+
+	naddrs = 0;
+
+	mib[0] = CTL_NET;
+	mib[1] = PF_ROUTE;
+	mib[2] = 0;
+	mib[3] = 0;
+	mib[4] = NET_RT_IFLIST;
+	mib[5] = ifindex;
+
+	if (sysctl(mib, elementsof(mib), NULL, &len, NULL, 0) != 0) {
+		daemon_log(LOG_ERR, "sysctl(NET_RT_IFLIST): %s",
+		    strerror(errno));
+		return (-1);
+	}
+
+	buf = malloc(len);
+	if (buf == NULL) {
+		daemon_log(LOG_ERR, "malloc(%zd): %s", len, strerror(errno));
+		return (-1);
+	}
+
+	if (sysctl(mib, elementsof(mib), buf, &len, NULL, 0) != 0) {
+		daemon_log(LOG_ERR, "sysctl(NET_RT_IFLIST): %s",
+		    strerror(errno));
+		free(buf);
+		return (-1);
+	}
+
+	lim = buf + len;
+	for (next = buf; next < lim; next += ifm->ifm_msglen) {
+		ifm = (struct if_msghdr *)next;
+		if (ifm->ifm_type == RTM_NEWADDR) {
+			ifam = (struct ifa_msghdr *)next;
+			sa = (struct sockaddr *)(ifam + 1);
+			if (sa->sa_family != AF_INET)
+				continue;
+			++naddrs;
+		}
+	}
+	free(buf);
+
+	*state = (naddrs > 0) ? STATE_SLEEPING : STATE_START;
+
+	return (0);
+}
+
+int
+iface_process(Event *event)
+{
+	int b;
+
+	assert(fd != -1);
+
+	b = !!addresses;
+
+	if (rtm_dispatch() == -1)
+		return (-1);
+
+	if (b && !addresses)
+		*event = EVENT_ROUTABLE_ADDR_UNCONFIGURED;
+	else if (!b && addresses)
+		*event = EVENT_ROUTABLE_ADDR_CONFIGURED;
+
+	return (0);
+}
+
+void
+iface_done(void)
+{
+	Address *a;
+
+	if (fd != -1) {
+		close(fd);
+		fd = -1;
+	}
+
+	while ((a = addresses) != NULL) {
+		AVAHI_LLIST_REMOVE(Address, addresses, addresses, a);
+		avahi_free(a);
+	}
+}
+
+/*
+ * Dispatch kernel routing socket messages.
+ */
+static int
+rtm_dispatch(void)
+{
+	struct msghdr mh;
+	struct iovec iov[1];
+	struct rt_msghdr *rtm;
+	struct rtm_dispinfo *di;
+	ssize_t len;
+	int retval;
+
+	di = malloc(sizeof(*di));
+	if (di == NULL) {
+		daemon_log(LOG_ERR, "malloc(%zd): %s", sizeof(*di),
+		    strerror(errno));
+		return (-1);
+	}
+	di->di_buflen = MAX_RTMSG_SIZE;
+	di->di_buf = calloc(MAX_RTMSG_SIZE, 1);
+	if (di->di_buf == NULL) {
+		free(di);
+		daemon_log(LOG_ERR, "calloc(%d): %s", MAX_RTMSG_SIZE,
+		    strerror(errno));
+		return (-1);
+	}
+
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = di->di_buf;
+	iov[0].iov_len = di->di_buflen;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+
+	retval = 0;
+	for (;;) {
+		len = recvmsg(fd, &mh, MSG_DONTWAIT);
+		if (len == -1) {
+			if (errno == EWOULDBLOCK)
+				break;
+			else {
+				daemon_log(LOG_ERR, "recvmsg(): %s",
+				    strerror(errno));
+				retval = -1;
+				break;
+			}
+		}
+
+		rtm = (void *)di->di_buf;
+		if (rtm->rtm_version != RTM_VERSION) {
+			daemon_log(LOG_ERR,
+			    "unknown routing socket message (version %d)\n",
+			    rtm->rtm_version);
+			/* this is non-fatal; just ignore it for now. */
+			continue;
+		}
+
+		switch (rtm->rtm_type) {
+		case RTM_NEWADDR:
+		case RTM_DELADDR:
+			retval = rtm_dispatch_newdeladdr(di);
+			break;
+		default:
+			break;
+		}
+
+		/*
+		 * If we got an error; assume our position on the call
+		 * stack is enclosed by a level-triggered event loop,
+		 * and signal the error condition.
+		 */
+		if (retval != 0)
+			break;
+	}
+	free(di->di_buf);
+	free(di);
+
+	return (retval);
+}
+
+static struct sockaddr *
+next_sa(struct sockaddr *sa)
+{
+	void		*p;
+	size_t		 sa_size;
+
+	sa_size = sa->sa_len;
+	if (sa_size < sizeof(u_long))
+		sa_size = sizeof(u_long);
+	p = ((char *)sa) + sa_size;
+
+	return (struct sockaddr *)p;
+}
+
+/* handle address coming or going away */
+static int
+rtm_dispatch_newdeladdr(struct rtm_dispinfo *di)
+{
+	Address			*ap;
+	rtmunion_t		*rtm;
+	struct sockaddr		*sa;
+	struct sockaddr_in	*sa_in;
+
+/* macro to skip to next RTA; has side-effects */
+#define SKIPRTA(rtmsgp, rta, sa)					\
+	do {								\
+		if ((rtmsgp)->rtm_addrs & (rta))			\
+			(sa) = next_sa((sa));				\
+	} while (0)
+
+	rtm = (void *)di->di_buf;
+
+	assert(rtm->rtm.rtm_type == RTM_NEWADDR ||
+	       rtm->rtm.rtm_type == RTM_DELADDR);
+
+	if (rtm->rtm.rtm_index != ifindex)
+		return (0);
+
+	if (!(rtm->rtm.rtm_addrs & RTA_IFA)) {
+		daemon_log(LOG_ERR, "ifa msg has no RTA_IFA.");
+		return (0);
+	}
+
+	/* skip over rtmsg padding correctly */
+	sa = (struct sockaddr *)((&rtm->ifam) + 1);
+	SKIPRTA(&rtm->rtm, RTA_DST, sa);
+	SKIPRTA(&rtm->rtm, RTA_GATEWAY, sa);
+	SKIPRTA(&rtm->rtm, RTA_NETMASK, sa);
+	SKIPRTA(&rtm->rtm, RTA_GENMASK, sa);
+	SKIPRTA(&rtm->rtm, RTA_IFP, sa);
+
+	/*
+	 * sa now points to RTA_IFA sockaddr; we are only interested
+	 * in updates for link-local addresses.
+	 */
+	if (sa->sa_family != AF_INET)
+		return (0);
+	sa_in = (struct sockaddr_in *)sa;
+	if (!IN_LINKLOCAL(ntohl(sa_in->sin_addr.s_addr)))
+		return (0);
+
+	for (ap = addresses; ap; ap = ap->addresses_next) {
+		if (ap->address == sa_in->sin_addr.s_addr)
+			break;
+	}
+	if (rtm->rtm.rtm_type == RTM_DELADDR && ap != NULL) {
+		AVAHI_LLIST_REMOVE(Address, addresses, addresses, ap);
+		avahi_free(ap);
+	}
+	if (rtm->rtm.rtm_type == RTM_NEWADDR && ap == NULL) {
+		ap = avahi_new(Address, 1);
+		ap->address = sa_in->sin_addr.s_addr;
+		AVAHI_LLIST_PREPEND(Address, addresses, addresses, ap);
+	}
+
+	return (0);
+#undef SKIPRTA
+}
diff -Nurd -x'*~' avahi-0.6.20.orig/avahi-autoipd/main.c avahi-0.6.20/avahi-autoipd/main.c
--- avahi-0.6.20.orig/avahi-autoipd/main.c	2007-06-21 10:32:28.000000000 -0400
+++ avahi-0.6.20/avahi-autoipd/main.c	2007-06-26 17:52:45.000000000 -0400
@@ -29,7 +29,7 @@
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
-#ifdef __FreeBSD__
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 
@@ -38,8 +38,10 @@
 #endif
 #include <net/ethernet.h>
 #include <net/if.h>
-#ifdef __FreeBSD__
+#ifdef HAVE_NET_IF_DL_H
 #include <net/if_dl.h>
+#endif
+#ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #include <arpa/inet.h>
@@ -601,7 +603,7 @@
 
 	buf = malloc(len);
 	if (buf == NULL) {
-		daemon_log(LOG_ERR, "malloc(%d): %s", len, strerror(errno));
+		daemon_log(LOG_ERR, "malloc(%zd): %s", len, strerror(errno));
 		return (-1);
 	}
 
diff -Nurd -x'*~' avahi-0.6.20.orig/configure.ac avahi-0.6.20/configure.ac
--- avahi-0.6.20.orig/configure.ac	2007-06-22 12:37:52.000000000 -0400
+++ avahi-0.6.20/configure.ac	2007-06-26 21:51:26.000000000 -0400
@@ -195,6 +195,8 @@
 
 AM_CONDITIONAL(HAVE_SYS_SYSCTL_H, [ test x"$HAVE_SYS_SYSCTL_H" = xyes ])
 
+AC_CHECK_HEADERS([net/if_dl.h net/route.h])
+
 #
 # Check for lifconf struct; only present on Solaris
 #
diff -Nurd -x'*~' avahi-0.6.20.orig/initscript/darwin/Makefile.am avahi-0.6.20/initscript/darwin/Makefile.am
--- avahi-0.6.20.orig/initscript/darwin/Makefile.am	2005-11-14 19:40:12.000000000 -0500
+++ avahi-0.6.20/initscript/darwin/Makefile.am	2007-06-27 00:17:55.000000000 -0400
@@ -23,9 +23,13 @@
 	org.freedesktop.avahi-daemon.plist.in \
 	org.freedesktop.avahi-dnsconfd.plist.in
 
+if HAVE_EXPAT
+if HAVE_LIBDAEMON
 initd_SCRIPTS = \
 	org.freedesktop.avahi-daemon.plist \
 	org.freedesktop.avahi-dnsconfd.plist
+endif
+endif
 
 CLEANFILES = \
 	org.freedesktop.avahi-daemon.plist \
diff -Nurd -x'*~' avahi-0.6.20.orig/man/Makefile.am avahi-0.6.20/man/Makefile.am
--- avahi-0.6.20.orig/man/Makefile.am	2007-06-11 11:58:01.000000000 -0400
+++ avahi-0.6.20/man/Makefile.am	2007-06-27 00:23:45.000000000 -0400
@@ -35,12 +35,8 @@
 	avahi-publish.1.xml \
 	avahi-resolve.1.xml \
 	avahi-set-host-name.1.xml \
-	avahi-daemon.8.xml \
 	avahi-discover.1.xml \
 	avahi-bookmarks.1.xml \
-	avahi-dnsconfd.8.xml \
-	avahi-daemon.conf.5.xml \
-	avahi-dnsconfd.action.8.xml \
 	avahi.service.5.xml \
 	avahi.hosts.5.xml \
 	avahi-autoipd.8.xml \
@@ -50,6 +46,17 @@
 CLEANFILES = \
 	$(noinst_DATA)
 
+if HAVE_EXPAT
+if HAVE_LIBDAEMON
+man_MANS += \
+	avahi-daemon.8.xml \
+	avahi-dnsconfd.8.xml \
+	avahi-daemon.conf.5.xml \
+	avahi-dnsconfd.action.8.xml
+endif
+endif
+
+
 if HAVE_DBUS
 
 man_MANS += \

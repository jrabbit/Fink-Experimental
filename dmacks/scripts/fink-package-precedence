#!/usr/bin/perl
# -*- mode: Perl; tab-width: 4; -*-

# A dirty hack by Daniel Macks

use warnings;
use strict;

use File::Find;
use Getopt::Long;

my %opts = (
	'headers' => 1,				# scan .h in -M dependency files?
	'libs' => 1,				# scan otool -L of compiled binaries?
	'help' => 0,				# print usage msg?
	);

GetOptions(
	\%opts,
	'headers!',
	'libs!',
	'help|?',
	) or $opts{'help'} = 1;
if (!$opts{'headers'} && !$opts{'libs'}) {
	# must specify at least one mode
	$opts{'help'} = 1;
};
if (!@ARGV) {
	# must specify at least one location
	$opts{'help'} = 1;
}
if ($opts{'help'}) {
	my $msg = <<EOMSG;

Usage: $0 [options] <list of locations>

Options:

  --headers/--no-headers  Scan .Plo and .Po files (*1) for:
                          * Use of system headers that should be
                            masked by fink ones (*2)
                            (bad -I ordering or missing BuildDepends)
                          * Fink packages that supply headers used
                            (packages to list in BuildDepends)

  --libs/--no-libs        Scan compiled binaries for:
                          * System libraries that should be masked by
                            fink ones (*2)
                            (bad -L ordering or missing BuildDepends)

  --help                  Display this help message and exit

  *1 For example, generated by gcc -M flags as activated by
     ./configure --enable-dependency-tracking

  *2 error-code on exit if this condition occurs

  <list of locations> can be .Plo and/or .Po filenames, compiled-
  binary filenames, or directories to scan for these files.

EOMSG

	die $msg;
}

if ($opts{'headers'}) {

print "Scanning .Plo and .Po dependency files...\n";

my %deps;						# key=included file
								# value=first .Plo/.Tpo where it's listed

my $plo_count = 0;
find sub {
	return unless /\.(Plo|Po)$/;	#  .deps/TARGET.Plo or
									#  .deps/TARGET.Po for libtool lib
									#  objects vs simple objects

	print "\t$File::Find::name\n";
	$plo_count++;
	open my $plo, '<', $_ or die "Could not read $_: $!\n";
	while ( defined ( $_ = <$plo> ) ) {
		next if /^\s*$/;		# usually lots of blank lines
		s/^[^:]*://;				# only care deps; filename is key dependant
		foreach (split) {
			next unless /^\//;		# skip continuation markers and
									# build-dir local files
			$deps{$_} = $File::Find::name if ! exists $deps{$_};
		}
	}
	close $plo;
}, @ARGV;

if (! $plo_count) {
	die "No .Plo or .Tpo files found.\n";
}

print "Looking for incorrect headers in ", $plo_count, " dependency files...\n";

# regexes for headers to disallow.
# * /usr/local is bad news!
# * OSX or X11 files for which fink has replacements
my $repl_regex = '^' . join '|', (
	'/usr/local/include',
	'/usr/include/iconv\.h',
	'/usr/include/libxml2',
	'/usr/include/libxslt',
	'/usr/include/pcap',
	'/usr/.*/ft2build\.h',
	'/usr/.*/freetype2',
	'/usr/.*/fontconfig',
	'/usr/.*/expat\.h',
	'/usr/.*/Xft',
	'/usr/.*/cairo',
	'/usr/.*/glitz',
	'/usr/.*/pixman',
);
$repl_regex = qr/$repl_regex/; # pre-compile (will use many times)
my $fink_prefix = '/sw';
my $fink_prefix_regex = qr/^\Q$fink_prefix\E/;

my @fink_headers;

my $bad_system = 0;
foreach (sort keys %deps) {
	if (/$repl_regex/) {
		print "\t $deps{$_} uses $_\n";
		$bad_system = 1;
	} elsif (/$fink_prefix_regex/) {
		push @fink_headers, $_;
	}
}
if ($bad_system) {
	die "Please fix build process to get consistent use of fink's headers.\n";
}


my %fink_pkgs;
my $dpkg_s = "$fink_prefix/bin/dpkg -S";
my $progress = 1;
print "Determining fink providers of ", scalar(@fink_headers), " headers...\n";
while (@fink_headers) {
	# so in blocks using heuristic to avoid shell cmd-line limit
	my @chunk = splice @fink_headers, 0, 100;
	print "\t$progress - ", ($progress+=@chunk)-1, "\n";

	open my $dpkg_s, "$dpkg_s @chunk |" or die "Could not fork $dpkg_s: $!\n";
	while (<$dpkg_s>) {
		if (/^([^:]+):/) {
			$fink_pkgs{$1} = 1;
		}
	}
	close $dpkg_s or die "Error reading $dpkg_s: $! $?\n";
}

print "Found use of headers from ", scalar(keys %fink_pkgs), " fink packages:\n";
map { print "\t$_\n" } sort keys %fink_pkgs;

}

if ($opts{'libs'}) {
	my $otool = '/usr/bin/otool';
	if (!-x $otool) {
		die "Cannot scan binary linking without $otool\n";
	}

my %deps;						# key=linked lib
								# value=first binary that links against it

find sub {
	return unless -f;
	open my $otool_L, "$otool -L $_ |" or die "Could not fork $otool -L $_: $!\n";
	while ( defined ( $_ = <$otool_L> ) ) {
		next unless /^\t(.+) \(/;	# only read dyld links
		$deps{$1} = $File::Find::name if ! exists $deps{$1};
	}
	close $otool_L;
}, @ARGV;

# regexes for libraries to disallow.
# * /usr/local is bad news!
# * OSX or X11 files for which fink has replacements
my $repl_regex = '^' . join '|', (
	'/usr/local/lib',
	'/usr/lib/libiconv\.',
	'/usr/lib/liblibxml\.',
	'/usr/lib/libxslt\.',
	'/usr/lib/libpcap\.',
	'/usr/X11.*/libfreetype\.',
	'/usr/X11.*/libfontconfig\.',
	'/usr/.*/libexpat\.',
	'/usr/X11.*/libXft\.',
	'/usr/X11.*/libcairo\.',
	'/usr/X11.*/libglitz\.',
	'/usr/X11.*/libpixman\.',
);
$repl_regex = qr/$repl_regex/; # pre-compile (will use many times)

my $bad_system = 0;
foreach (sort keys %deps) {
	if (/$repl_regex/) {
		print "\t $deps{$_} uses $_\n";
		$bad_system = 1;
	}
}
if ($bad_system) {
	die "Please fix build process to get consistent use of fink's libraries.\n";
}


}

Index: darwin_stop_world.c
===================================================================
--- darwin_stop_world.c	(revision 56697)
+++ darwin_stop_world.c	(working copy)
@@ -73,7 +73,13 @@
   GC_thread p;
   pthread_t me;
   ptr_t lo, hi;
+#if defined(POWERPC)
   ppc_thread_state_t state;
+#elif defined(I386)
+  i386_thread_state_t state;
+#else
+# error FIXME for non-x86 || ppc architectures
+#endif
   mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;
   
   me = pthread_self();
@@ -93,6 +99,17 @@
 			     &thread_state_count);
 	if(r != KERN_SUCCESS) ABORT("thread_get_state failed");
 	
+#if defined(I386)
+	lo = state.esp;
+
+	GC_push_one(state.eax); 
+	GC_push_one(state.ebx); 
+	GC_push_one(state.ecx); 
+	GC_push_one(state.edx); 
+	GC_push_one(state.edi); 
+	GC_push_one(state.esi); 
+	GC_push_one(state.ebp); 
+#elif defined(POWERPC)
 	lo = (void*)(state.r1 - PPC_RED_ZONE_SIZE);
         
 	GC_push_one(state.r0); 
@@ -126,6 +143,9 @@
 	GC_push_one(state.r29); 
 	GC_push_one(state.r30); 
 	GC_push_one(state.r31);
+#else
+# error FIXME for non-x86 || ppc architectures
+#endif
       } /* p != me */
       if(p->flags & MAIN_THREAD)
 	hi = GC_stackbottom;
Index: include/private/gcconfig.h
===================================================================
--- include/private/gcconfig.h	(revision 56697)
+++ include/private/gcconfig.h	(working copy)
@@ -304,7 +304,28 @@
 #    define mach_type_known
 #   elif defined(__i386__)
 #    define I386
-     --> Not really supported, but at least we recognize it.
+#    define mach_type_known
+#    define DARWIN_DONT_PARSE_STACK
+#    define OS_TYPE "DARWIN"
+#    define DYNAMIC_LOADING
+     /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+        These aren't used when dyld support is enabled (it is by default) */
+#    define DATASTART ((ptr_t) get_etext())
+#    define DATAEND	((ptr_t) get_end())
+#    define STACKBOTTOM ((ptr_t) 0xc0000000)
+#    define USE_MMAP
+#    define USE_MMAP_ANON
+#    define USE_ASM_PUSH_REGS
+     /* This is potentially buggy. It needs more testing. See the comments in
+        os_dep.c.  It relies on threads to track writes. */
+#    ifdef GC_DARWIN_THREADS
+/* #       define MPROTECT_VDB -- diabled for now.  May work for some apps. */
+#    endif
+#    include <unistd.h>
+#    define GETPAGESIZE() getpagesize()
+      /* There seems to be some issues with trylock hanging on darwin. This
+         should be looked into some more */
+#     define NO_PTHREAD_TRYLOCK
 #   endif
 # endif
 # if defined(NeXT) && defined(mc68000)
Index: os_dep.c
===================================================================
--- os_dep.c	(revision 56697)
+++ os_dep.c	(working copy)
@@ -3819,6 +3819,10 @@
         mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE64_COUNT;
         ppc_exception_state64_t exc_state;
 #     endif
+#   elif defined(I386)
+        thread_state_flavor_t flavor = i386_EXCEPTION_STATE;
+        mach_msg_type_number_t exc_state_count = i386_EXCEPTION_STATE_COUNT;
+        i386_exception_state_t exc_state;
 #   else
 #	error FIXME for non-ppc darwin
 #   endif
@@ -3850,7 +3854,13 @@
     }
     
     /* This is the address that caused the fault */
+#if defined(POWERPC)
     addr = (char*) exc_state.dar;
+#elif defined (I386)
+    addr = (char*) exc_state.faultvaddr;
+#else
+#   error FIXME for non POWERPC/I386
+#endif
         
     if((HDR(addr)) == 0) {
         /* Ugh... just like the SIGBUS problem above, it seems we get a bogus 

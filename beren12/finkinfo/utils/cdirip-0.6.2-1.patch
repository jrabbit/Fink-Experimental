diff -ruN cdirip-0.6.2.orig/2dos cdirip-0.6.2/2dos
--- cdirip-0.6.2.orig/2dos	1969-12-31 19:00:00.000000000 -0500
+++ cdirip-0.6.2/2dos	2002-06-20 11:22:27.000000000 -0400
@@ -0,0 +1 @@
+find -X . -type f \! -name "*.o" -print | xargs perl -p -i -e 's/\n/\r\n/;'
diff -ruN cdirip-0.6.2.orig/2unix cdirip-0.6.2/2unix
--- cdirip-0.6.2.orig/2unix	1969-12-31 19:00:00.000000000 -0500
+++ cdirip-0.6.2/2unix	2002-06-20 11:34:23.000000000 -0400
@@ -0,0 +1 @@
+find . -type f \! -name "*.o" -print | xargs perl -p -i -e 's/\r\n/\n/;'
diff -ruN cdirip-0.6.2.orig/Makefile.linux cdirip-0.6.2/Makefile.linux
--- cdirip-0.6.2.orig/Makefile.linux	2002-04-02 22:12:18.000000000 -0500
+++ cdirip-0.6.2/Makefile.linux	2002-06-20 13:05:20.000000000 -0400
@@ -1,37 +1,36 @@
-#####################################
-#                                   #
-#  Makefile for CDIrip
-#  Generated by Bloodshed Dev-C++   #
-#                                   #
-#####################################
-
-
-# Compiler
-CC=gcc
-# Parameters given to the compiler
-CFLAGS=-s -O1  -I/usr/include -I/include    
-# Output filename (*.exe)
-OUTPUT=cdirip
-
-# Source files
-SRCS=cdirip.c buffer.c cdi.c common.c 
-# Output object files (*.o)
-OBJS=cdirip.o buffer.o cdi.o common.o
-
-# Standard targets
-
-all: compile_res
-	$(CC) -c $(SRCS) $(CFLAGS)
-	$(CC) -o $(OUTPUT) $(OBJS) $(CFLAGS)
-
-compile_res:
-
-
-test: all
-	./$(OUTPUT)
-
-clean:
-	del *.o
-
-mrproper: clean
-
+#####################################
+#                                   #
+#  Makefile for CDIrip              #
+#  Generated by Bloodshed Dev-C++   #
+#                                   #
+#####################################
+
+
+# Compiler
+CC=gcc
+# Parameters given to the compiler
+CFLAGS=-I/usr/include -I/include    
+# Output filename (*.exe)
+OUTPUT=cdirip
+
+# Source files
+SRCS=cdirip.c buffer.c cdi.c common.c audio.c
+# Output object files (*.o)
+OBJS=cdirip.o buffer.o cdi.o common.o audio.o
+
+# Standard targets
+
+all: compile_res
+	$(CC) -c $(SRCS) $(CFLAGS)
+	$(CC) -o $(OUTPUT) $(OBJS) $(CFLAGS)
+
+compile_res:
+
+
+test: all
+	./$(OUTPUT)
+
+clean:
+	rm -f *.o
+
+mrproper: clean
diff -ruN cdirip-0.6.2.orig/audio.c cdirip-0.6.2/audio.c
--- cdirip-0.6.2.orig/audio.c	2002-04-09 02:44:12.000000000 -0400
+++ cdirip-0.6.2/audio.c	2002-06-20 11:34:53.000000000 -0400
@@ -1,186 +1,185 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include "audio.h"
-
-
-
-void writewavheader(FILE *fdest, long track_length)
-{
-unsigned long  wTotal_length;
-unsigned long  wData_length;
-unsigned long  wHeaderLength = 16;
-unsigned short wFormat = 1;
-unsigned short wChannels = 2;
-unsigned long  wSampleRate = 44100;
-unsigned long  wBitRate = 176400;
-unsigned short wBlockAlign = 4;
-unsigned short wBitsPerSample = 16;
-
-      wData_length = track_length*2352;
-      wTotal_length = wData_length + 8 + 16 + 12;
-
-      fwrite("RIFF", 4, 1, fdest);
-      fwrite_as_little(&wTotal_length, 4, fdest);
-      fwrite("WAVE", 4, 1, fdest);
-      fwrite("fmt ", 4, 1, fdest);
-      fwrite_as_little(&wHeaderLength, 4, fdest);
-      fwrite_as_little(&wFormat, 2, fdest);
-      fwrite_as_little(&wChannels, 2, fdest);
-      fwrite_as_little(&wSampleRate, 4, fdest);
-      fwrite_as_little(&wBitRate, 4, fdest);
-      fwrite_as_little(&wBlockAlign, 2, fdest);
-      fwrite_as_little(&wBitsPerSample, 2, fdest);
-      fwrite("data", 4, 1, fdest);
-      fwrite_as_little(&wData_length, 4, fdest);
-}
-
-
-void writeaiffheader(FILE *fdest, long track_length)
-{
-unsigned long  source_length, total_length;
-unsigned char  buf[4];
-unsigned long  aCommSize = 18;
-unsigned short aChannels = 2;
-unsigned long  aNumFrames;
-unsigned short aBitsPerSample = 16;
-unsigned long  aSampleRate = 44100;
-unsigned long  aSsndSize;
-unsigned long  aOffset = 0;
-unsigned long  aBlockSize = 0;
-
-
-      source_length = track_length*2352;
-      total_length = source_length + 8 + 18 + 8 + 12; // COMM + SSND
-      aNumFrames = source_length/4;
-      aSsndSize = source_length + 8;
-
-      fwrite("FORM", 4, 1, fdest);
-
-      fwrite_as_big(&total_length, 4, fdest);
-
-      fwrite("AIFF", 4, 1, fdest);
-      fwrite("COMM", 4, 1, fdest);
-
-      fwrite_as_big(&aCommSize, 4, fdest);
-      fwrite_as_big(&aChannels, 2, fdest);
-      fwrite_as_big(&aNumFrames, 4, fdest);
-      fwrite_as_big(&aBitsPerSample, 2, fdest);
-
-      write_ieee_extended(fdest, (double)aSampleRate);
-
-      fwrite("SSND", 4, 1, fdest);
-
-      fwrite_as_big(&aSsndSize, 4, fdest);
-      fwrite_as_big(&aOffset, 4, fdest);
-      fwrite_as_big(&aBlockSize, 4, fdest);
-}
-
-
-void write_ieee_extended(FILE *fdest, double x)
-{
-	char buf[10];
-	ConvertToIeeeExtended(x, buf);
-	/*
-	report("converted %g to %o %o %o %o %o %o %o %o %o %o",
-		x,
-		buf[0], buf[1], buf[2], buf[3], buf[4],
-		buf[5], buf[6], buf[7], buf[8], buf[9]);
-	*/
-	(void) fwrite(buf, 1, 10, fdest);
-}
-
-
-
-/*
- * C O N V E R T   T O   I E E E   E X T E N D E D
- */
-
-/* Copyright (C) 1988-1991 Apple Computer, Inc.
- * All rights reserved.
- *
- * Machine-independent I/O routines for IEEE floating-point numbers.
- *
- * NaN's and infinities are converted to HUGE_VAL or HUGE, which
- * happens to be infinity on IEEE machines.  Unfortunately, it is
- * impossible to preserve NaN's in a machine-independent way.
- * Infinities are, however, preserved on IEEE machines.
- *
- * These routines have been tested on the following machines:
- *    Apple Macintosh, MPW 3.1 C compiler
- *    Apple Macintosh, THINK C compiler
- *    Silicon Graphics IRIS, MIPS compiler
- *    Cray X/MP and Y/MP
- *    Digital Equipment VAX
- *
- *
- * Implemented by Malcolm Slaney and Ken Turkowski.
- *
- * Malcolm Slaney contributions during 1988-1990 include big- and little-
- * endian file I/O, conversion to and from Motorola's extended 80-bit
- * floating-point format, and conversions to and from IEEE single-
- * precision floating-point format.
- *
- * In 1991, Ken Turkowski implemented the conversions to and from
- * IEEE double-precision format, added more precision to the extended
- * conversions, and accommodated conversions involving +/- infinity,
- * NaN's, and denormalized numbers.
- */
-
-#ifndef HUGE_VAL
-# define HUGE_VAL HUGE
-#endif /*HUGE_VAL*/
-
-# define FloatToUnsigned(f)      ((unsigned long)(((long)(f - 2147483648.0)) + 2147483647L) + 1)
-
-void ConvertToIeeeExtended(double num, char *bytes)
-{
-    int    sign;
-    int expon;
-    double fMant, fsMant;
-    unsigned long hiMant, loMant;
-
-    if (num < 0) {
-        sign = 0x8000;
-        num *= -1;
-    } else {
-        sign = 0;
-    }
-
-    if (num == 0) {
-        expon = 0; hiMant = 0; loMant = 0;
-    }
-    else {
-        fMant = frexp(num, &expon);
-        if ((expon > 16384) || !(fMant < 1)) {    /* Infinity or NaN */
-            expon = sign|0x7FFF; hiMant = 0; loMant = 0; /* infinity */
-        }
-        else {    /* Finite */
-            expon += 16382;
-            if (expon < 0) {    /* denormalized */
-                fMant = ldexp(fMant, expon);
-                expon = 0;
-            }
-            expon |= sign;
-            fMant = ldexp(fMant, 32);          
-            fsMant = floor(fMant); 
-            hiMant = FloatToUnsigned(fsMant);
-            fMant = ldexp(fMant - fsMant, 32); 
-            fsMant = floor(fMant); 
-            loMant = FloatToUnsigned(fsMant);
-        }
-    }
-    
-    bytes[0] = expon >> 8;
-    bytes[1] = expon;
-    bytes[2] = hiMant >> 24;
-    bytes[3] = hiMant >> 16;
-    bytes[4] = hiMant >> 8;
-    bytes[5] = hiMant;
-    bytes[6] = loMant >> 24;
-    bytes[7] = loMant >> 16;
-    bytes[8] = loMant >> 8;
-    bytes[9] = loMant;
-}
-
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+#include "audio.h"
+
+
+
+void writewavheader(FILE *fdest, long track_length)
+{
+unsigned long  wTotal_length;
+unsigned long  wData_length;
+unsigned long  wHeaderLength = 16;
+unsigned short wFormat = 1;
+unsigned short wChannels = 2;
+unsigned long  wSampleRate = 44100;
+unsigned long  wBitRate = 176400;
+unsigned short wBlockAlign = 4;
+unsigned short wBitsPerSample = 16;
+
+      wData_length = track_length*2352;
+      wTotal_length = wData_length + 8 + 16 + 12;
+
+      fwrite("RIFF", 4, 1, fdest);
+      fwrite_as_little(&wTotal_length, 4, fdest);
+      fwrite("WAVE", 4, 1, fdest);
+      fwrite("fmt ", 4, 1, fdest);
+      fwrite_as_little(&wHeaderLength, 4, fdest);
+      fwrite_as_little(&wFormat, 2, fdest);
+      fwrite_as_little(&wChannels, 2, fdest);
+      fwrite_as_little(&wSampleRate, 4, fdest);
+      fwrite_as_little(&wBitRate, 4, fdest);
+      fwrite_as_little(&wBlockAlign, 2, fdest);
+      fwrite_as_little(&wBitsPerSample, 2, fdest);
+      fwrite("data", 4, 1, fdest);
+      fwrite_as_little(&wData_length, 4, fdest);
+}
+
+
+void writeaiffheader(FILE *fdest, long track_length)
+{
+unsigned long  source_length, total_length;
+unsigned char  buf[4];
+unsigned long  aCommSize = 18;
+unsigned short aChannels = 2;
+unsigned long  aNumFrames;
+unsigned short aBitsPerSample = 16;
+unsigned long  aSampleRate = 44100;
+unsigned long  aSsndSize;
+unsigned long  aOffset = 0;
+unsigned long  aBlockSize = 0;
+
+
+      source_length = track_length*2352;
+      total_length = source_length + 8 + 18 + 8 + 12; // COMM + SSND
+      aNumFrames = source_length/4;
+      aSsndSize = source_length + 8;
+
+      fwrite("FORM", 4, 1, fdest);
+
+      fwrite_as_big(&total_length, 4, fdest);
+
+      fwrite("AIFF", 4, 1, fdest);
+      fwrite("COMM", 4, 1, fdest);
+
+      fwrite_as_big(&aCommSize, 4, fdest);
+      fwrite_as_big(&aChannels, 2, fdest);
+      fwrite_as_big(&aNumFrames, 4, fdest);
+      fwrite_as_big(&aBitsPerSample, 2, fdest);
+
+      write_ieee_extended(fdest, (double)aSampleRate);
+
+      fwrite("SSND", 4, 1, fdest);
+
+      fwrite_as_big(&aSsndSize, 4, fdest);
+      fwrite_as_big(&aOffset, 4, fdest);
+      fwrite_as_big(&aBlockSize, 4, fdest);
+}
+
+
+void write_ieee_extended(FILE *fdest, double x)
+{
+	char buf[10];
+	ConvertToIeeeExtended(x, buf);
+	/*
+	report("converted %g to %o %o %o %o %o %o %o %o %o %o",
+		x,
+		buf[0], buf[1], buf[2], buf[3], buf[4],
+		buf[5], buf[6], buf[7], buf[8], buf[9]);
+	*/
+	(void) fwrite(buf, 1, 10, fdest);
+}
+
+
+
+/*
+ * C O N V E R T   T O   I E E E   E X T E N D E D
+ */
+
+/* Copyright (C) 1988-1991 Apple Computer, Inc.
+ * All rights reserved.
+ *
+ * Machine-independent I/O routines for IEEE floating-point numbers.
+ *
+ * NaN's and infinities are converted to HUGE_VAL or HUGE, which
+ * happens to be infinity on IEEE machines.  Unfortunately, it is
+ * impossible to preserve NaN's in a machine-independent way.
+ * Infinities are, however, preserved on IEEE machines.
+ *
+ * These routines have been tested on the following machines:
+ *    Apple Macintosh, MPW 3.1 C compiler
+ *    Apple Macintosh, THINK C compiler
+ *    Silicon Graphics IRIS, MIPS compiler
+ *    Cray X/MP and Y/MP
+ *    Digital Equipment VAX
+ *
+ *
+ * Implemented by Malcolm Slaney and Ken Turkowski.
+ *
+ * Malcolm Slaney contributions during 1988-1990 include big- and little-
+ * endian file I/O, conversion to and from Motorola's extended 80-bit
+ * floating-point format, and conversions to and from IEEE single-
+ * precision floating-point format.
+ *
+ * In 1991, Ken Turkowski implemented the conversions to and from
+ * IEEE double-precision format, added more precision to the extended
+ * conversions, and accommodated conversions involving +/- infinity,
+ * NaN's, and denormalized numbers.
+ */
+
+#ifndef HUGE_VAL
+# define HUGE_VAL HUGE
+#endif /*HUGE_VAL*/
+
+# define FloatToUnsigned(f)      ((unsigned long)(((long)(f - 2147483648.0)) + 2147483647L) + 1)
+
+void ConvertToIeeeExtended(double num, char *bytes)
+{
+    int    sign;
+    int expon;
+    double fMant, fsMant;
+    unsigned long hiMant, loMant;
+
+    if (num < 0) {
+        sign = 0x8000;
+        num *= -1;
+    } else {
+        sign = 0;
+    }
+
+    if (num == 0) {
+        expon = 0; hiMant = 0; loMant = 0;
+    }
+    else {
+        fMant = frexp(num, &expon);
+        if ((expon > 16384) || !(fMant < 1)) {    /* Infinity or NaN */
+            expon = sign|0x7FFF; hiMant = 0; loMant = 0; /* infinity */
+        }
+        else {    /* Finite */
+            expon += 16382;
+            if (expon < 0) {    /* denormalized */
+                fMant = ldexp(fMant, expon);
+                expon = 0;
+            }
+            expon |= sign;
+            fMant = ldexp(fMant, 32);          
+            fsMant = floor(fMant); 
+            hiMant = FloatToUnsigned(fsMant);
+            fMant = ldexp(fMant - fsMant, 32); 
+            fsMant = floor(fMant); 
+            loMant = FloatToUnsigned(fsMant);
+        }
+    }
+    
+    bytes[0] = expon >> 8;
+    bytes[1] = expon;
+    bytes[2] = hiMant >> 24;
+    bytes[3] = hiMant >> 16;
+    bytes[4] = hiMant >> 8;
+    bytes[5] = hiMant;
+    bytes[6] = loMant >> 24;
+    bytes[7] = loMant >> 16;
+    bytes[8] = loMant >> 8;
+    bytes[9] = loMant;
+}
diff -ruN cdirip-0.6.2.orig/audio.h cdirip-0.6.2/audio.h
--- cdirip-0.6.2.orig/audio.h	2002-04-09 02:44:12.000000000 -0400
+++ cdirip-0.6.2/audio.h	2002-06-20 11:34:58.000000000 -0400
@@ -1,10 +1,9 @@
-#ifndef __AUDIO_H__
-#define __AUDIO_H__
-
-void writewavheader(FILE *fdest, long track_length);
-void writeaiffheader(FILE *fdest, long track_length);
-void write_ieee_extended(FILE *fdest, double x);
-void ConvertToIeeeExtended(double num, char *bytes);
-
-#endif
-
+#ifndef __AUDIO_H__
+#define __AUDIO_H__
+
+void writewavheader(FILE *fdest, long track_length);
+void writeaiffheader(FILE *fdest, long track_length);
+void write_ieee_extended(FILE *fdest, double x);
+void ConvertToIeeeExtended(double num, char *bytes);
+
+#endif
diff -ruN cdirip-0.6.2.orig/buffer.c cdirip-0.6.2/buffer.c
--- cdirip-0.6.2.orig/buffer.c	2001-03-15 12:45:26.000000000 -0500
+++ cdirip-0.6.2/buffer.c	2002-06-20 11:35:12.000000000 -0400
@@ -1,80 +1,79 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include "buffer.h"
-
-
-int BufWrite (char *data, long data_size, struct buffer_s *buffer)
-{
-     long write_length;
-
-     if (data_size > (buffer->size + (buffer->size - buffer->index - 1)))
-        return 0;  // unimplemented
-
-     if (buffer->index + data_size < buffer->size)  // 1 menos
-     {
-        memcpy ((buffer->ptr + buffer->index), data, data_size);
-        buffer->index += data_size;
-     }
-     else
-     {
-         write_length = buffer->size - buffer->index;
-         memcpy ((buffer->ptr + buffer->index), data, write_length);
-         fwrite (buffer->ptr, buffer->size, 1, buffer->file);
-         memcpy (buffer->ptr, data + write_length, data_size - write_length);
-         buffer->index = data_size - write_length;
-     }
-
-return 1;
-}
-
-int BufWriteFlush (struct buffer_s *buffer)
-{
-
-     fwrite (buffer->ptr, buffer->index, 1, buffer->file);
-     buffer->index = 0;
-
-return 1;
-}
-
-
-int BufRead (char *data, long data_size, struct buffer_s *buffer, long filesize)
-{
-     long read_length, max_length, pos;
-
-     if (data_size > (buffer->size + (buffer->size - buffer->index - 1)))
-        return 0;  // unimplemented
-
-     if (filesize == 0)  // no cuenta
-     {
-        max_length = buffer->size;
-     }
-     else
-     {
-        pos = ftell(buffer->file);
-        if (pos > filesize) max_length = 0;
-        else max_length = ((pos + buffer->size) > filesize) ? (filesize - pos) : buffer->size;
-     }
-
-     if (buffer->index == 0)
-     {
-        fread(buffer->ptr, max_length, 1, buffer->file);
-     }
-
-     if (buffer->index + data_size <= buffer->size)
-     {
-        memcpy (data, buffer->ptr + buffer->index, data_size);
-        buffer->index += data_size;
-        if (buffer->index >= buffer->size) buffer->index = 0;
-     }
-     else
-     {
-         read_length = buffer->size - buffer->index;
-         memcpy (data, buffer->ptr + buffer->index, read_length);
-         fread (buffer->ptr, max_length, 1, buffer->file);
-         memcpy (data + read_length, buffer->ptr, data_size - read_length);
-         buffer->index = data_size - read_length;
-     }
-
-return 1;
-}
-
+#include <stdio.h>
+#include <stdlib.h>
+#include "buffer.h"
+
+
+int BufWrite (char *data, long data_size, struct buffer_s *buffer)
+{
+     long write_length;
+
+     if (data_size > (buffer->size + (buffer->size - buffer->index - 1)))
+        return 0;  // unimplemented
+
+     if (buffer->index + data_size < buffer->size)  // 1 menos
+     {
+        memcpy ((buffer->ptr + buffer->index), data, data_size);
+        buffer->index += data_size;
+     }
+     else
+     {
+         write_length = buffer->size - buffer->index;
+         memcpy ((buffer->ptr + buffer->index), data, write_length);
+         fwrite (buffer->ptr, buffer->size, 1, buffer->file);
+         memcpy (buffer->ptr, data + write_length, data_size - write_length);
+         buffer->index = data_size - write_length;
+     }
+
+return 1;
+}
+
+int BufWriteFlush (struct buffer_s *buffer)
+{
+
+     fwrite (buffer->ptr, buffer->index, 1, buffer->file);
+     buffer->index = 0;
+
+return 1;
+}
+
+
+int BufRead (char *data, long data_size, struct buffer_s *buffer, long filesize)
+{
+     long read_length, max_length, pos;
+
+     if (data_size > (buffer->size + (buffer->size - buffer->index - 1)))
+        return 0;  // unimplemented
+
+     if (filesize == 0)  // no cuenta
+     {
+        max_length = buffer->size;
+     }
+     else
+     {
+        pos = ftell(buffer->file);
+        if (pos > filesize) max_length = 0;
+        else max_length = ((pos + buffer->size) > filesize) ? (filesize - pos) : buffer->size;
+     }
+
+     if (buffer->index == 0)
+     {
+        fread(buffer->ptr, max_length, 1, buffer->file);
+     }
+
+     if (buffer->index + data_size <= buffer->size)
+     {
+        memcpy (data, buffer->ptr + buffer->index, data_size);
+        buffer->index += data_size;
+        if (buffer->index >= buffer->size) buffer->index = 0;
+     }
+     else
+     {
+         read_length = buffer->size - buffer->index;
+         memcpy (data, buffer->ptr + buffer->index, read_length);
+         fread (buffer->ptr, max_length, 1, buffer->file);
+         memcpy (data + read_length, buffer->ptr, data_size - read_length);
+         buffer->index = data_size - read_length;
+     }
+
+return 1;
+}
diff -ruN cdirip-0.6.2.orig/buffer.h cdirip-0.6.2/buffer.h
--- cdirip-0.6.2.orig/buffer.h	2001-03-06 14:18:24.000000000 -0500
+++ cdirip-0.6.2/buffer.h	2002-06-20 11:35:14.000000000 -0400
@@ -1,16 +1,15 @@
-#ifndef __BUFFER_H__
-#define __BUFFER_H__
-
-struct buffer_s {
-       FILE *file;
-       char *ptr;
-       long index;
-       long size;
-       };
-
-int BufRead (char *data, long size, struct buffer_s *buffer, long filesize);
-int BufWrite (char *data, long size, struct buffer_s *buffer);
-int BufWriteFlush (struct buffer_s *buffer);
-
-#endif
-
+#ifndef __BUFFER_H__
+#define __BUFFER_H__
+
+struct buffer_s {
+       FILE *file;
+       char *ptr;
+       long index;
+       long size;
+       };
+
+int BufRead (char *data, long size, struct buffer_s *buffer, long filesize);
+int BufWrite (char *data, long size, struct buffer_s *buffer);
+int BufWriteFlush (struct buffer_s *buffer);
+
+#endif
Binary files cdirip-0.6.2.orig/buffer.o and cdirip-0.6.2/buffer.o differ
diff -ruN cdirip-0.6.2.orig/cdi.c cdirip-0.6.2/cdi.c
--- cdirip-0.6.2.orig/cdi.c	2002-06-08 02:15:04.000000000 -0400
+++ cdirip-0.6.2/cdi.c	2002-06-20 11:22:27.000000000 -0400
@@ -1,140 +1,140 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include "common.h"
-#include "cdi.h"
-
-// Global variables
-
-unsigned long temp_value;
-
-
-/////////////////////////////////////////////////////////////////////////////
-
-
-unsigned long ask_type(FILE *fsource, long header_position)
-{
-
-unsigned char filename_length;
-unsigned long track_mode;
-
-    fseek(fsource, header_position, SEEK_SET);
-    fread_as_little(&temp_value, 4, fsource);
-    if (temp_value != 0)
-       fseek(fsource, 8, SEEK_CUR); // extra data (DJ 3.00.780 and up)
-    fseek(fsource, 24, SEEK_CUR);
-    fread_as_little(&filename_length, 1, fsource);
-    fseek(fsource, filename_length, SEEK_CUR);
-    fseek(fsource, 19, SEEK_CUR);
-    fread_as_little(&temp_value, 4, fsource);
-       if (temp_value == 0x80000000)
-          fseek(fsource, 8, SEEK_CUR); // DJ4
-    fseek(fsource, 16, SEEK_CUR);
-    fread_as_little(&track_mode, 4, fsource);
-    fseek(fsource, header_position, SEEK_SET);
-    return (track_mode);
-}
-
-
-/////////////////////////////////////////////////////////////////////////////
-
-
-void CDI_read_track (FILE *fsource, image_s *image, track_s *track)
-{
-
-     char TRACK_START_MARK[10] = { 0, 0, 0x01, 0, 0, 0, 0xFF, 0xFF, 0xFF, 0xFF };
-     char current_start_mark[10];
-
-         fread_as_little(&temp_value, 4, fsource);
-         if (temp_value != 0)
-            fseek(fsource, 8, SEEK_CUR); // extra data (DJ 3.00.780 and up)
-
-         fread(&current_start_mark, 10, 1, fsource);
-         if (memcmp(TRACK_START_MARK, current_start_mark, 10)) error_exit(ERR_GENERIC, "Unsupported format: Could not find the track start mark");
-
-         fread(&current_start_mark, 10, 1, fsource);
-         if (memcmp(TRACK_START_MARK, current_start_mark, 10)) error_exit(ERR_GENERIC, "Unsupported format: Could not find the track start mark");
-
-         fseek(fsource, 4, SEEK_CUR);
-         fread_as_little(&track->filename_length, 1, fsource);
-         fseek(fsource, track->filename_length, SEEK_CUR);
-         fseek(fsource, 11, SEEK_CUR);
-         fseek(fsource, 4, SEEK_CUR);
-         fseek(fsource, 4, SEEK_CUR);
-         fread_as_little(&temp_value, 4, fsource);
-            if (temp_value == 0x80000000)
-               fseek(fsource, 8, SEEK_CUR); // DJ4
-         fseek(fsource, 2, SEEK_CUR);
-         fread_as_little(&track->pregap_length, 4, fsource);
-         fread_as_little(&track->length, 4, fsource);
-         fseek(fsource, 6, SEEK_CUR);
-         fread_as_little(&track->mode, 4, fsource);
-         fseek(fsource, 12, SEEK_CUR);
-         fread_as_little(&track->start_lba, 4, fsource);
-         fread_as_little(&track->total_length, 4, fsource);
-         fseek(fsource, 16, SEEK_CUR);
-         fread_as_little(&track->sector_size_value, 4, fsource);
-
-         switch(track->sector_size_value)
-               {
-               case 0 : track->sector_size = 2048; break;
-               case 1 : track->sector_size = 2336; break;
-               case 2 : track->sector_size = 2352; break;
-               default: error_exit(ERR_GENERIC, "Unsupported sector size");
-               }
-
-         if (track->mode > 2) error_exit(ERR_GENERIC, "Unsupported format: Track mode not supported");
-
-         fseek(fsource, 29, SEEK_CUR);
-         if (image->version != CDI_V2)
-            {
-            fseek(fsource, 5, SEEK_CUR);
-            fread_as_little(&temp_value, 4, fsource);
-            if (temp_value == 0xffffffff)
-                fseek(fsource, 78, SEEK_CUR); // extra data (DJ 3.00.780 and up)
-            }
-}
-
-
-void CDI_skip_next_session (FILE *fsource, image_s *image)
-{
-     fseek(fsource, 4, SEEK_CUR);
-     fseek(fsource, 8, SEEK_CUR);
-     if (image->version != CDI_V2) fseek(fsource, 1, SEEK_CUR);
-}
-
-void CDI_get_tracks (FILE *fsource, image_s *image)
-{
-     fread_as_little(&image->tracks, 2, fsource);
-}
-
-void CDI_init (FILE *fsource, image_s *image, char *fsourcename)
-{
-     fseek(fsource, 0L, SEEK_END);
-     image->length = ftell(fsource);
-
-     if (image->length < 8) error_exit(ERR_GENERIC, "Image file is too short");
-
-     fseek(fsource, image->length-8, SEEK_SET);
-     fread_as_little(&image->version, 4, fsource);
-     fread_as_little(&image->header_offset, 4, fsource);
-
-     if (errno != 0) error_exit(ERR_READIMAGE, fsourcename);
-     if (image->header_offset == 0) error_exit(ERR_GENERIC, "Bad image format");
-}
-
-void CDI_get_sessions (FILE *fsource, image_s *image)
-{
-#ifndef DEBUG_CDI
-     if (image->version == CDI_V35)
-        fseek(fsource, (image->length - image->header_offset), SEEK_SET);
-     else
-        fseek(fsource, image->header_offset, SEEK_SET);
-
-#else
-     fseek(fsource, 0L, SEEK_SET);
-#endif
-     fread_as_little(&image->sessions, 2, fsource);
-}
-
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "common.h"
+#include "cdi.h"
+
+// Global variables
+
+unsigned long temp_value;
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+
+unsigned long ask_type(FILE *fsource, long header_position)
+{
+
+unsigned char filename_length;
+unsigned long track_mode;
+
+    fseek(fsource, header_position, SEEK_SET);
+    fread_as_little(&temp_value, 4, fsource);
+    if (temp_value != 0)
+       fseek(fsource, 8, SEEK_CUR); // extra data (DJ 3.00.780 and up)
+    fseek(fsource, 24, SEEK_CUR);
+    fread_as_little(&filename_length, 1, fsource);
+    fseek(fsource, filename_length, SEEK_CUR);
+    fseek(fsource, 19, SEEK_CUR);
+    fread_as_little(&temp_value, 4, fsource);
+       if (temp_value == 0x80000000)
+          fseek(fsource, 8, SEEK_CUR); // DJ4
+    fseek(fsource, 16, SEEK_CUR);
+    fread_as_little(&track_mode, 4, fsource);
+    fseek(fsource, header_position, SEEK_SET);
+    return (track_mode);
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+
+void CDI_read_track (FILE *fsource, image_s *image, track_s *track)
+{
+
+     char TRACK_START_MARK[10] = { 0, 0, 0x01, 0, 0, 0, 0xFF, 0xFF, 0xFF, 0xFF };
+     char current_start_mark[10];
+
+         fread_as_little(&temp_value, 4, fsource);
+         if (temp_value != 0)
+            fseek(fsource, 8, SEEK_CUR); // extra data (DJ 3.00.780 and up)
+
+         fread(&current_start_mark, 10, 1, fsource);
+         if (memcmp(TRACK_START_MARK, current_start_mark, 10)) error_exit(ERR_GENERIC, "Unsupported format: Could not find the track start mark");
+
+         fread(&current_start_mark, 10, 1, fsource);
+         if (memcmp(TRACK_START_MARK, current_start_mark, 10)) error_exit(ERR_GENERIC, "Unsupported format: Could not find the track start mark");
+
+         fseek(fsource, 4, SEEK_CUR);
+         fread_as_little(&track->filename_length, 1, fsource);
+         fseek(fsource, track->filename_length, SEEK_CUR);
+         fseek(fsource, 11, SEEK_CUR);
+         fseek(fsource, 4, SEEK_CUR);
+         fseek(fsource, 4, SEEK_CUR);
+         fread_as_little(&temp_value, 4, fsource);
+            if (temp_value == 0x80000000)
+               fseek(fsource, 8, SEEK_CUR); // DJ4
+         fseek(fsource, 2, SEEK_CUR);
+         fread_as_little(&track->pregap_length, 4, fsource);
+         fread_as_little(&track->length, 4, fsource);
+         fseek(fsource, 6, SEEK_CUR);
+         fread_as_little(&track->mode, 4, fsource);
+         fseek(fsource, 12, SEEK_CUR);
+         fread_as_little(&track->start_lba, 4, fsource);
+         fread_as_little(&track->total_length, 4, fsource);
+         fseek(fsource, 16, SEEK_CUR);
+         fread_as_little(&track->sector_size_value, 4, fsource);
+
+         switch(track->sector_size_value)
+               {
+               case 0 : track->sector_size = 2048; break;
+               case 1 : track->sector_size = 2336; break;
+               case 2 : track->sector_size = 2352; break;
+               default: error_exit(ERR_GENERIC, "Unsupported sector size");
+               }
+
+         if (track->mode > 2) error_exit(ERR_GENERIC, "Unsupported format: Track mode not supported");
+
+         fseek(fsource, 29, SEEK_CUR);
+         if (image->version != CDI_V2)
+            {
+            fseek(fsource, 5, SEEK_CUR);
+            fread_as_little(&temp_value, 4, fsource);
+            if (temp_value == 0xffffffff)
+                fseek(fsource, 78, SEEK_CUR); // extra data (DJ 3.00.780 and up)
+            }
+}
+
+
+void CDI_skip_next_session (FILE *fsource, image_s *image)
+{
+     fseek(fsource, 4, SEEK_CUR);
+     fseek(fsource, 8, SEEK_CUR);
+     if (image->version != CDI_V2) fseek(fsource, 1, SEEK_CUR);
+}
+
+void CDI_get_tracks (FILE *fsource, image_s *image)
+{
+     fread_as_little(&image->tracks, 2, fsource);
+}
+
+void CDI_init (FILE *fsource, image_s *image, char *fsourcename)
+{
+     fseek(fsource, 0L, SEEK_END);
+     image->length = ftell(fsource);
+
+     if (image->length < 8) error_exit(ERR_GENERIC, "Image file is too short");
+
+     fseek(fsource, image->length-8, SEEK_SET);
+     fread_as_little(&image->version, 4, fsource);
+     fread_as_little(&image->header_offset, 4, fsource);
+
+     if (errno != 0) error_exit(ERR_READIMAGE, fsourcename);
+     if (image->header_offset == 0) error_exit(ERR_GENERIC, "Bad image format");
+}
+
+void CDI_get_sessions (FILE *fsource, image_s *image)
+{
+#ifndef DEBUG_CDI
+     if (image->version == CDI_V35)
+        fseek(fsource, (image->length - image->header_offset), SEEK_SET);
+     else
+        fseek(fsource, image->header_offset, SEEK_SET);
+
+#else
+     fseek(fsource, 0L, SEEK_SET);
+#endif
+     fread_as_little(&image->sessions, 2, fsource);
+}
+
diff -ruN cdirip-0.6.2.orig/cdi.h cdirip-0.6.2/cdi.h
--- cdirip-0.6.2.orig/cdi.h	2001-12-25 23:53:00.000000000 -0500
+++ cdirip-0.6.2/cdi.h	2002-06-20 11:35:41.000000000 -0400
@@ -1,16 +1,15 @@
-#ifndef __CDI_H__
-#define __CDI_H__
-
-#define CDI_V2  0x80000004
-#define CDI_V3  0x80000005
-#define CDI_V35 0x80000006
-
-unsigned long ask_type(FILE *fsource, long header_position);
-void CDI_init (FILE *fsource, image_s *image, char *fsourcename);
-void CDI_get_sessions (FILE *fsource, image_s *image);
-void CDI_get_tracks (FILE *fsource, image_s *image);
-void CDI_read_track (FILE *fsource, image_s *image, track_s *track);
-void CDI_skip_next_session (FILE *fsource, image_s *image);
-
-#endif
-
+#ifndef __CDI_H__
+#define __CDI_H__
+
+#define CDI_V2  0x80000004
+#define CDI_V3  0x80000005
+#define CDI_V35 0x80000006
+
+unsigned long ask_type(FILE *fsource, long header_position);
+void CDI_init (FILE *fsource, image_s *image, char *fsourcename);
+void CDI_get_sessions (FILE *fsource, image_s *image);
+void CDI_get_tracks (FILE *fsource, image_s *image);
+void CDI_read_track (FILE *fsource, image_s *image, track_s *track);
+void CDI_skip_next_session (FILE *fsource, image_s *image);
+
+#endif
Binary files cdirip-0.6.2.orig/cdi.o and cdirip-0.6.2/cdi.o differ
diff -ruN cdirip-0.6.2.orig/cdirip.c cdirip-0.6.2/cdirip.c
--- cdirip-0.6.2.orig/cdirip.c	2002-06-08 02:15:04.000000000 -0400
+++ cdirip-0.6.2/cdirip.c	2002-06-20 13:27:10.000000000 -0400
@@ -1,799 +1,820 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <limits.h>
-#ifdef _WIN32
-#include <windows.h>
-#include <shlobj.h>
-#endif
-#include "common.h"
-#include "cdirip.h"
-#include "buffer.h"
-#include "cdi.h"
-#include "audio.h"
-
-// Linux add-ons by Pedro Melo
-
-#ifndef _WIN32
-#define MAX_PATH PATH_MAX
-#endif
-
-#ifdef __BORLANDC__
-#define strcasecmp stricmp
-#endif
-
-// Global variables
-
-char *global_read_buffer_ptr;
-char *global_write_buffer_ptr;
-
-// Main function
-
-int main( int argc, char **argv )
-{
-
-int  i;
-char cuesheetname[13], filename[MAX_PATH], destpath[MAX_PATH];
-FILE *fsource, *fcuesheet;
-
-image_s image = { 0, };
-track_s track = { 0, };
-opts_s  opts  = { 0, };
-flags_s flags = { 0, };
-
-image.global_current_session = 0;
-track.global_current_track   = 0;
-track.position               = 0;
-
-// Opciones
-
-printf("CDIrip 0.6.2 - (C) 2002 by DeXT\n\n");
-
-flags.ask_for_image = true;
-flags.ask_for_dest_path = true;
-
-opts.audio = WAV_FORMAT;
-
-#ifndef _WIN32
-opts.convert = ISO_FORMAT;  // Linux only!
-#else
-opts.convert = DEFAULT_FORMAT;
-#endif
-
-if (argc >= 2)
-   {
-   for(i = 1; i < argc; i++)
-     {
-#ifdef _WIN32
-     if (argv[i][0] == '/' || argv[i][0] == '-')
-#else
-     if (argv[i][0] == '-')    // Linux absolute paths start with '/'
-#endif
-      {
-      if (!strcasecmp(argv[i]+1,"iso"    )) opts.convert   = ISO_FORMAT;
-      if (!strcasecmp(argv[i]+1,"bin"    )) opts.convert   = BIN_FORMAT;
-      if (!strcasecmp(argv[i]+1,"mac"    )) opts.convert   = MAC_FORMAT; // ISO/2056
-      if (!strcasecmp(argv[i]+1,"raw"    )) opts.audio     = RAW_FORMAT;
-      if (!strcasecmp(argv[i]+1,"cda"    )) opts.audio     = CDA_FORMAT;
-      if (!strcasecmp(argv[i]+1,"wav"    )) opts.audio     = WAV_FORMAT;
-      if (!strcasecmp(argv[i]+1,"aiff"   )) opts.audio     = AIFF_FORMAT;
-      if (!strcasecmp(argv[i]+1,"info"   )) opts.showinfo  = true;
-      if (!strcasecmp(argv[i]+1,"cut"    )) opts.cutfirst  = true;
-      if (!strcasecmp(argv[i]+1,"cutall" )) opts.cutall    = true;
-      if (!strcasecmp(argv[i]+1,"full"   )) opts.fulldata  = true;
-      if (!strcasecmp(argv[i]+1,"swap"   )) opts.swap      = true;
-      if (!strcasecmp(argv[i]+1,"speed"  )) opts.showspeed = true;
-      if (!strcasecmp(argv[i]+1,"pregap" )) opts.pregap    = true;
-
-      if (!strcasecmp(argv[i]+1,"cdrecord"  )) { opts.cutall = true; opts.convert = ISO_FORMAT; }
-      if (!strcasecmp(argv[i]+1,"winoncd"   )) { opts.cutall = true; opts.convert = ISO_FORMAT; opts.audio = RAW_FORMAT; }
-      if (!strcasecmp(argv[i]+1,"fireburner")) { opts.cutall = true; opts.convert = BIN_FORMAT; }
-      }
-     else if (i == 1) flags.ask_for_image = false;
-     else if (i == 2) flags.ask_for_dest_path = false;
-     }
-   }
-
-if (flags.ask_for_image)
-   {
-#ifdef _WIN32
-   if (askfilename(filename) != 0)
-      {
-      printf("Exit requested by user");
-      FreeConsole();
-      ExitProcess(0);
-      }
-#else
-   printf("Error: Bad syntax\n\nUsage: cdirip image.cdi [dest_path] [options]\n");  // Linux only
-   exit(EXIT_FAILURE);
-#endif
-   }
-else
-   strcpy(filename, argv[1]);
-
-// Abrir fichero
-
-printf("Searching file: '%s'\n",filename);
-
-fsource = fopen(filename,"rb");
-
-if (fsource == NULL)
-   {
-   if (errno == ENOENT)  // "No such file or directory"
-      {
-      strcat(filename, ".cdi");
-      printf("Not found. Trying '%s' instead...\n",filename);
-      fsource = fopen(filename,"rb");
-      }
-   }
-
-if (fsource == NULL) error_exit(ERR_OPENIMAGE, filename);
-
-errno = 0;
-printf("Found image file. Opening...\n");
-
-CDI_init (fsource, &image, filename);
-
-if (image.version == CDI_V2)
-   printf("This is a v2.0 image\n");
-else if (image.version == CDI_V3)
-   printf("This is a v3.0 image\n");
-else if (image.version == CDI_V35)
-   printf("This is a v3.5 image\n");
-else
-   error_exit(ERR_GENERIC, "Unsupported image version");
-
-// Cambiar directorio de destino
-
-if (!opts.showinfo)
-   {
-#ifdef _WIN32
-   if (!(!flags.ask_for_image && flags.ask_for_dest_path))
-      {
-      if (flags.ask_for_dest_path)
-         {
-            if (askpath(destpath) == 0)
-               {
-               printf("Exit requested by user");
-               FreeConsole();
-               ExitProcess(0);
-               }
-         }
-      else
-         strcpy(destpath, argv[2]);
-
-      printf("Destination path: '%s'\n", destpath);
-      if (chdir(destpath) != 0) error_exit(ERR_PATH, destpath);
-      }
-#else
-   if (!flags.ask_for_dest_path)  // en Linux solo cambiar si se especifico un path
-      {
-      strcpy(destpath, argv[2]);
-      printf("Destination path: '%s'\n", destpath);
-      if (chdir(destpath) != 0) error_exit(ERR_PATH, destpath);
-      }
-#endif
-   }
-
-// Sets proper audio format
-
-switch (opts.audio)
-       {
-       case AIFF_FORMAT:
-       case CDA_FORMAT:
-            opts.swap = opts.swap ? false : true; // invert swap switch for AIFF/CDA (MSB by default)
-            break;
-       case WAV_FORMAT:
-       case RAW_FORMAT:
-       default:
-       }
-
-// Start parsing image
-
-printf("\nAnalyzing image...\n");
-
-CDI_get_sessions (fsource, &image);
-
-if (image.sessions == 0)  error_exit(ERR_GENERIC, "Bad format: Could not find header");
-
-printf("Found %d session(s)\n",image.sessions);
-
-// Allocating buffers
-
-global_read_buffer_ptr = (char *) malloc (READ_BUF_SIZE);
-global_write_buffer_ptr = (char *) malloc (WRITE_BUF_SIZE);
-
-if (global_read_buffer_ptr == NULL || global_write_buffer_ptr == NULL)
-        error_exit(ERR_GENERIC, "Not enough free memory for buffers!");
-
-// Start ripping
-
-if (!opts.showinfo) printf("\nRipping image... (Press Ctrl-C at any time to exit)\n");
-
-if (opts.pregap) printf("Pregap data will be saved\n");
-
-image.remaining_sessions = image.sessions;
-
-/////////////////////////////////////////////////////////////// Bucle sessions
-
-while(image.remaining_sessions > 0)
-  {
-  image.global_current_session++;
-
-  CDI_get_tracks (fsource, &image);
-
-  image.header_position = ftell(fsource);
-
-  printf("\nSession %d has %d track(s)\n",image.global_current_session,image.tracks);
-
-  if (image.tracks == 0)
-     printf("Open session\n");
-  else
-    {
-
-// Decidir si crear cuesheet
-
-    if (!opts.showinfo)
-       {
-       if (image.global_current_session == 1)
-          {
-          if (ask_type(fsource, image.header_position) == 2)
-             {
-             if (opts.convert == ISO_FORMAT || opts.convert == MAC_FORMAT)
-                flags.create_cuesheet = false;  // Si "/iso" y Modo2 -> no cuesheet
-             else
-                {
-                flags.create_cuesheet = true;
-                opts.convert = BIN_FORMAT;     // Si Modo2 -> cuesheet + BIN
-                }
-             }
-          else
-             flags.create_cuesheet = true;      // Si Audio o Modo1
-          }
-       else
-          {
-          if (opts.convert == BIN_FORMAT)      // ojo! tb depende de lo anterior
-             flags.create_cuesheet = true;
-          else
-             flags.create_cuesheet = false;
-          }
-       }
-    else
-       flags.create_cuesheet = false;
-
-// Crear cuesheet
-
-    if (flags.create_cuesheet)
-       {
-       printf("Creating cuesheet...\n");
-       if (image.global_current_session == 1)
-            sprintf(cuesheetname,STR_TDISC_CUE_FILENAME);
-       else
-            sprintf(cuesheetname,STR_TDISCN_CUE_FILENAME,image.global_current_session);
-       fcuesheet = fopen(cuesheetname,"wb");
-       }
-
-    image.remaining_tracks = image.tracks;
-
-///////////////////////////////////////////////////////////////// Bucle tracks
-
-    while(image.remaining_tracks > 0)
-         {
-         track.global_current_track++;
-         track.number = image.tracks - image.remaining_tracks + 1;
-
-         CDI_read_track (fsource, &image, &track);
-
-         image.header_position = ftell(fsource);
-
-// Mostrar info
-
-         if (!opts.showinfo) printf("Saving  ");
-         printf("Track: %2d  ",track.global_current_track);
-         printf("Type: ");
-         switch(track.mode)
-               {
-               case 0 : printf("Audio/"); break;
-               case 1 : printf("Mode1/"); break;
-               case 2 :
-               default: printf("Mode2/");
-               }
-         printf("%d  ",track.sector_size);
-         if (opts.pregap)
-            printf("Pregap: %-3ld  ",track.pregap_length);
-         printf("Size: %-6ld  ",track.length);
-         printf("LBA: %-6ld  ",track.start_lba);
-
-         if (opts.showinfo) printf("\n");
-
-//       if (track.pregap_length != 150) printf("Warning! This track seems to have a non-standard pregap...\n");
-
-         if (track.length < 0 && opts.pregap == false)
-            error_exit(ERR_GENERIC, "Negative track size found\n"
-                                    "You must extract image with /pregap option");
-
-// Decidir si cortar
-
-
-         if (!opts.fulldata && track.mode != 0 && image.global_current_session == 1 && image.sessions > 1)
-            flags.do_cut = 2;
-         else if (!(track.mode != 0 && opts.fulldata))
-            {
-            flags.do_cut = ((opts.cutall) ? 2 : 0) +
-                           ((opts.cutfirst && track.global_current_track == 1) ? 2 : 0);
-            }
-         else flags.do_cut = 0;
-
-
-// Decidir si convertir
-
-         if (track.mode != 0 && track.sector_size != 2048)
-            switch (opts.convert)
-                   {
-                   case BIN_FORMAT: flags.do_convert = false; break;
-                   case ISO_FORMAT: flags.do_convert = true; break;
-                   case MAC_FORMAT: flags.do_convert = true; break;
-                   case DEFAULT_FORMAT:
-                   default: if (track.mode == 1)
-                               flags.do_convert = true;          // Modo1/2352 -> ISO
-                            else
-                               if (image.global_current_session > 1)
-                                  flags.do_convert = true;       // Modo2 2ª sesion -> ISO
-                               else
-                                  flags.do_convert = false;      // Modo2 1ª sesion -> BIN (obsoleto)
-                   }
-         else
-            flags.do_convert = false;
-
-         if (track.sector_size == 2048 || (track.mode != 0 && flags.do_convert))
-            flags.save_as_iso = true;
-         else
-            flags.save_as_iso = false;
-
-// Guardar la pista
-
-         if (!opts.showinfo)
-            {
-            if (track.total_length < track.length + track.pregap_length)
-               {
-               printf("\nThis track seems truncated. Skipping...\n");
-               fseek(fsource, track.position, SEEK_SET);
-               fseek(fsource, track.total_length, SEEK_CUR);
-               track.position = ftell(fsource);
-               }
-            else
-               {
-               savetrack(fsource, &image, &track, &opts, &flags);
-               track.position = ftell(fsource);
-
-// Generar entradas de cuesheet
-
-               if (flags.create_cuesheet && !(track.mode == 2 && flags.do_convert))  // No generar entrada si convertimos (obsoleto)
-                  savecuesheet(fcuesheet, &image, &track, &opts, &flags);
-
-               }
-            }
-
-         fseek(fsource, image.header_position, SEEK_SET);
-
-
-// Cerrar bucles
-
-         image.remaining_tracks--;
-         }
-
-    if (flags.create_cuesheet) fclose(fcuesheet);
-    }
-
-  CDI_skip_next_session (fsource, &image);
-
-  image.remaining_sessions--;
-  }
-
-// Liberar buffers
-
-  free(global_write_buffer_ptr);
-  free(global_read_buffer_ptr);
-
-// Finalizar
-
-printf("\nAll done!\n");
-
-if (!opts.showinfo) printf("Good burnin'...\n");
-
-fclose(fsource);
-
-return 0;
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
-
-
-void savetrack(FILE *fsource, image_s *image, track_s *track, opts_s *opts, flags_s *flags)
-{
-
-unsigned long i, ii;
-long track_length;
-unsigned long header_length;
-char tmp_val;
-int all_fine;
-char buffer[2352], filename [13];
-FILE *fdest;
-
-#ifdef _WIN32
-LARGE_INTEGER Frequency, old_count;
-#endif
-
-struct buffer_s read_buffer;
-struct buffer_s write_buffer;
-
-#ifdef _WIN32
-     if (opts->showspeed)
-     {
-     QueryPerformanceFrequency(&Frequency);
-     QueryPerformanceCounter(&old_count);
-     }
-#endif
-
-     fseek(fsource, track->position, SEEK_SET);
-
-     if (track->mode == 0)
-        {
-        switch (opts->audio)
-               {
-               case RAW_FORMAT:
-                    sprintf(filename,STR_TAUDIO_RAW_FILENAME,track->global_current_track);
-                    break;
-               case CDA_FORMAT:
-                    sprintf(filename,STR_TAUDIO_CDA_FILENAME,track->global_current_track);
-                    break;
-               case AIFF_FORMAT:
-                    sprintf(filename,STR_TAUDIO_AIFF_FILENAME,track->global_current_track);
-                    break;
-               case WAV_FORMAT:
-               default:
-                    sprintf(filename,STR_TAUDIO_WAV_FILENAME,track->global_current_track);
-                    break;
-               }
-        }
-     else
-        {
-        if (flags->save_as_iso)
-              sprintf(filename,STR_TDATA_ISO_FILENAME,track->global_current_track);
-        else
-              sprintf(filename,STR_TDATA_BIN_FILENAME,track->global_current_track);
-        }
-
-     fdest = fopen(filename,"wb");
-
-     if (fdest == NULL) error_exit(ERR_SAVETRACK, filename);
-
-     read_buffer.file = fsource;
-     read_buffer.size = READ_BUF_SIZE;
-     read_buffer.index = 0;
-     read_buffer.ptr = global_read_buffer_ptr;
-     write_buffer.file = fdest;
-     write_buffer.size = WRITE_BUF_SIZE;
-     write_buffer.index = 0;
-     write_buffer.ptr = global_write_buffer_ptr;
-
-     fseek(fsource, track->pregap_length*track->sector_size, SEEK_CUR);  // always skip pregap
-
-     if (flags->do_cut != 0) printf("[cut: %d] ", flags->do_cut);
-
-     track_length = track->length - flags->do_cut;     // para no modificar valor original
-
-     if (opts->pregap && track->mode == 0 && image->remaining_tracks > 1)  // quick hack to save next track pregap (audio tracks only)
-        track_length += track->pregap_length;                              // if this isn't last track in current session
-
-     if (flags->do_convert)
-         printf("[ISO]\n");
-     else
-         printf("\n");
-/*
-     if (track->mode == 2)
-        switch (track->sector_size) {
-               case 2352: sector_type = MODE2_2352; break;
-               case 2336: sector_type = MODE2_2336; break;
-               case 2056: sector_type = MODE2_2056; break;
-               case 2048: sector_type = MODE2_2048; break;
-               }
-     else if (track->mode == 1)
-        switch (track->sector_size) {
-               case 2352: sector_type = MODE1_2352; break;
-               case 2048: sector_type = MODE1_2048; break;
-               }
-     else if (track->mode == 0)
-        switch (track->sector_size) {
-               case 2352: sector_type = MODE0_2352; break;
-               }
-*/
-     if (flags->do_convert) {
-	if (track->mode == 2) {
-		switch (track->sector_size) {
-			case 2352: header_length = 24; break;
-			case 2336: header_length =  8; break;
-			default:   header_length =  0;
-			}
-	} else {
-		switch (track->sector_size) {
-			case 2352: header_length = 16; break;
-			case 2048:
-			default:   header_length =  0;
-			}
-	}
-     }
-
-     if (track->mode == 0)
-        switch (opts->audio)
-               {
-               case WAV_FORMAT:
-                    writewavheader(fdest, track_length);
-                    break;
-               case AIFF_FORMAT:
-                    writeaiffheader(fdest, track_length);
-                    break;
-               default:
-               }
-
-     for(i = 0; i < track_length; i++)
-        {
-#ifndef DEBUG_CDI
-              if (!(i%128)) show_counter (i, track_length, image->length, ftell(fsource));
-#endif
-              BufRead (buffer, track->sector_size, &read_buffer, image->length);
-
-              if (track->mode == 0 && opts->swap)
-                 for (ii = 0; ii < track->sector_size; ++ii, ++ii)
-                     {
-                     tmp_val = buffer[ii];
-                     buffer[ii] = buffer[ii+1];
-                     buffer[ii+1] = tmp_val;
-                     }
-
-              if (flags->do_convert)
-                 {
-                 if (opts->convert == MAC_FORMAT) BufWrite("\0\0\x08\0\0\0\x08\0", 8, &write_buffer);
-                 all_fine = BufWrite (buffer + header_length, 2048, &write_buffer);
-                 }
-              else
-                 {
-                 all_fine = BufWrite (buffer, track->sector_size, &write_buffer);
-                 }
-
-              if (!all_fine) error_exit(ERR_SAVETRACK, filename);
-
-#ifdef _WIN32
-              if (opts->showspeed && !((i+1)%SHOW_INTERVAL)) show_speed (track->sector_size, Frequency, &old_count);
-#endif
-        }
-
-     printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
-            "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
-            "                                                          "
-            "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
-            "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
-
-//     if (flags->do_cut != 0) fseek(fsource, flags->do_cut*track->sector_size, SEEK_CUR);
-
-// Calcular posicion (BufRead no seguro, tb cuttrack & pregap)
-
-     fseek(fsource, track->position, SEEK_SET);
-//     fseek(fsource, track->pregap_length * track->sector_size, SEEK_CUR);
-//     fseek(fsource, track->length * track->sector_size, SEEK_CUR);
-     fseek(fsource, track->total_length * track->sector_size, SEEK_CUR);
-
-// Vaciar buffers
-
-     BufWriteFlush(&write_buffer);
-
-     fflush(fdest);
-     fclose(fdest);
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
-
-
-void show_counter (unsigned long i, long track_length, unsigned long image_length, long pos)
-{
-     unsigned long progress, total_progress;
-
-        progress = (i*100/track_length);
-        total_progress = ((pos>>10)*100)/(image_length>>10);
-        printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
-        "[Current: %02d%%  Total: %02d%%]  ",progress, total_progress);
-}
-
-
-#ifdef _WIN32
-
-void show_speed (unsigned long sector_size, LARGE_INTEGER Frequency, LARGE_INTEGER *old_count)
-{
-     unsigned long speed, elapsed;
-     LARGE_INTEGER PerformanceCount, last_count;
-
-        QueryPerformanceCounter(&PerformanceCount);
-        last_count = *old_count;
-
-        elapsed = (PerformanceCount.QuadPart - last_count.QuadPart)/(Frequency.QuadPart/1000);  // in ms
-        speed = SHOW_INTERVAL*sector_size/(elapsed > 0 ? elapsed : 1);
-        printf("[Speed: %6ld KB/s]  "
-        "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b", speed);
-
-        *old_count = PerformanceCount;
-}
-
-#endif
-
-
-//////////////////////////////////////////////////////////////////////////////
-
-
-void savecuesheet(FILE *fcuesheet, image_s *image, track_s *track, opts_s *opts, flags_s *flags)
-{
-
-char track_format_string[10];
-char audio_file_ext[5];
-
-     if (opts->swap)
-        strcpy(track_format_string,"MOTOROLA");
-     else
-        strcpy(track_format_string,"BINARY");
-
-     switch (opts->audio)
-            {
-            case AIFF_FORMAT:
-                 strcpy(audio_file_ext,"AIFF");
-                 break;
-            case CDA_FORMAT:
-                 strcpy(audio_file_ext,"CDA");
-                 break;
-            case RAW_FORMAT:
-                 strcpy(audio_file_ext,"RAW");
-                 break;
-            case WAV_FORMAT:
-            default:
-                 strcpy(audio_file_ext,"WAV");
-            }
-
-     if (track->mode == 0)
-        {
-        if (opts->audio == WAV_FORMAT)
-              fprintf(fcuesheet, "FILE TAUDIO%02d.WAV WAVE\r\n"
-                                 "  TRACK %02d AUDIO\r\n",
-                                 track->global_current_track,
-                                 track->number);
-        else
-              fprintf(fcuesheet, "FILE TAUDIO%02d.%s %s\r\n"
-                                 "  TRACK %02d AUDIO\r\n",
-                                 track->global_current_track,
-                                 audio_file_ext,
-                                 track_format_string,
-                                 track->number);
-
-        if (track->global_current_track > 1 && !opts->pregap && track->pregap_length > 0)
-              fprintf(fcuesheet, "    PREGAP 00:02:00\r\n");
-
-        }
-     else
-        {
-        if (flags->save_as_iso)
-              fprintf(fcuesheet, "FILE TDATA%02d.ISO BINARY\r\n"
-                                 "  TRACK %02d MODE%d/2048\r\n",
-                                 track->global_current_track,
-                                 track->number,
-                                 track->mode);
-        else
-              fprintf(fcuesheet, "FILE TDATA%02d.BIN BINARY\r\n"
-                                 "  TRACK %02d MODE%d/%d\r\n",
-                                 track->global_current_track,
-                                 track->number,
-                                 track->mode,
-                                 track->sector_size);
-        }
-
-     fprintf(fcuesheet, "    INDEX 01 00:00:00\r\n");
-
-     if (opts->pregap && track->mode != 0 && image->remaining_tracks > 1) // instead of saving pregap
-        fprintf(fcuesheet, "  POSTGAP 00:02:00\r\n");
-
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
-
-
-#ifdef _WIN32
-
-int askfilename(char *string)
-{
-
-HWND hWnd = NULL;
-OPENFILENAME ofn;
-char szFile[MAX_PATH];
-
-     memset(&ofn, 0, sizeof(ofn));
-     szFile[0] = 0;
-
-#ifdef __BORLANDC__
-     ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
-#else
-     ofn.lStructSize = sizeof(ofn);
-#endif
-     ofn.hwndOwner = hWnd;
-     ofn.lpstrFile = szFile;
-     ofn.nMaxFile = sizeof(szFile);
-     ofn.lpstrFilter = "DiscJuggler image (*.cdi;*.cdr)\0*.cdi;*.cdr\0All files (*.*)\0*.*\0\0";
-     ofn.nFilterIndex = 1;
-     ofn.lpstrDefExt = "cdi";
-     ofn.lpstrTitle = "Select CDI image to open...";
-     ofn.lpstrFileTitle = NULL;
-     ofn.nMaxFileTitle = 0;
-     ofn.lpstrInitialDir = NULL;
-     ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST;
-
-     if (GetOpenFileName(&ofn))
-        strcpy (string, szFile);
-     else
-        return 1;
-
-     return 0;
-}
-
-#endif
-
-
-//////////////////////////////////////////////////////////////////////////////
-
-#ifdef _WIN32
-
-int askpath(char *sz_buf)
-{
-
-// taken (w/small changes) from Olan Patrick's FILEDLGS library (PD)
-
-    BROWSEINFO      bi;
-    LPITEMIDLIST    pidlRoot, pidlChosen;
-    char            pszBuffer[MAX_PATH];
-    char            szChosenFolder[MAX_PATH] = "\\\\";
-    int             retval;
-
-    HWND            hwndf = NULL;
-    DWORD           dwFlags = BIF_RETURNONLYFSDIRS;
-
-    SHGetSpecialFolderLocation(hwndf, CSIDL_DESKTOP, &pidlRoot);
-
-    memset(&bi, 0, sizeof(BROWSEINFO));
-    bi.hwndOwner = hwndf;
-    bi.pidlRoot = pidlRoot;
-    bi.pszDisplayName = pszBuffer;
-    bi.lpszTitle = "Select destination path...";
-    bi.ulFlags = dwFlags;
-
-    retval = 0;
-    if ((pidlChosen = SHBrowseForFolder(&bi)) != NULL)
-    {
-        if (dwFlags & BIF_BROWSEFORCOMPUTER)
-        {
-            strncat(szChosenFolder, pszBuffer, MAX_PATH - 2);
-            retval = 1;
-        }
-        else if (SHGetPathFromIDList(pidlChosen, pszBuffer))
-        {
-            strncpy(szChosenFolder, pszBuffer, MAX_PATH);
-            retval = 1;
-        }
-    }
-    else
-        szChosenFolder[0] = '\0';
-
-    strncpy(sz_buf, szChosenFolder, MAX_PATH);
-    return (retval);
-
-}
-
-#endif
-
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+#ifdef _WIN32
+#include <windows.h>
+#include <shlobj.h>
+#endif
+#include "common.h"
+#include "cdirip.h"
+#include "buffer.h"
+#include "cdi.h"
+#include "audio.h"
+
+// Linux add-ons by Pedro Melo
+// Code tweaks and more docs by Chris Zubrzycki
+
+#ifndef _WIN32
+#define MAX_PATH PATH_MAX
+#endif /*_WIN32*/
+
+#ifdef __BORLANDC__
+#define strcasecmp stricmp
+#endif /*__BORLANDC__*/
+
+// Global variables
+
+char *global_read_buffer_ptr;
+char *global_write_buffer_ptr;
+
+// Main function
+
+int main( int argc, char **argv )
+{
+
+int  i;
+char cuesheetname[13], filename[MAX_PATH], destpath[MAX_PATH];
+FILE *fsource, *fcuesheet;
+
+image_s image = { 0, };
+track_s track = { 0, };
+opts_s  opts  = { 0, };
+flags_s flags = { 0, };
+
+image.global_current_session = 0;
+track.global_current_track   = 0;
+track.position               = 0;
+
+// Opciones
+
+printf("CDIrip 0.6.2 - (C) 2002 by DeXT\n\n");
+
+flags.ask_for_image = true;
+flags.ask_for_dest_path = true;
+
+opts.audio = WAV_FORMAT;
+
+#ifndef _WIN32
+opts.convert = ISO_FORMAT;  // Linux only!
+#else
+opts.convert = DEFAULT_FORMAT;
+#endif /*_WIN32*/
+
+if (argc >= 2)
+   {
+   for(i = 1; i < argc; i++)
+     {
+#ifdef _WIN32
+     if (argv[i][0] == '/' || argv[i][0] == '-')
+#else
+     if (argv[i][0] == '-')    // Linux absolute paths start with '/'
+#endif /*_WIN32*/
+      {
+      if (!strcasecmp(argv[i]+1,"iso"    )) opts.convert   = ISO_FORMAT;
+      if (!strcasecmp(argv[i]+1,"bin"    )) opts.convert   = BIN_FORMAT;
+      if (!strcasecmp(argv[i]+1,"mac"    )) opts.convert   = MAC_FORMAT; // ISO/2056
+      if (!strcasecmp(argv[i]+1,"raw"    )) opts.audio     = RAW_FORMAT;
+      if (!strcasecmp(argv[i]+1,"cda"    )) opts.audio     = CDA_FORMAT;
+      if (!strcasecmp(argv[i]+1,"wav"    )) opts.audio     = WAV_FORMAT;
+      if (!strcasecmp(argv[i]+1,"aiff"   )) opts.audio     = AIFF_FORMAT;
+      if (!strcasecmp(argv[i]+1,"info"   )) opts.showinfo  = true;
+      if (!strcasecmp(argv[i]+1,"cut"    )) opts.cutfirst  = true;
+      if (!strcasecmp(argv[i]+1,"cutall" )) opts.cutall    = true;
+      if (!strcasecmp(argv[i]+1,"full"   )) opts.fulldata  = true;
+      if (!strcasecmp(argv[i]+1,"swap"   )) opts.swap      = true;
+      if (!strcasecmp(argv[i]+1,"speed"  )) opts.showspeed = true;
+      if (!strcasecmp(argv[i]+1,"pregap" )) opts.pregap    = true;
+
+      if (!strcasecmp(argv[i]+1,"cdrecord"  )) { opts.cutall = true; opts.convert = ISO_FORMAT; }
+      if (!strcasecmp(argv[i]+1,"winoncd"   )) { opts.cutall = true; opts.convert = ISO_FORMAT; opts.audio = RAW_FORMAT; }
+      if (!strcasecmp(argv[i]+1,"fireburner")) { opts.cutall = true; opts.convert = BIN_FORMAT; }
+      }
+     else if (i == 1) flags.ask_for_image = false;
+     else if (i == 2) flags.ask_for_dest_path = false;
+     }
+   }
+
+if (flags.ask_for_image)
+   {
+#ifdef _WIN32
+   if (askfilename(filename) != 0)
+      {
+      printf("Exit requested by user");
+      FreeConsole();
+      ExitProcess(0);
+      }
+#else
+   printf("Error: Bad syntax\n\nUsage: cdirip image.cdi [dest_path] [options]\n\n");  // Linux only
+   printf("Options are as follows:\n\n");
+   printf("\t-cdredord:      creates cdrecord compatabile ISO and WAV tracks (same as -cutall -iso)\n");
+   printf("\t-winoncd:       creates winoncd compatabile ISO and RAW tracks (same as -cutall -iso -raw)\n");
+   printf("\t-fireburner:    creates fireburner BIN/CUE files (same as -cutall -bin)\n\n");
+   printf("Data Options\n");
+   printf("\t-iso:           creates ISO data tracks, with a 2048 tracksize\n");
+   printf("\t-bin:           creates bin/cue files, defaults to wav audio [default]\n");
+   printf("\t-mac:           creates Toast compatabile ISO files, with a 2056 tracksize\n");
+   printf("Audio Options\n");
+   printf("\t-raw:           copies audio in RAW format (headerless files to be used for cd writers)\n");
+   printf("\t-cda:           copies audio in CDA format (MSB by default)\n");
+   printf("\t-wav:           copies audio in WAV format [default]\n");
+   printf("\t-aiff:          copies audio in AIFF format (MSB by default)\n");
+   printf("\t-cut:           cuts the length of the first track by 2 sectors?\n");
+   printf("\t-cutall:        cuts the length of all tracks by 2 sectors?\n");
+   printf("\t-full:          don't cut?\n");
+   printf("\t-swap:          swaps the byte order\n");
+   printf("\t-speed:         shows the speed (Windows/DOS only)\n");
+   printf("\t-pregap:        preserves the pregap\n");
+   printf("\t-info:          quiet mode?\n");
+
+   exit(EXIT_FAILURE);
+#endif /*_WIN32*/
+   }
+else
+   strcpy(filename, argv[1]);
+
+// Abrir fichero
+
+printf("Searching file: '%s'\n",filename);
+
+fsource = fopen(filename,"rb");
+
+if (fsource == NULL)
+   {
+   if (errno == ENOENT)  // "No such file or directory"
+      {
+      strcat(filename, ".cdi");
+      printf("Not found. Trying '%s' instead...\n",filename);
+      fsource = fopen(filename,"rb");
+      }
+   }
+
+if (fsource == NULL) error_exit(ERR_OPENIMAGE, filename);
+
+errno = 0;
+printf("Found image file. Opening...\n");
+
+CDI_init (fsource, &image, filename);
+
+if (image.version == CDI_V2)
+   printf("This is a v2.0 image\n");
+else if (image.version == CDI_V3)
+   printf("This is a v3.0 image\n");
+else if (image.version == CDI_V35)
+   printf("This is a v3.5 image\n");
+else
+   error_exit(ERR_GENERIC, "Unsupported image version");
+
+// Cambiar directorio de destino
+
+if (!opts.showinfo)
+   {
+#ifdef _WIN32
+   if (!(!flags.ask_for_image && flags.ask_for_dest_path))
+      {
+      if (flags.ask_for_dest_path)
+         {
+            if (askpath(destpath) == 0)
+               {
+               printf("Exit requested by user");
+               FreeConsole();
+               ExitProcess(0);
+               }
+         }
+      else
+         strcpy(destpath, argv[2]);
+
+      printf("Destination path: '%s'\n", destpath);
+      if (chdir(destpath) != 0) error_exit(ERR_PATH, destpath);
+      }
+#else
+   if (!flags.ask_for_dest_path)  // en Linux solo cambiar si se especifico un path
+      {
+      strcpy(destpath, argv[2]);
+      printf("Destination path: '%s'\n", destpath);
+      if (chdir(destpath) != 0) error_exit(ERR_PATH, destpath);
+      }
+#endif /*_WIN32*/
+   }
+
+// Sets proper audio format
+
+switch (opts.audio)
+       {
+       case AIFF_FORMAT:
+       case CDA_FORMAT:
+            opts.swap = opts.swap ? false : true; // invert swap switch for AIFF/CDA (MSB by default)
+            break;
+       case WAV_FORMAT:
+       case RAW_FORMAT:
+       default:
+       }
+
+// Start parsing image
+
+printf("\nAnalyzing image...\n");
+
+CDI_get_sessions (fsource, &image);
+
+if (image.sessions == 0)  error_exit(ERR_GENERIC, "Bad format: Could not find header");
+
+printf("Found %d session(s)\n",image.sessions);
+
+// Allocating buffers
+
+global_read_buffer_ptr = (char *) malloc (READ_BUF_SIZE);
+global_write_buffer_ptr = (char *) malloc (WRITE_BUF_SIZE);
+
+if (global_read_buffer_ptr == NULL || global_write_buffer_ptr == NULL)
+        error_exit(ERR_GENERIC, "Not enough free memory for buffers!");
+
+// Start ripping
+
+if (!opts.showinfo) printf("\nRipping image... (Press Ctrl-C at any time to exit)\n");
+
+if (opts.pregap) printf("Pregap data will be saved\n");
+
+image.remaining_sessions = image.sessions;
+
+/////////////////////////////////////////////////////////////// Bucle sessions
+
+while(image.remaining_sessions > 0)
+  {
+  image.global_current_session++;
+
+  CDI_get_tracks (fsource, &image);
+
+  image.header_position = ftell(fsource);
+
+  printf("\nSession %d has %d track(s)\n",image.global_current_session,image.tracks);
+
+  if (image.tracks == 0)
+     printf("Open session\n");
+  else
+    {
+
+// Decidir si crear cuesheet
+
+    if (!opts.showinfo)
+       {
+       if (image.global_current_session == 1)
+          {
+          if (ask_type(fsource, image.header_position) == 2)
+             {
+             if (opts.convert == ISO_FORMAT || opts.convert == MAC_FORMAT)
+                flags.create_cuesheet = false;  // Si "/iso" y Modo2 -> no cuesheet
+             else
+                {
+                flags.create_cuesheet = true;
+                opts.convert = BIN_FORMAT;     // Si Modo2 -> cuesheet + BIN
+                }
+             }
+          else
+             flags.create_cuesheet = true;      // Si Audio o Modo1
+          }
+       else
+          {
+          if (opts.convert == BIN_FORMAT)      // ojo! tb depende de lo anterior
+             flags.create_cuesheet = true;
+          else
+             flags.create_cuesheet = false;
+          }
+       }
+    else
+       flags.create_cuesheet = false;
+
+// Crear cuesheet
+
+    if (flags.create_cuesheet)
+       {
+       printf("Creating cuesheet...\n");
+       if (image.global_current_session == 1)
+            sprintf(cuesheetname,STR_TDISC_CUE_FILENAME);
+       else
+            sprintf(cuesheetname,STR_TDISCN_CUE_FILENAME,image.global_current_session);
+       fcuesheet = fopen(cuesheetname,"wb");
+       }
+
+    image.remaining_tracks = image.tracks;
+
+///////////////////////////////////////////////////////////////// Bucle tracks
+
+    while(image.remaining_tracks > 0)
+         {
+         track.global_current_track++;
+         track.number = image.tracks - image.remaining_tracks + 1;
+
+         CDI_read_track (fsource, &image, &track);
+
+         image.header_position = ftell(fsource);
+
+// Mostrar info
+
+         if (!opts.showinfo) printf("Saving  ");
+         printf("Track: %2d  ",track.global_current_track);
+         printf("Type: ");
+         switch(track.mode)
+               {
+               case 0 : printf("Audio/"); break;
+               case 1 : printf("Mode1/"); break;
+               case 2 :
+               default: printf("Mode2/");
+               }
+         printf("%d  ",track.sector_size);
+         if (opts.pregap)
+            printf("Pregap: %-3ld  ",track.pregap_length);
+         printf("Size: %-6ld  ",track.length);
+         printf("LBA: %-6ld  ",track.start_lba);
+
+         if (opts.showinfo) printf("\n");
+
+//       if (track.pregap_length != 150) printf("Warning! This track seems to have a non-standard pregap...\n");
+
+         if (track.length < 0 && opts.pregap == false)
+            error_exit(ERR_GENERIC, "Negative track size found\n"
+                                    "You must extract image with /pregap option");
+
+// Decidir si cortar
+
+
+         if (!opts.fulldata && track.mode != 0 && image.global_current_session == 1 && image.sessions > 1)
+            flags.do_cut = 2;
+         else if (!(track.mode != 0 && opts.fulldata))
+            {
+            flags.do_cut = ((opts.cutall) ? 2 : 0) +
+                           ((opts.cutfirst && track.global_current_track == 1) ? 2 : 0);
+            }
+         else flags.do_cut = 0;
+
+
+// Decidir si convertir
+
+         if (track.mode != 0 && track.sector_size != 2048)
+            switch (opts.convert)
+                   {
+                   case BIN_FORMAT: flags.do_convert = false; break;
+                   case ISO_FORMAT: flags.do_convert = true; break;
+                   case MAC_FORMAT: flags.do_convert = true; break;
+                   case DEFAULT_FORMAT:
+                   default: if (track.mode == 1)
+                               flags.do_convert = true;          // Modo1/2352 -> ISO
+                            else
+                               if (image.global_current_session > 1)
+                                  flags.do_convert = true;       // Modo2 2ª sesion -> ISO
+                               else
+                                  flags.do_convert = false;      // Modo2 1ª sesion -> BIN (obsoleto)
+                   }
+         else
+            flags.do_convert = false;
+
+         if (track.sector_size == 2048 || (track.mode != 0 && flags.do_convert))
+            flags.save_as_iso = true;
+         else
+            flags.save_as_iso = false;
+
+// Guardar la pista
+
+         if (!opts.showinfo)
+            {
+            if (track.total_length < track.length + track.pregap_length)
+               {
+               printf("\nThis track seems truncated. Skipping...\n");
+               fseek(fsource, track.position, SEEK_SET);
+               fseek(fsource, track.total_length, SEEK_CUR);
+               track.position = ftell(fsource);
+               }
+            else
+               {
+               savetrack(fsource, &image, &track, &opts, &flags);
+               track.position = ftell(fsource);
+
+// Generar entradas de cuesheet
+
+               if (flags.create_cuesheet && !(track.mode == 2 && flags.do_convert))  // No generar entrada si convertimos (obsoleto)
+                  savecuesheet(fcuesheet, &image, &track, &opts, &flags);
+
+               }
+            }
+
+         fseek(fsource, image.header_position, SEEK_SET);
+
+
+// Cerrar bucles
+
+         image.remaining_tracks--;
+         }
+
+    if (flags.create_cuesheet) fclose(fcuesheet);
+    }
+
+  CDI_skip_next_session (fsource, &image);
+
+  image.remaining_sessions--;
+  }
+
+// Liberar buffers
+
+  free(global_write_buffer_ptr);
+  free(global_read_buffer_ptr);
+
+// Finalizar
+
+printf("\nAll done!\n");
+
+if (!opts.showinfo) printf("Good burnin'...\n");
+
+fclose(fsource);
+
+return 0;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+
+
+void savetrack(FILE *fsource, image_s *image, track_s *track, opts_s *opts, flags_s *flags)
+{
+
+unsigned long i, ii;
+long track_length;
+unsigned long header_length;
+char tmp_val;
+int all_fine;
+char buffer[2352], filename [13];
+FILE *fdest;
+
+#ifdef _WIN32
+LARGE_INTEGER Frequency, old_count;
+#endif /*_WIN32*/
+
+struct buffer_s read_buffer;
+struct buffer_s write_buffer;
+
+#ifdef _WIN32
+     if (opts->showspeed)
+     {
+     QueryPerformanceFrequency(&Frequency);
+     QueryPerformanceCounter(&old_count);
+     }
+#endif /*_WIN32*/
+
+     fseek(fsource, track->position, SEEK_SET);
+
+     if (track->mode == 0)
+        {
+        switch (opts->audio)
+               {
+               case RAW_FORMAT:
+                    sprintf(filename,STR_TAUDIO_RAW_FILENAME,track->global_current_track);
+                    break;
+               case CDA_FORMAT:
+                    sprintf(filename,STR_TAUDIO_CDA_FILENAME,track->global_current_track);
+                    break;
+               case AIFF_FORMAT:
+                    sprintf(filename,STR_TAUDIO_AIFF_FILENAME,track->global_current_track);
+                    break;
+               case WAV_FORMAT:
+               default:
+                    sprintf(filename,STR_TAUDIO_WAV_FILENAME,track->global_current_track);
+                    break;
+               }
+        }
+     else
+        {
+        if (flags->save_as_iso)
+              sprintf(filename,STR_TDATA_ISO_FILENAME,track->global_current_track);
+        else
+              sprintf(filename,STR_TDATA_BIN_FILENAME,track->global_current_track);
+        }
+
+     fdest = fopen(filename,"wb");
+
+     if (fdest == NULL) error_exit(ERR_SAVETRACK, filename);
+
+     read_buffer.file = fsource;
+     read_buffer.size = READ_BUF_SIZE;
+     read_buffer.index = 0;
+     read_buffer.ptr = global_read_buffer_ptr;
+     write_buffer.file = fdest;
+     write_buffer.size = WRITE_BUF_SIZE;
+     write_buffer.index = 0;
+     write_buffer.ptr = global_write_buffer_ptr;
+
+     fseek(fsource, track->pregap_length*track->sector_size, SEEK_CUR);  // always skip pregap
+
+     if (flags->do_cut != 0) printf("[cut: %d] ", flags->do_cut);
+
+     track_length = track->length - flags->do_cut;     // para no modificar valor original
+
+     if (opts->pregap && track->mode == 0 && image->remaining_tracks > 1)  // quick hack to save next track pregap (audio tracks only)
+        track_length += track->pregap_length;                              // if this isn't last track in current session
+
+     if (flags->do_convert)
+         printf("[ISO]\n");
+     else
+         printf("\n");
+/*
+     if (track->mode == 2)
+        switch (track->sector_size) {
+               case 2352: sector_type = MODE2_2352; break;
+               case 2336: sector_type = MODE2_2336; break;
+               case 2056: sector_type = MODE2_2056; break;
+               case 2048: sector_type = MODE2_2048; break;
+               }
+     else if (track->mode == 1)
+        switch (track->sector_size) {
+               case 2352: sector_type = MODE1_2352; break;
+               case 2048: sector_type = MODE1_2048; break;
+               }
+     else if (track->mode == 0)
+        switch (track->sector_size) {
+               case 2352: sector_type = MODE0_2352; break;
+               }
+*/
+     if (flags->do_convert) {
+	if (track->mode == 2) {
+		switch (track->sector_size) {
+			case 2352: header_length = 24; break;
+			case 2336: header_length =  8; break;
+			default:   header_length =  0;
+			}
+	} else {
+		switch (track->sector_size) {
+			case 2352: header_length = 16; break;
+			case 2048:
+			default:   header_length =  0;
+			}
+	}
+     }
+
+     if (track->mode == 0)
+        switch (opts->audio)
+               {
+               case WAV_FORMAT:
+                    writewavheader(fdest, track_length);
+                    break;
+               case AIFF_FORMAT:
+                    writeaiffheader(fdest, track_length);
+                    break;
+               default:
+               }
+
+     for(i = 0; i < track_length; i++)
+        {
+#ifndef DEBUG_CDI
+              if (!(i%128)) show_counter (i, track_length, image->length, ftell(fsource));
+#endif /*DEBUG_CDI*/
+              BufRead (buffer, track->sector_size, &read_buffer, image->length);
+
+              if (track->mode == 0 && opts->swap)
+                 for (ii = 0; ii < track->sector_size; ++ii, ++ii)
+                     {
+                     tmp_val = buffer[ii];
+                     buffer[ii] = buffer[ii+1];
+                     buffer[ii+1] = tmp_val;
+                     }
+
+              if (flags->do_convert)
+                 {
+                 if (opts->convert == MAC_FORMAT) BufWrite("\0\0\x08\0\0\0\x08\0", 8, &write_buffer);
+                 all_fine = BufWrite (buffer + header_length, 2048, &write_buffer);
+                 }
+              else
+                 {
+                 all_fine = BufWrite (buffer, track->sector_size, &write_buffer);
+                 }
+
+              if (!all_fine) error_exit(ERR_SAVETRACK, filename);
+
+#ifdef _WIN32
+              if (opts->showspeed && !((i+1)%SHOW_INTERVAL)) show_speed (track->sector_size, Frequency, &old_count);
+#endif /*_WIN32*/
+        }
+
+     printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
+            "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
+            "                                                          "
+            "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
+            "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
+
+//     if (flags->do_cut != 0) fseek(fsource, flags->do_cut*track->sector_size, SEEK_CUR);
+
+// Calcular posicion (BufRead no seguro, tb cuttrack & pregap)
+
+     fseek(fsource, track->position, SEEK_SET);
+//     fseek(fsource, track->pregap_length * track->sector_size, SEEK_CUR);
+//     fseek(fsource, track->length * track->sector_size, SEEK_CUR);
+     fseek(fsource, track->total_length * track->sector_size, SEEK_CUR);
+
+// Vaciar buffers
+
+     BufWriteFlush(&write_buffer);
+
+     fflush(fdest);
+     fclose(fdest);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+
+
+void show_counter (unsigned long i, long track_length, unsigned long image_length, long pos)
+{
+     unsigned long progress, total_progress;
+
+        progress = (i*100/track_length);
+        total_progress = ((pos>>10)*100)/(image_length>>10);
+        printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
+        "[Current: %02d%%  Total: %02d%%]  ",progress, total_progress);
+}
+
+
+#ifdef _WIN32
+
+void show_speed (unsigned long sector_size, LARGE_INTEGER Frequency, LARGE_INTEGER *old_count)
+{
+     unsigned long speed, elapsed;
+     LARGE_INTEGER PerformanceCount, last_count;
+
+        QueryPerformanceCounter(&PerformanceCount);
+        last_count = *old_count;
+
+        elapsed = (PerformanceCount.QuadPart - last_count.QuadPart)/(Frequency.QuadPart/1000);  // in ms
+        speed = SHOW_INTERVAL*sector_size/(elapsed > 0 ? elapsed : 1);
+        printf("[Speed: %6ld KB/s]  "
+        "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b", speed);
+
+        *old_count = PerformanceCount;
+}
+
+#endif /*_WIN32*/
+
+
+//////////////////////////////////////////////////////////////////////////////
+
+
+void savecuesheet(FILE *fcuesheet, image_s *image, track_s *track, opts_s *opts, flags_s *flags)
+{
+
+char track_format_string[10];
+char audio_file_ext[5];
+
+     if (opts->swap)
+        strcpy(track_format_string,"MOTOROLA");
+     else
+        strcpy(track_format_string,"BINARY");
+
+     switch (opts->audio)
+            {
+            case AIFF_FORMAT:
+                 strcpy(audio_file_ext,"AIFF");
+                 break;
+            case CDA_FORMAT:
+                 strcpy(audio_file_ext,"CDA");
+                 break;
+            case RAW_FORMAT:
+                 strcpy(audio_file_ext,"RAW");
+                 break;
+            case WAV_FORMAT:
+            default:
+                 strcpy(audio_file_ext,"WAV");
+            }
+
+     if (track->mode == 0)
+        {
+        if (opts->audio == WAV_FORMAT)
+              fprintf(fcuesheet, "FILE TAUDIO%02d.WAV WAVE\r\n"
+                                 "  TRACK %02d AUDIO\r\n",
+                                 track->global_current_track,
+                                 track->number);
+        else
+              fprintf(fcuesheet, "FILE TAUDIO%02d.%s %s\r\n"
+                                 "  TRACK %02d AUDIO\r\n",
+                                 track->global_current_track,
+                                 audio_file_ext,
+                                 track_format_string,
+                                 track->number);
+
+        if (track->global_current_track > 1 && !opts->pregap && track->pregap_length > 0)
+              fprintf(fcuesheet, "    PREGAP 00:02:00\r\n");
+
+        }
+     else
+        {
+        if (flags->save_as_iso)
+              fprintf(fcuesheet, "FILE TDATA%02d.ISO BINARY\r\n"
+                                 "  TRACK %02d MODE%d/2048\r\n",
+                                 track->global_current_track,
+                                 track->number,
+                                 track->mode);
+        else
+              fprintf(fcuesheet, "FILE TDATA%02d.BIN BINARY\r\n"
+                                 "  TRACK %02d MODE%d/%d\r\n",
+                                 track->global_current_track,
+                                 track->number,
+                                 track->mode,
+                                 track->sector_size);
+        }
+
+     fprintf(fcuesheet, "    INDEX 01 00:00:00\r\n");
+
+     if (opts->pregap && track->mode != 0 && image->remaining_tracks > 1) // instead of saving pregap
+        fprintf(fcuesheet, "  POSTGAP 00:02:00\r\n");
+
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+
+
+#ifdef _WIN32
+
+int askfilename(char *string)
+{
+
+HWND hWnd = NULL;
+OPENFILENAME ofn;
+char szFile[MAX_PATH];
+
+     memset(&ofn, 0, sizeof(ofn));
+     szFile[0] = 0;
+
+#ifdef __BORLANDC__
+     ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+#else /*__BORLANDC__*/
+     ofn.lStructSize = sizeof(ofn);
+#endif
+     ofn.hwndOwner = hWnd;
+     ofn.lpstrFile = szFile;
+     ofn.nMaxFile = sizeof(szFile);
+     ofn.lpstrFilter = "DiscJuggler image (*.cdi;*.cdr)\0*.cdi;*.cdr\0All files (*.*)\0*.*\0\0";
+     ofn.nFilterIndex = 1;
+     ofn.lpstrDefExt = "cdi";
+     ofn.lpstrTitle = "Select CDI image to open...";
+     ofn.lpstrFileTitle = NULL;
+     ofn.nMaxFileTitle = 0;
+     ofn.lpstrInitialDir = NULL;
+     ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST;
+
+     if (GetOpenFileName(&ofn))
+        strcpy (string, szFile);
+     else
+        return 1;
+
+     return 0;
+}
+
+#endif /*_WIN32*/
+
+
+//////////////////////////////////////////////////////////////////////////////
+
+#ifdef _WIN32
+
+int askpath(char *sz_buf)
+{
+
+// taken (w/small changes) from Olan Patrick's FILEDLGS library (PD)
+
+    BROWSEINFO      bi;
+    LPITEMIDLIST    pidlRoot, pidlChosen;
+    char            pszBuffer[MAX_PATH];
+    char            szChosenFolder[MAX_PATH] = "\\\\";
+    int             retval;
+
+    HWND            hwndf = NULL;
+    DWORD           dwFlags = BIF_RETURNONLYFSDIRS;
+
+    SHGetSpecialFolderLocation(hwndf, CSIDL_DESKTOP, &pidlRoot);
+
+    memset(&bi, 0, sizeof(BROWSEINFO));
+    bi.hwndOwner = hwndf;
+    bi.pidlRoot = pidlRoot;
+    bi.pszDisplayName = pszBuffer;
+    bi.lpszTitle = "Select destination path...";
+    bi.ulFlags = dwFlags;
+
+    retval = 0;
+    if ((pidlChosen = SHBrowseForFolder(&bi)) != NULL)
+    {
+        if (dwFlags & BIF_BROWSEFORCOMPUTER)
+        {
+            strncat(szChosenFolder, pszBuffer, MAX_PATH - 2);
+            retval = 1;
+        }
+        else if (SHGetPathFromIDList(pidlChosen, pszBuffer))
+        {
+            strncpy(szChosenFolder, pszBuffer, MAX_PATH);
+            retval = 1;
+        }
+    }
+    else
+        szChosenFolder[0] = '\0';
+
+    strncpy(sz_buf, szChosenFolder, MAX_PATH);
+    return (retval);
+
+}
+
+#endif /*_WIN32*/
diff -ruN cdirip-0.6.2.orig/cdirip.dev cdirip-0.6.2/cdirip.dev
--- cdirip-0.6.2.orig/cdirip.dev	2002-06-08 02:15:04.000000000 -0400
+++ cdirip-0.6.2/cdirip.dev	2002-06-20 11:22:27.000000000 -0400
@@ -1,79 +1,79 @@
-[Project]
-FileName=cdirip.dev
-Name=CDIrip
-UnitCount=10
-Icon=
-Type=1
-Ver=1
-ObjFiles=
-Includes=
-Libs=
-Resources=
-Compiler=
-Linker=-lcomdlg32 -lshell32
-IsCpp=0
-PrivateResource=
-ResourceIncludes=
-ExeOutput=
-ObjectOutput=
-
-[Unit1]
-FileName=cdirip.c
-FileTime=747156571
-Open=1
-Top=1
-
-[Unit2]
-FileName=cdirip.h
-FileTime=747156166
-Open=1
-Top=0
-
-[Unit3]
-FileName=buffer.c
-FileTime=710438711
-Open=1
-Top=0
-
-[Unit4]
-FileName=buffer.h
-FileTime=710251984
-Open=1
-Top=0
-
-[Unit5]
-FileName=cdi.c
-FileTime=746760743
-Open=1
-Top=0
-
-[Unit6]
-FileName=cdi.h
-Open=1
-Top=0
-
-[Unit7]
-FileName=common.h
-FileTime=746756559
-Open=1
-Top=0
-
-[Unit8]
-FileName=common.c
-FileTime=746760743
-Open=1
-Top=0
-
-[Unit9]
-FileName=audio.c
-Open=1
-Top=0
-
-[Unit10]
-FileName=audio.h
-Open=1
-Top=0
-
-[Views]
-ProjectView=1
-
+[Project]
+FileName=cdirip.dev
+Name=CDIrip
+UnitCount=10
+Icon=
+Type=1
+Ver=1
+ObjFiles=
+Includes=
+Libs=
+Resources=
+Compiler=
+Linker=-lcomdlg32 -lshell32
+IsCpp=0
+PrivateResource=
+ResourceIncludes=
+ExeOutput=
+ObjectOutput=
+
+[Unit1]
+FileName=cdirip.c
+FileTime=747156571
+Open=1
+Top=1
+
+[Unit2]
+FileName=cdirip.h
+FileTime=747156166
+Open=1
+Top=0
+
+[Unit3]
+FileName=buffer.c
+FileTime=710438711
+Open=1
+Top=0
+
+[Unit4]
+FileName=buffer.h
+FileTime=710251984
+Open=1
+Top=0
+
+[Unit5]
+FileName=cdi.c
+FileTime=746760743
+Open=1
+Top=0
+
+[Unit6]
+FileName=cdi.h
+Open=1
+Top=0
+
+[Unit7]
+FileName=common.h
+FileTime=746756559
+Open=1
+Top=0
+
+[Unit8]
+FileName=common.c
+FileTime=746760743
+Open=1
+Top=0
+
+[Unit9]
+FileName=audio.c
+Open=1
+Top=0
+
+[Unit10]
+FileName=audio.h
+Open=1
+Top=0
+
+[Views]
+ProjectView=1
+
diff -ruN cdirip-0.6.2.orig/cdirip.h cdirip-0.6.2/cdirip.h
--- cdirip-0.6.2.orig/cdirip.h	2002-04-09 02:44:12.000000000 -0400
+++ cdirip-0.6.2/cdirip.h	2002-06-20 11:37:26.000000000 -0400
@@ -1,84 +1,82 @@
-#ifndef __CDIRIP_H__
-#define __CDIRIP_H__
-
-
-#define true  1
-#define false 0
-
-#define DEFAULT_FORMAT   0
-#define ISO_FORMAT       1
-#define BIN_FORMAT       2
-#define MAC_FORMAT       3
-
-#define WAV_FORMAT       0
-#define RAW_FORMAT       1
-#define CDA_FORMAT       2
-#define AIFF_FORMAT      3
-
-#define SHOW_INTERVAL 2000
-
-#define READ_BUF_SIZE  1024*1024
-#define WRITE_BUF_SIZE 1024*1024
-
-
-typedef struct opts_s
-       {
-       char showinfo;
-       char cutfirst;
-       char cutall;
-       char convert;
-       char fulldata;
-       char audio;
-       char swap;
-       char showspeed;
-       char pregap;
-       } opts_s;
-
-typedef struct flags_s
-       {
-       char ask_for_image;
-       char ask_for_dest_path;
-       char do_cut;
-       char do_convert;
-       char create_cuesheet;
-       char save_as_iso;
-       } flags_s;
-
-
-void savetrack(FILE *fsource, image_s *, track_s *, opts_s *, flags_s *);
-void savecuesheet(FILE *fcuesheet, image_s *, track_s *, opts_s *, flags_s *);
-
-void show_counter(unsigned long i, long track_length, unsigned long image_length, long pos);
-
-#ifdef _WIN32
-int askfilename(char *string);
-int askpath(char *sz_buf);
-void show_speed (unsigned long sector_size, LARGE_INTEGER Frequency, LARGE_INTEGER *old_count);
-#endif
-
-
-// Strings
-
-#ifdef _WIN32
-static char STR_TDISC_CUE_FILENAME  [ ] = "TDisc.cue";
-static char STR_TDISCN_CUE_FILENAME [ ] = "TDisc%d.cue";
-static char STR_TAUDIO_RAW_FILENAME [ ] = "TAudio%02d.raw";
-static char STR_TAUDIO_WAV_FILENAME [ ] = "TAudio%02d.wav";
-static char STR_TAUDIO_CDA_FILENAME [ ] = "TAudio%02d.cda";
-static char STR_TAUDIO_AIFF_FILENAME [ ] = "TAudio%02d.aiff";
-static char STR_TDATA_ISO_FILENAME  [ ] = "TData%02d.iso";
-static char STR_TDATA_BIN_FILENAME  [ ] = "TData%02d.bin";
-#else
-static char STR_TDISC_CUE_FILENAME   [ ] = "tdisc.cue";
-static char STR_TDISCN_CUE_FILENAME  [ ] = "tdisc%d.cue";
-static char STR_TAUDIO_RAW_FILENAME  [ ] = "taudio%02d.raw";
-static char STR_TAUDIO_WAV_FILENAME  [ ] = "taudio%02d.wav";
-static char STR_TAUDIO_CDA_FILENAME  [ ] = "taudio%02d.cda";
-static char STR_TAUDIO_AIFF_FILENAME [ ] = "taudio%02d.aiff";
-static char STR_TDATA_ISO_FILENAME   [ ] = "tdata%02d.iso";
-static char STR_TDATA_BIN_FILENAME   [ ] = "tdata%02d.bin";
-#endif
-
-
-
-#endif
+#ifndef __CDIRIP_H__
+#define __CDIRIP_H__
+
+
+#define true  1
+#define false 0
+
+#define DEFAULT_FORMAT   0
+#define ISO_FORMAT       1
+#define BIN_FORMAT       2
+#define MAC_FORMAT       3
+
+#define WAV_FORMAT       0
+#define RAW_FORMAT       1
+#define CDA_FORMAT       2
+#define AIFF_FORMAT      3
+
+#define SHOW_INTERVAL 2000
+
+#define READ_BUF_SIZE  1024*1024
+#define WRITE_BUF_SIZE 1024*1024
+
+
+typedef struct opts_s
+       {
+       char showinfo;
+       char cutfirst;
+       char cutall;
+       char convert;
+       char fulldata;
+       char audio;
+       char swap;
+       char showspeed;
+       char pregap;
+       } opts_s;
+
+typedef struct flags_s
+       {
+       char ask_for_image;
+       char ask_for_dest_path;
+       char do_cut;
+       char do_convert;
+       char create_cuesheet;
+       char save_as_iso;
+       } flags_s;
+
+
+void savetrack(FILE *fsource, image_s *, track_s *, opts_s *, flags_s *);
+void savecuesheet(FILE *fcuesheet, image_s *, track_s *, opts_s *, flags_s *);
+
+void show_counter(unsigned long i, long track_length, unsigned long image_length, long pos);
+
+#ifdef _WIN32
+int askfilename(char *string);
+int askpath(char *sz_buf);
+void show_speed (unsigned long sector_size, LARGE_INTEGER Frequency, LARGE_INTEGER *old_count);
+#endif /*_WIN32*/
+
+
+// Strings
+
+#ifdef _WIN32
+static char STR_TDISC_CUE_FILENAME  [ ] = "TDisc.cue";
+static char STR_TDISCN_CUE_FILENAME [ ] = "TDisc%d.cue";
+static char STR_TAUDIO_RAW_FILENAME [ ] = "TAudio%02d.raw";
+static char STR_TAUDIO_WAV_FILENAME [ ] = "TAudio%02d.wav";
+static char STR_TAUDIO_CDA_FILENAME [ ] = "TAudio%02d.cda";
+static char STR_TAUDIO_AIFF_FILENAME [ ] = "TAudio%02d.aiff";
+static char STR_TDATA_ISO_FILENAME  [ ] = "TData%02d.iso";
+static char STR_TDATA_BIN_FILENAME  [ ] = "TData%02d.bin";
+#else
+static char STR_TDISC_CUE_FILENAME   [ ] = "tdisc.cue";
+static char STR_TDISCN_CUE_FILENAME  [ ] = "tdisc%d.cue";
+static char STR_TAUDIO_RAW_FILENAME  [ ] = "taudio%02d.raw";
+static char STR_TAUDIO_WAV_FILENAME  [ ] = "taudio%02d.wav";
+static char STR_TAUDIO_CDA_FILENAME  [ ] = "taudio%02d.cda";
+static char STR_TAUDIO_AIFF_FILENAME [ ] = "taudio%02d.aiff";
+static char STR_TDATA_ISO_FILENAME   [ ] = "tdata%02d.iso";
+static char STR_TDATA_BIN_FILENAME   [ ] = "tdata%02d.bin";
+#endif /*_WIN32*/
+
+#endif /* __CDIRIP_H__*/
Binary files cdirip-0.6.2.orig/cdirip.o and cdirip-0.6.2/cdirip.o differ
diff -ruN cdirip-0.6.2.orig/common.c cdirip-0.6.2/common.c
--- cdirip-0.6.2.orig/common.c	2002-04-09 02:44:12.000000000 -0400
+++ cdirip-0.6.2/common.c	2002-06-20 11:39:13.000000000 -0400
@@ -1,122 +1,122 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#ifdef _WIN32
-#include <windows.h>
-#endif
-#include "common.h"
-
-
-long fread_as_little (void *buf, long length, FILE *fsource)
-{
-     char *tmp;
-     long i;
-
-     tmp = buf;
-
-#ifdef BIG_ENDIAN
-     for (i = length; i > 0; i--)
-         if (!fread(&(tmp[i-1]), 1, 1, fsource)) return 0; // error
-#else
-     for (i = 0; i < length; i++)
-         if (!fread(&(tmp[i]), 1, 1, fsource)) return 0; // error
-#endif
-
-return 1; // success
-}
-
-long fread_as_big (void *buf, long length, FILE *fsource)
-{
-     char *tmp;
-     long i;
-
-     tmp = buf;
-
-#ifdef BIG_ENDIAN
-     for (i = 0; i < length; i++)
-         if (!fread(&(tmp[i]), 1, 1, fsource)) return 0; // error
-#else
-     for (i = length; i > 0; i--)
-         if (!fread(&(tmp[i-1]), 1, 1, fsource)) return 0; // error
-#endif
-
-return 1; // success
-}
-
-long fwrite_as_little (void *buf, long length, FILE *fdest)
-{
-     char *tmp;
-     long i;
-
-     tmp = buf;
-
-#ifdef BIG_ENDIAN
-     for (i = length; i > 0; i--)
-         if (!fwrite(&(tmp[i-1]), 1, 1, fdest)) return 0; // error
-#else
-     for (i = 0; i < length; i++)
-         if (!fwrite(&(tmp[i]), 1, 1, fdest)) return 0; // error
-#endif
-
-return 1; // success
-}
-
-long fwrite_as_big (void *buf, long length, FILE *fdest)
-{
-     char *tmp;
-     long i;
-
-     tmp = buf;
-
-#ifdef BIG_ENDIAN
-     for (i = 0; i < length; i++)
-         if (!fwrite(&(tmp[i]), 1, 1, fdest)) return 0; // error
-#else
-     for (i = length; i > 0; i--)
-         if (!fwrite(&(tmp[i-1]), 1, 1, fdest)) return 0; // error
-#endif
-
-return 1; // success
-}
-
-
-void error_exit(long errcode, char *string)
-{
-
-char errmessage[256];
-
-#ifdef _WIN32
-HWND hWnd = NULL;
-#endif
-
-    if (errcode != ERR_GENERIC)
-       printf("\n%s: %s\n", string, strerror(errno));  // string is used as Filename
-
-    switch(errcode)
-          {
-          case ERR_OPENIMAGE:
-                   strcpy(errmessage, "File not found\n\nYou may have typed a wrong name or path to source CDI image");
-                   break;
-          case ERR_SAVETRACK:
-                   strcpy(errmessage, "Could not save track");
-                   break;
-          case ERR_READIMAGE:
-                   strcpy(errmessage, "Error reading image");
-                   break;
-          case ERR_PATH:
-                   strcpy(errmessage, "Could not find destination path");
-                   break;
-          case ERR_GENERIC:
-          default: strcpy(errmessage, string);          // string is used as Error message
-          }
-
-#ifdef _WIN32
-    MessageBoxA(hWnd, errmessage, NULL, MB_OK | MB_ICONERROR);
-    ExitProcess(0);
-#else
-    printf(errmessage);
-    exit(EXIT_FAILURE);
-#endif
-
-}
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#ifdef _WIN32
+#include <windows.h>
+#endif
+#include "common.h"
+
+
+long fread_as_little (void *buf, long length, FILE *fsource)
+{
+     char *tmp;
+     long i;
+
+     tmp = buf;
+
+#ifdef BIG_ENDIAN
+     for (i = length; i > 0; i--)
+         if (!fread(&(tmp[i-1]), 1, 1, fsource)) return 0; // error
+#else
+     for (i = 0; i < length; i++)
+         if (!fread(&(tmp[i]), 1, 1, fsource)) return 0; // error
+#endif /*BIG_ENDIN*/
+
+return 1; // success
+}
+
+long fread_as_big (void *buf, long length, FILE *fsource)
+{
+     char *tmp;
+     long i;
+
+     tmp = buf;
+
+#ifdef BIG_ENDIAN
+     for (i = 0; i < length; i++)
+         if (!fread(&(tmp[i]), 1, 1, fsource)) return 0; // error
+#else
+     for (i = length; i > 0; i--)
+         if (!fread(&(tmp[i-1]), 1, 1, fsource)) return 0; // error
+#endif /*BIG_ENDIN*/
+
+return 1; // success
+}
+
+long fwrite_as_little (void *buf, long length, FILE *fdest)
+{
+     char *tmp;
+     long i;
+
+     tmp = buf;
+
+#ifdef BIG_ENDIAN
+     for (i = length; i > 0; i--)
+         if (!fwrite(&(tmp[i-1]), 1, 1, fdest)) return 0; // error
+#else
+     for (i = 0; i < length; i++)
+         if (!fwrite(&(tmp[i]), 1, 1, fdest)) return 0; // error
+#endif /*BIG_ENDIN*/
+
+return 1; // success
+}
+
+long fwrite_as_big (void *buf, long length, FILE *fdest)
+{
+     char *tmp;
+     long i;
+
+     tmp = buf;
+
+#ifdef BIG_ENDIAN
+     for (i = 0; i < length; i++)
+         if (!fwrite(&(tmp[i]), 1, 1, fdest)) return 0; // error
+#else
+     for (i = length; i > 0; i--)
+         if (!fwrite(&(tmp[i-1]), 1, 1, fdest)) return 0; // error
+#endif /*BIG_ENDIN*/
+
+return 1; // success
+}
+
+
+void error_exit(long errcode, char *string)
+{
+
+char errmessage[256];
+
+#ifdef _WIN32
+HWND hWnd = NULL;
+#endif /*_WIN32*/
+
+    if (errcode != ERR_GENERIC)
+       printf("\n%s: %s\n", string, strerror(errno));  // string is used as Filename
+
+    switch(errcode)
+          {
+          case ERR_OPENIMAGE:
+                   strcpy(errmessage, "File not found\n\nYou may have typed a wrong name or path to source CDI image\n");
+                   break;
+          case ERR_SAVETRACK:
+                   strcpy(errmessage, "Could not save track\n");
+                   break;
+          case ERR_READIMAGE:
+                   strcpy(errmessage, "Error reading image\n");
+                   break;
+          case ERR_PATH:
+                   strcpy(errmessage, "Could not find destination path\n");
+                   break;
+          case ERR_GENERIC:
+          default: strcpy(errmessage, string);          // string is used as Error message
+          }
+
+#ifdef _WIN32
+    MessageBoxA(hWnd, errmessage, NULL, MB_OK | MB_ICONERROR);
+    ExitProcess(0);
+#else
+    printf(errmessage);
+    exit(EXIT_FAILURE);
+#endif /*_WIN32*/
+
+}
diff -ruN cdirip-0.6.2.orig/common.h cdirip-0.6.2/common.h
--- cdirip-0.6.2.orig/common.h	2002-04-09 02:44:12.000000000 -0400
+++ cdirip-0.6.2/common.h	2002-06-20 11:39:42.000000000 -0400
@@ -1,60 +1,59 @@
-#ifndef __COMMON_H__
-#define __COMMON_H__
-
-/* Error codes */
-
-#define ERR_GENERIC   0L
-#define ERR_OPENIMAGE 0x01
-#define ERR_SAVETRACK 0x02
-#define ERR_READIMAGE 0x03
-#define ERR_SAVEIMAGE 0x04
-#define ERR_PATH      0x05
-
-
-/* For Debug only! */
-
-// #define DEBUG_CDI
-
-
-
-/* Basic structures */
-
-typedef struct image_s
-       {
-       long               header_offset;
-       long               header_position;
-       long               length;
-       unsigned long      version;
-       unsigned short int sessions;
-       unsigned short int tracks;
-       unsigned short int remaining_sessions;
-       unsigned short int remaining_tracks;
-       unsigned short int global_current_session;
-       } image_s;
-
-typedef struct track_s
-       {
-       unsigned short int global_current_track;
-       unsigned short int number;
-       long               position;
-       unsigned long      mode;
-       unsigned long      sector_size;
-       unsigned long      sector_size_value;
-       long               length;
-       long               pregap_length;
-       long               total_length;
-       unsigned long      start_lba;
-       unsigned char      filename_length;
-       } track_s;
-
-
-/* Functions */
-
-long fread_as_little(void *buf, long length, FILE *fsource);
-long fread_as_big(void *buf, long length, FILE *fsource);
-long fwrite_as_little(void *buf, long length, FILE *fdest);
-long fwrite_as_big(void *buf, long length, FILE *fdest);
-
-void error_exit(long errcode, char *string);
-
-#endif
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+/* Error codes */
+
+#define ERR_GENERIC   0L
+#define ERR_OPENIMAGE 0x01
+#define ERR_SAVETRACK 0x02
+#define ERR_READIMAGE 0x03
+#define ERR_SAVEIMAGE 0x04
+#define ERR_PATH      0x05
+
+
+/* For Debug only! */
+
+// #define DEBUG_CDI
+
+
+/* Basic structures */
+
+typedef struct image_s
+       {
+       long               header_offset;
+       long               header_position;
+       long               length;
+       unsigned long      version;
+       unsigned short int sessions;
+       unsigned short int tracks;
+       unsigned short int remaining_sessions;
+       unsigned short int remaining_tracks;
+       unsigned short int global_current_session;
+       } image_s;
+
+typedef struct track_s
+       {
+       unsigned short int global_current_track;
+       unsigned short int number;
+       long               position;
+       unsigned long      mode;
+       unsigned long      sector_size;
+       unsigned long      sector_size_value;
+       long               length;
+       long               pregap_length;
+       long               total_length;
+       unsigned long      start_lba;
+       unsigned char      filename_length;
+       } track_s;
+
+
+/* Functions */
+
+long fread_as_little(void *buf, long length, FILE *fsource);
+long fread_as_big(void *buf, long length, FILE *fsource);
+long fwrite_as_little(void *buf, long length, FILE *fdest);
+long fwrite_as_big(void *buf, long length, FILE *fdest);
+
+void error_exit(long errcode, char *string);
+
+#endif /*__COMMON_H__*/
Binary files cdirip-0.6.2.orig/common.o and cdirip-0.6.2/common.o differ
